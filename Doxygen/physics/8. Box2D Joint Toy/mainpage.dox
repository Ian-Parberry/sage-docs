/**
\mainpage notitle

\anchor section1
# 1. Introduction

The Box2D Joint Toy demonstrates some important Box2D joints, including
revolute, gear, prismatic, wheel, distance, and pulley joints.
It is divided into 7 levels.
This code demo has no sound.
The remainder of this page is divided into six sections.
\ref section2 "Section 2" lists the controls
and their corresponding actions,
\ref section3 "Section 3" tells you how to build it,
\ref section4 "Section 4" gives you a list of actions to take in the game to see some of its
important features,
\ref section5 "Section 5" gives a breakdown of the code,
important features,
\ref section6 "Section 6" contains some programming problems,
and
\ref section7 "Section 7" addresses the question "what next?".

\anchor section2
# 2. Keyboard Controls

<center>
<table>
<tr>
<td><center><b>Key</b></center></td>
<td><center><b>Action</b></center></td>
<tr>
<td><center>F1</center></td>
<td>Help (this document)</td>
<tr>
<td><center>F2</center></td>
<td>Toggle draw mode from "sprites only", to "sprites and lines", to "lines only"</td>
<tr>
<td><center>Backspace</center></td>
<td>Reset current level</td>
<tr>
<td><center>Enter</center></td>
<td>Advance to next level</td>
<tr>
<td><center>Space</center></td>
<td>Do an interesting thing (see \ref section4-1 "Section 4.1" to \ref section4-7 "Section 4.7")</td>
<tr>
<td><center>PrtScr (hold down)</center></td>
<td>Save screenshot to a PNG file</td>
<tr>
<td><center>Esc</center></td>
<td>Quit game and close the window</td>
</table>
</center>

\anchor section3
# 3. Building the Game

This code uses <a href="../sage/index.html">SAGE</a>
and <a href="https://github.com/erincatto/Box2D">Box2D</a>.
Make sure that you have followed the
<a href="../install/index.html">SAGE Installation Instructions</a>
and the <a href="../installphysics/index.html">Box2D Installation Instructions</a>.
Navigate to the folder <span style="background-color:#D8E4D8;">`8. Box2D Joint Toy`</span> in your
copy of the <span style="background-color:#D8E4D8;">`sage-physics`</span> repository.
Run <span style="background-color:#D8E4D8;">`checkenv.bat`</span>
to verify that you have set the environment
variables correctly.
Open <span style="background-color:#D8E4D8;">`Box2D Joint Toy.sln`</span>
 with Visual Studio and build the Release configuration.
Alternatively, run <span style="background-color:#D8E4D8;">`Build.bat`</span>
to build both Release and Debug configurations. 

\anchor section4
# 4. Game Play

This toy has 7 levels. As mentioned in \ref section2 "Section 2",
the `Enter` key advances to the next level and the `Backspace` key resets
the current level to the initial conditions.
The levels are as follows:
the windmill (\ref section4-1 "Section 4.1"),
round and square gears (\ref section4-2 "Section 4.2"),
nautilus gears (\ref section4-3 "Section 4.3"),
rack-and-pinion (\ref section4-4 "Section 4.4"),
car and bridge (\ref section4-5 "Section 4.5"),
Newton's cradle (\ref section4-6 "Section 4.6"), and
elephant drop (\ref section4-7 "Section 4.7").
In every level the `Space` bar does an interesting things. These are
described more detail in the subsections below.

\anchor section4-1
## 4.1 The Windmill

\anchor fig1
\image html l1.png "Fig. 1: The windmill." width=60%

A windmill with a revolute joint connecting the vanes to the body.
The revolute joint has a motor (see \ref fig1 "Fig. 1"). 
The `Space` bar reverses the motor's direction of rotation. 
Notice that the vanes take a while to spin up to full speed,
and when the direction of the motor is reversed they slowly spin down
to zero before spinning up in the opposite direction. This is a property
of motors in Box2D and will depend of the mass of the body being rotated.

\anchor section4-2
## 4.2 Gears

\anchor fig2
\image html l2.png "Fig. 2: The gears." width=60%

A system of 9 interlocked gears constructed using revolute and
gear joints (see \ref fig2 "Fig. 2").
The largest
gear has a motor and the others are driven by their
gear joints. The `Space` bar reverses the motor's direction of
rotation. Notice that the gears take a while to spin up to full speed,
and when the direction of the motor is reversed they slowly spin down
to zero before spinning up in the opposite direction.
Notice also how the teeth of the gears appear to mesh.
However, if you look closely you will see that they do not
mesh exactly. This is because we are not computing the physics of the teeth,
we are simply rotating the gears at the right speeds assuming that the
sprites are drawn with teeth that mesh correctly.
The 4 square gears
mesh perfectly the same way that round gears do.
They are cheating in a way - they require no extra code over and
above what is necessary for ordinary round gears.

\anchor section4-3
## 4.3 Nautilus Gears

\anchor fig3
\image html l3.png "Fig. 3: The nautilus gears." width=60%

A pair of <em>nautilus gears</em>, which are gears
in the shape of a nautilus shell (see \ref fig3 "Fig. 3").
The left gear has a revolute joint with a motor. 
The right gear has variable speed, so they cannot be animated by Box2D.
We have to animate it ourselves which means doing a little math,
which we will cover in \ref section5-3 "Section 5.3".  The `Space` bar reverses the motor's direction of rotation. Notice that the gears take a while to spin up to full speed,
and when the direction of the motor is reversed they slowly spin down
to zero before spinning up in the opposite direction.

\anchor section4-4
## 4.4 Rack-and-Pinion

\anchor fig4
\image html l4.png "Fig. 4: The rack-and-pinion." width=60%

A <em>rack-and-pinion</em> consists of a round gear called a <em>pinion</em>
connected to a toothed rod called a <em>rack</em> (see \ref fig4 "Fig. 4").
When the pinion rotates, the rack moves horizontally. 
The pinion has a
revolute joint with a motor. 
The rack is connected to the pinion using a gear joint and a prismatic joint.
The `Space` bar reverses the motor's direction of rotation.
Notice that the pinion takes a while to spin up to full speed,
and when the direction of the motor is reversed it slowly spins down
to zero before spinning up in the opposite direction.
Also notice the sudden stop when the pinion reaches its extreme
left and right positions.

\anchor section4-5
## 4.5 Car and Bridge

\anchor fig5
\image html l5.png "Fig. 5: The car." width=60%

A car drives autonomously back and forth over a pair of ramps
(see \ref fig5 "Fig. 5"). 
The car is constructed using a pair of wheel joints that
have motors. The `Space` bar reverses the motors' directions of rotation.
Notice that the car takes a while to get to full speed,
and when the direction of the motors is reversed it slows down
to zero before speeding up in the opposite direction.
Also notice the suspension that makes the car bounce when
it goes over the ramps.
If you are fast with the `Space` bar you may be able to get
the car stuck. If you do, reset it with the `Backspace` key.

\anchor section4-6
## 4.6 Newton's Cradle

\anchor fig6
\image html l6.png "Fig. 6: Newton's cradle." width=60%

Distance joints are used to construct a 2D
<a href="../newton/index.html">Newton's Cradle</a>
with 6 balls (see \ref fig6 "Fig. 6").
When the balls are stopped, hitting the `Space` bar will lift and release
from 1 to 5 balls in sequence.
After that it should behave like a real Newton's Cradle.
\ref fig7 "Fig. 7" shows a screen shot with one ball raised (left),
and the result after the collision (right).
\ref fig8 "Fig. 8" shows a screen shot with two balls raised (left),
and the result after the collision (right).
When the balls are in motion, the `Space` bar stops them.

\anchor fig7
\image html newton1.png "Fig. 7: Newton's cradle with 1 ball raised (left) and after collision (right)." width=80%

\anchor fig8
\image html newton2.png "Fig. 8: Newton's cradle with 2 balls raised (left) and after collision (right)." width=80%

\anchor section4-7
## 4.7 Elephant Drop

\anchor fig9
\image html l7.png "Fig. 9: The elephant drop before (left) and after (right) the elephant is dropped." width=80%

A pulley joint is used to lift a safe when an elephant is dropped
into a wooden cradle (see \ref fig9 "Fig. 9"). The pulley wheels and ropes are animated in code.
When the elephant is not present, the `Space` bar makes it drop in from above.
When the elephant is present, the `Space` bar makes it disappear.
You can make the elephant appear and disappear at any point in the cradle's
travel, not just when it is at the top or bottom.
Notice that in \ref fig9 "Fig. 9" (right) the cradle is not immediately
below the left rim of the pulley wheel above so that the rope from
the pulley to the cradle is not vertical, whereas that portion of the
rope is perfectly vertical in \ref fig9 "Fig. 9" (left).
This is because the elephant
is not dropped exactly above the center of the cradle, causing it to
rock from side to side as it falls.

\anchor section5
# 5. Code Breakdown

Each of the levels has its own class, each of which is derived from
`CLevel`. `CLevel` contains code and data that will be used by
most of the levels. Some of its functions are stubs.
A pointer to a class representing the current level
is maintained in `CCommon::m_pLevel`, which is of type `CLevel*`.
Many of `CLevel`'s member functions are `virtual` so that they
can be overridden in any particular level class if desired.
Most importantly, `CLevel` has an `std::vector` of pointers to
`CObject` for you to store your objects, and
function `CLevel::Draw` to draw the objects in in
(although of course this may be overridden in derived classes),
a function stub `CLevel::Action` to perform the "interesting action"
in response to the space bar
(see \ref section2 "Section 2"),
and a function stub `CLevel::Move` that will be used in \ref section5-3 "Section 5.3",
\ref section5-4 "Section 5.4", and \ref section5-5 "Section 5.5" to implement
things that are not supported in Box2D.
`CLevel::Move` or a function derivde from it will be called from `CGame::ProcessFrame`
once per animation frame.

The most interesting portions of the code for
each of the level classes is described in the following subsections:
the windmill (\ref section5-1 "Section 5.1"),
round and square gears (\ref section5-2 "Section 5.2"),
nautilus gears (\ref section5-3 "Section 5.3"),
rack-and-pinion (\ref section5-4 "Section 5.4"),
car and bridge (\ref section5-5 "Section 5.5"), and
Newton's cradle (\ref section5-6 "Section 5.6"),
and
elephant drop (\ref section5-7 "Section 5.7").

\anchor section5-1
## 5.1 The Windmill

The windmill level is implemented in class `CWindmill`, which is
derived from `CLevel`.
The `CWindmill` constructor calls `CWindmill::CreateFan` to create
an instance of `CObject` for the fan, which is drawn using the
sprite shown in \ref fig10 "Figure 10" (right);
and calls `CWindmill::CreateBase`
to create an instance of `CObject` for the base, which is drawn using the
sprite shown in \ref fig10 "Figure 10" (left).


\anchor fig10
\image html windmillspr.png "Fig. 10: The windmill sprites for the base (left), and the fan (right)." width=30%

`CObject` has a pointer to a Box2D body `CObject::m_pBody`
of type `b2Body*`.
`CWindmill::CreateFan` declares a body definition `bd`
and sets its `type` and `position` fields.
It then declares an instance of `b2CircleShape` called `s` and sets its
radius to half the width of the sprite in \ref fig10 "Figure 10" (right),
translated from Render World to Physics World coordinates.
It then declares a fixture definition `fd` and sets its shape to `s`
and its density somewhat arbitrarily to `0.1f`.
It then creates a Physics World body for the fan by calling

    m_pPhysicsWorld->CreateBody(&bd)

and saving the pointer to the Box2D body returned in a local
variable `pBody`.
The instance of `CObject` for the fan is then created by calling

    new CObject(eSprite::WindmillFan, pBody)

and pushing the pointer returned at the back of the inherited object list
`CLevel::m_stdObject`. 
Finally, the fixture for the shape is attached to the body by
calling

    pBody->CreateFixture(&fd);

although this could be called before the instance of `CObject` was created.

\anchor fig11
\image html windmill.png "Fig. 11: The windmill level drawn with Box2D bodies in black on top of sprites (left), and bodies only (right)." width=80%

`CWindmill::CreateBase`, on the other hand, creates an instance of `CObject`
with a pointer to a Box2D body that does not have a fixture attached to it.
This results in the sprite for the windmill base being drawn as
in \ref fig11 "Fig. 11" (left), but it does not participate in
Box2D collision detection and response and is not drawn when
only Box2D bodies are drawn as in \ref fig11 "Fig. 11" (right).
As far as Box2D is concerned, then, the world consists of two bodies,
one of which is a circle and the other of which is essentially the empty body.

Returning to the `CWindmill` constructor,
after calling `CWindmill::CreateFan` and `CWindmill::CreateBase`
and saving the `b2Body` pointers in local variables
`pFan` and `pBase`, respectively, it declares a
_revolute joint_ definition `wd`. The word _revolute_ is a synonym
for _rotation_. A revolute joint, then, allows two bodies to rotate
about a single point. If both bodies are dynamic, then the two 
bodies rotate freely, but in our case the body for the windmill base
is given type `b2_staticBody` in  `CWindmill::CreateBase`, which
results in the windmill fan rotating about its center in the expected way.
Various fields of the revolute joint definition `wd` are filled in,
including pointers to the two bodies from `pFan` and `pBase`,
a motor speed and the maximum torque to be applied.
Recall from \ref section4-1 "Section 4.1" that the fan slowly
spins up to speed. The rate at which it does so depends
upon the fan's mass (which depends on its shape and density)
and the motor's torque. Setting the torque ususally requires
a certain amount of try-it-and-see before you arrive at an
appropriate value.

The revolute joint is created from the description in `wd`
by calling

    m_pPhysicsWorld->CreateJoint(&wd)

Unfortunately `b2World::CreateJoint` returns a pointer to a `b2Joint`,
which is a base class from which all Box2D joints are derived.
It's up to us to cast this pointer to the correct
type as follows:

    m_pJoint = (b2RevoluteJoint*)m_pPhysicsWorld->CreateJoint(&wd);

We save this pointer in `CWindmill::m_pJoint` because we
will need to use it in  `CWindmill::Action` to change the
motor speed in response to the space bar in  `CGame::KeyboardHandler`.
This is easily done as follows using `b2RevoluteJoint`'s 
`GetMotorSpeed` and `SetMotorSpeed` functions.

    void CWindmill::Action(){
      m_pJoint->SetMotorSpeed(-m_pJoint->GetMotorSpeed());
    } //Action

A little care must be taken when leaving a level to
ensure that there are no memory leaks.
`CLevel` has a virtual destructor `CLevel::~CLevel` that `delete`s
all of the objects in the object list `CLevel::m_stdObject`.
In turn the `CObject` destructor `CObject::~CObject` calls

    m_pPhysicsWorld->DestroyBody(m_pBody)

to destroy the Box2D body associated with the object. This assumes
that the Box2D Physics World pointed to by `m_pPhysicsWorld`
still exists. This implies that the `CGame` destructor
`CGame::~CGame` must `delete` the current level before it
`delete`s Physics World. This is handled as follows.

    CGame::~CGame(){
      delete m_pRenderer;
      delete m_pLevel;
      delete m_pPhysicsWorld;
    } //destructor


\anchor section5-2
## 5.2 Gears

The Gear level is implemented in class `CGear`, which is
derived from `CLevel`.
It may come as a surprise that if you use `F2` to draw the
Physics World bodies, then you will see a collection
of small non-overlapping circles as shown in \ref fig12 "Fig. 12",
whereas in sprite mode you see gears of different size
as shown in \ref fig2 "Fig. 2" happily rotating at the right speeds.

\anchor fig12
\image html gears.png "Fig. 12: The gear level drawn with Box2D bodies." width=40%

This brings us to what I call the First Law of Computer Graphics:

> If it looks right, it is right.

and also what might be called the First Corollary of Computer Animation:

> The things that you see on the screen don't actually interact - they are just drawn that way.

In this case it might _look_ as if the gears mesh in such a way that the teeth
of one gear pushed against the teeth of the next gear, but that really isn't
so. All we need to do is make sure that the center of each gear
is in the correct place, and that gears that should "contact" rotate at
the correct relative speeds (and of course that the sprites have the correct number and shape of teeth for their size).

\anchor fig13
\image html gear0.png "Fig. 13: The five round gears." width=55%

Consider the five round gears in \ref fig2 "Fig. 2".
As seen in \ref fig13 "Fig. 13", we can number them
0 through 4. Note that gears 2 and 3 have the same diameter, but gears 0, 1, and
differ from them and each other. 

\anchor fig14
\image html gear1.png "Fig. 14: The five round gears drawn so that they appear to mesh." width=30%

These are drawn as shown in \ref fig14 "Fig. 14" positioned and oriented
so that their teeth
appear to mesh together.
As we animated the gears we just need to make sure that they stay that way.
The largest, gear 0, will have a motor, and the others will rotate
at the required speeds and directions.
The relative speeds of rotation are proportional to the radii of the
gears involved, which can be found by counting the teeth, as in \ref fig15 "Fig. 15".

\anchor fig15
\image html gear2.png "Fig. 15: A gear with 12 teeth." width=12%

The relative directions of rotation flip from one gear to the next.
For example, the largest gear in \ref fig16 "Fig. 16" is driven
clockwise by a motor in a clockwise direction as indicated by the
black arrows, while the other gears rotate in the directions indicated by the gray dotted arrows.

\anchor fig16
\image html gear3.png "Fig. 16: Directions of rotation." width=45%

The code for the creation of the gears and their revolute joints is
very similar to the code for the rotating fan in the
Windmill level (see \ref section5-3 "Section 5.3"). 
Pointers to the revolute joints are stored in an `std::vector` of
`b2RevoluteJoint` pointers `CGear::m_stdJoint` by the `CGear` constructor `CGear::CGear`.
`CGear::CreateGearJoint` creates a gear joint
that joins the revolute joints pointed to by `m_stdJoint[i]` and `m_stdJoint[j]`,
with gear ratio `r`, where the unsigned integers `i`, `j`, and the floating point value `r` are parameters.
It does this by declaring a gear joint definition `gd` and filling
in fields for the ratio, pointers to two revolute joints, and pointers to the corresponding two Box2D bodies.
The gear joint is then created by calling

    m_pPhysicsWorld->CreateJoint(&gd);

There is no need to save the joint pointer returned since it does not have any properties that we want to change, and it will be
destroyed when the two revolute joints are destroyed.

Then, for example, the `CGear` constructor `CGear::CGear` makes the four
following function calls for the gear joints joining gears
0 to 1, 2 to 2, 1 to 3, and 3 to 4.
The third parameter in each case the ratio of the number of
teeth in the second gear to the number of teeth in the first gear,
noting that gear 0 has 33 teeth, gear 1 and 4 have 18 teeth, and gears 2 and 3 have 12 teeth.

    CreateGearJoint(0, 1, 18.0f/33.0f); 
    CreateGearJoint(1, 2, 12.0f/18.0f);
    CreateGearJoint(1, 3, 12.0f/18.0f);
    CreateGearJoint(3, 4, 18.0f/12.0f);


\anchor section5-3
## 5.3 Nautilus Gears

The Nautilus Gear level is implemented in class `CNautilusGear`, which is
derived from `CLevel`. A _nautilus shell_ is the shell from the <a href="https://en.wikipedia.org/wiki/Nautilus">cephalopod family _Nautilidae_</a>.
A _nautilus gear_ is made from a cross-section of a nautilus shell, two of which are shown in \ref fig17 "Fig. 17".
The cross-section consists of a series of cells of increasing size that spiral out from a center point.
In \ref fig17 "Fig. 17" the left-hand shell rotates about that point with constant angular velocity,
while the right-hand shell rotates around its central point with angular velocity that increases and decreases over time so that the teeth appear to mesh.
Remember that our task here is not to compute how the teeth mesh, but merely to draw the right-hand gear at an orientation that makes appear that it meshes with the left-hand gear.

\anchor fig17
\image html Nautilus2-342-96.gif "Fig. 17: Animation of two nautilus gears." width=25%

Since Box2D does not directly support nautilus gears,
`CNautilusGear` will override `CLevel::Move` with a function `CNautilusGear::Move`
that computes the orientation of the second gear from the orientation of the first gear.
Recall that this function will be called once per animation frame from `CGame::ProcessFrame`.
Up until now, the function call `m_pLevel->Move()` in `CGame::ProcessFrame` defaults to
`CLevel::Move`, which does nothing.
Before we write code for `CNautilusGear::Move` we will need to derive some mathematics about nautilus gears.
Suppose we have a nautilus gear of maximum radius \f$a\f$ and
minimum radius \f$b\f$, as shown in \ref fig18 "Fig. 18" (left).
The radius of 
a nautilus gear at angle \f$\theta\f$ measured counterclockwise from
the positive \f$x\f$-axis (see \ref fig18 "Fig. 18", right)
is \f$ce^{d\theta}\f$
for some constants \f$c, d\f$ that depend on the particular nautilus shell in question
and \f$e \approx 2.71828\f$ is the base of the natural logarithm.
Since the radius at angle zero is \f$b\f$, \f$b = ce^0\f$, that is, \f$c = b\f$.
Since the radius at angle \f$2 \pi\f$ is \f$a\f$, \f$a = be^{2 d\pi}\f$.
That is, taking the natural logarithm of both sides,
\f$d = \ln (a/b)/2 \pi\f$. Examining our nautilus gear sprite in an image editor,
we find that \f$a=98\f$ and \f$b=34\f$ pixels.

\anchor fig18
\image html nautilus1.png "Fig. 18: Nautilus gear equation." width=40%

We thus begin our code for `CNautilusGear::Move`
with \f$\theta_0\f$, \f$a\f$, \f$b\f$, and \f$d\f$.
Variable `theta0` holds \f$\theta_0\f$, which is the opposite of the gear's orientation
(from the gear's perspective, when it rotates through angle \f$\theta\f$ it is as if
the world has rotated through angle \f$-\theta\f$).
`CNautilusGear` has constant member variables for \f$a, b, d\f$.

    const float a = 98.0f; 
    const float b = 34.0f; 
    const float d = 0.5f*logf(a/b)/b2_pi; 

Since the fixed distance between the gear centers is \f$a+b\f$ (\ref fig19 "Fig. 19", left),
and \f$be^{d\theta_0} + be^{d\theta_1}\f$ (\ref fig19 "Fig. 19", right),
we can deduce that: 

\f[
be^{d\theta_0} + be^{d\theta_1} = a+b
\f]

which implies that, dividing both sides by \f$b\f$ then subtracting \f$e^{d\theta_1}\f$ from both sides:
\f[
e^{d\theta_1} = a/b+1 - e^{d\theta_0}
\f]
and so, taking the natural logarithm of both sides and dividing by \f$d\f$,
\f[
\theta_1 = \ln(a/b + 1 - e^{d\theta_0})/d.
\f]

\anchor fig19
\image html nautilus2.png "Fig. 19: Two nautilus gears." width=55%

Since the right-hand gear starts out at an orientation of \f$\pi\f$,
its orientation is now \f$\pi - \theta_1\f$. The code for `CNautilusGear::Move` is then:

    void CNautilusGear::Move(){
      float theta0 = -m_stdObject[0]->GetBody()->GetAngle(); //left gear angle
      const float b2_2pi = 2.0f*b2_pi; //2 times pi in Physics World
      theta0 -= (UINT)floor(theta0/b2_2pi)*b2_2pi; //normalize theta0 to be in [0, 2pi]
      const float theta1 = logf(a/b + 1.0f - expf(d*theta0))/d; //angle for right gear

      b2Body* pBody = m_stdObject[1]->GetBody(); //body of right gear
      pBody->SetTransform(pBody->GetPosition(), b2_pi - theta1); //orient right gear
    } //Move

The `CNautilusGear` constructor `CNautilusGear::CNautilusGear` calls `CNautilusGear::CreateGear`
once for each gear to create it in the correct position and orientationas shown in
\ref fig19 "Fig. 19", left. It then creates a revolute joint that connects the left gear to a
null background, and enables its motor. This is similar to the `CGear` constructor
`CGear::CGear` we saw in \ref section5-3 "Section 5.3" except that it does not connect the
nautilus gears with a Box2D gear joint. If `CNautilusGear::Move` were not called from 
`CGame::ProcessFrame` (for example, if you comment out the call to `m_pLevel->Move()`),
then the left gear would rotate but the right gear would not.

\anchor section5-4
## 5.4 Rack-and-Pinion

The Rack-and-Pinion level is implemented in class `CRackAndPinion`, which is
derived from `CLevel`. 
Its constructor `CRackAndPinion::CRackAndPinion` calls `CRackAndPinion::CreateRack` to create
the rack (the horizontal part of \ref fig22 "Fig. 22"),
`CRackAndPinion::CreatePinion` to create the pinion,
(the round gear in \ref fig22 "Fig. 22")
and `CRackAndPinion::CreateBase` to create a null physics body for the background.
It also creates a revolute joint for the pinion and stores
a pointer to it in `CRackAndPinion::m_pRevoluteJoint`.

\anchor fig22
\image html rackandpinion.gif "Fig. 22: The rack-and-pinion." width=50%

The horizontal motion of the rack is constrained by a <em>prismatic joint</em> that lets
you set the direction of motion and the limits of travel. 
First we create a prismatic joint definition

    b2PrismaticJointDef pjd;

A call to

    pjd.Initialize(pBase, pRack, pRack->GetPosition(), b2Vec2(1.0f, 0.0f));

specifies pointers to the base body `pBase` and the rack `pRack`, the rack's initial
position `pRack->GetPosition()`, and the unit direction vector pointing the positive X direction.
Note that here and elsewhere it is important to create Box2D bodies in their initial
positions and orientations, in contrast to graphics objects that can be creates at the origin
and translated/rotated to their initial places.
We then specify an upper and lower translation limit and enable limits.

    pjd.lowerTranslation = -m_fLimit;
    pjd.upperTranslation = m_fLimit;
    pjd.enableLimit = true;

We can then create and save the prismatic joint.

    m_pPrismaticJoint = (b2PrismaticJoint*)m_pPhysicsWorld->CreateJoint(&pjd);

A gear joint is used
in order for the rack to move in synchrony with the pinion.
W saw gear joints being used to connect revolute joints
in `\ref section5-2 "Section 5.2".
Here a gear joint will be used to connect a revolute joint (for the pinion)
with a prismatic joint (for the rack)
using the pointers `CRackAndPinion::m_pRevoluteJoint` and `CRackAndPinion::m_pPrismaticJoint`
created above.
To do this we create a gear joint definition
    
    b2GearJointDef gd;

set its ratio field to \f$\pi\f$ divided by half the width of the rack sprite

    gd.ratio = b2_pi/w2;

where we define
    
    const float w = m_pRenderer->GetWidth(eSprite::Rack);
    const float w2 = RW2PW(w)/2.0f;

and set its joint pointers

    gd.joint1 = m_pRevoluteJoint;
    gd.joint2 = m_pPrismaticJoint;

and provide pointers to the respective physics bodies

    gd.bodyA = pPinion;
    gd.bodyB = pRack;

We then go ahead and create the gear joint with a call to

    m_pPhysicsWorld->CreateJoint(&gd);

There is no need to save the joint pointer so we don't.

Recall again that the
pinion does not actually engage with and move the rack: the Box2D joints merely coordinate the
position of the rack with the orientation of the pinion. The teeth are not present in the Box2D
representation of the rack and pinion as shown in \ref fig23 "Fig. 23".
It is up to us to create sprites with the
teeth in the right places to create the illusion of a rack and pinion.

\anchor fig23
\image html shape-rack.png "Fig. 23: The Rack-and-Pinion shapes." width=40%

`CRackAndPinion::Action` is called from the keyboard handler in response to the space bar,
overriding the default `CLevel::Action`. It merely reverses the direction of motion of the
motor on the revolute joint by negating its motor speed.

    void CRackAndPinion::Action(){
      m_pRevoluteJoint->SetMotorSpeed(-m_pRevoluteJoint->GetMotorSpeed());
    } //Action

Although the prismatic joint's limits will prevent the rack from sliding too far to
the left or right, we will need to add code to reverse the motor when either limit is reached.
`CRackAndPinion::Move` is the perfect place to do this.
It compares the prismatic
joint position from `m_pPrismaticJoint->GetJointTranslation()` and the sign of the motor speed
with the corresponding limit and negates the motor speed when the limit is reached.

\anchor section5-5
## 5.5 Car and Bridge

The Car and Bridge level is implemented in class `CCarAndBridge`, which is
derived from `CLevel`. 
Most of what you see in the screenshot shown in \ref fig5 "Fig. 5"
is baked into the background image shown in \ref fig24 "Fig. 24".
The actual shapes in Box2D are shown in \ref fig25 "Fig. 25".

\anchor fig24
\image html carbg.png "Fig. 24: Background image for the Car and Bridge." width=50%

\anchor fig25
\image html shape-car.png "Fig. 25: The Car and Bridge shapes." width=40%

Much of the code for `CCarAndBridge` is similar to the code that we have seen in previous levels,
including the use of `CCarAndBridge::Move` to reverse the car wheel motors when it nears the edge of the window.
However, the wheels are not connected to the rest of the car using revolute joints.
Instead we use <em>wheel joints</em> that allow the wheels to both rotate and
move up and down as shown in \ref fig26 "Fig. 26".

\anchor fig26
\image html car.png "Fig. 26: Degrees of freedom for the car and its wheels." width=25%

This is done by creating an instance of `b2WheelJointDef`, setting and enabling its various motor-related
fields, together with spring damping and stiffness values for the vertical motion.
Finally, its `collideConnected` field is set to `false` so that Box2D will not respond to
collisions between the wheels and the car body.

\anchor section5-6
## 5.6 Newton's Cradle

The Newton's Cradle level is implemented in class `CNewtonsCradle`, which is
derived from `CLevel`. 
Its constructor `CNewtonsCradle::CNewtonsCradle` calls `CNewtonsCradle::Create`
to create the balls and their joints. \ref fig27 "Fig 27" shows that each ball has
a circle shape (compare to \ref fig6 "Fig. 6"). `CNewtonsCradle::Create` calls
`CNewtonsCradle::CreateBall` once for each ball in a `for`-loop, then calls
`CNewtonsCradle::CreateCradle` to create the empty background. Finally
`CNewtonsCradle::Create` creates the lines for the strings joining the
balls to the cradle by calling `CLevel::CreateLine` once for each ball, then
creates a <em>distance joint</em> by filling in an instance of
`b2DistanceJointDef` with the positions of the ends of the strings and calling
`m_pPhysicsWorld->CreateJoint` for each ball.

\anchor fig27
\image html shape-newton.png "Fig. 27: The Newton's Cradle shapes." width=40%


`CNewtonsCradle::ResetBalls` resets the balls to their initial positions with
zero velocity. It does this by deleting the balls, lines, and joints and
re-creating them by calling `CNewtonsCradle::Create` used above in the constructor.
`CNewtonsCradle::CreateBall` deserves a little examination.
Almost all of the code there should be familiar except for the last two lines.
When these are executed the local variable `pBody` points to an instance
of `b2Body` representing the newly created ball. The call to

    pBody->SetAngularDamping(12.0f);

makes sure that the ball does not rotate about its connection point to its distance
joint, which if you examine the code closely will be found at the top of the ball.
Failure to set the angular damping to a high enough level will result in
balls wobbling as shown in \ref fig28 "Fig. 28". Finally, the call to

    pBody->SetLinearDamping(0.1f);

mimics the effect of the balls slowing down due to air friction.

\anchor fig28
\image html newton3.png "Fig. 28: Ball wobble." width=15%

The only interesting thing left is `CNewtonsCradle::Action`, which either
stops the balls with a call to `CNewtonsCradle::ResetBalls` if they are moving
or applies an impulse to the requisite number of them
(see \ref section4-6 "Section 4.6" for a reminder)
by calling `pBody->ApplyLinearImpulse` to apply a horizontal impulse through
the center of each ball body.


\anchor section5-7
## 5.7 Elephant Drop

The Elephant Drop level is implemented in class `CPulley`, which is
derived from `CLevel`. 
As shown in \ref fig9 "Fig. 9" (left), the level starts with an empty cradle
connected to a heavy safe via two pulley wheels and a rope. 
Handily, Box2D includes a joint called `b2b2PulleyJoint` that connects a point
on an instance of `b2Body` to another point on a second instance of `b2Body`.
Here the first body will be the wooden cradle on the left side of 
\ref fig9 "Fig. 9" (left), and the second body will be the safe on the
right side of \ref fig9 "Fig. 9" (left).
The pulley joint is created in the `CPulley` constructor by
filling in an instance of `b2PulleyJointDef` and using

    m_pJoint = (b2PulleyJoint*)m_pPhysicsWorld->CreateJoint;

to save a pointer to the created joint in `CPulley::m_pJoint`.

There will be three bodies with attached shapes (see \ref fig29 "Fig. 29"),
large rectangles 
for the elephant and the safe body respectively, and three narrow overlapping
rectangles for the crate body.
It is a little tedious to get the initial positions of everything lined up
correctly, but you can read the rest of the code for yourself if you wish.

\anchor fig29
\image html shape-elephant.png "Fig. 29: The Elephant Drop shapes." width=40%

Unfortunately Box2D's pulley joint `b2PulleyJoint` does not have the concept of pulley
wheels, just the positions of the ropes suspending the bodies
attached to the joint. It is up to us to animate the pulley
wheels in the correct directions as shown in \ref fig30 "Fig. 30".
Fortunately `b2PulleyJoint` has a member function `GetCurrentLengthA`
that returns the length of the left-hand portion of the rope. From
this we can deduce how far each pulley wheel must rotate.

\anchor fig30
\image html elephant.png "Fig. 30: Direction of motion for Elephant Drop." width=40%

For example, if a call to the pulley joint's `GetCurrentLengthA`
function reveals that the rope has moved distance \f$d\f$
around the circumference of a pulley wheel of radius \f$r\f$ (see
\ref fig31 "Fig. 31") and the angle subtended by that segment is \f$\theta\f$,
then \f$\theta = 2 \pi d/c\f$, where \f$c= 2 \pi r\f$ is the circumference of the circle,
and hence
\f$\theta = d/r\f$.

\anchor fig31
\image html angle.png "Fig. 31: Angle from distance around the circumference." width=12%

This calculation is carried out in `CPulley::Move`.
The orientation of each pulley wheel is then set by calling their `b2Body`'s
`SetTransform` function with \f$\theta\f$ as the orientation parameter
and the the body's current position as the position parameter.

\anchor section6
# 6. Problems

In the folder <span style="background-color:#D8E4D8;">`8. Box2D Joint Toy`</span> in your
copy of the <span style="background-color:#D8E4D8;">`sage-physics`</span> repository
you will find a folder <span style="background-color:#D8E4D8;">Problems</span> which will
contain some code to help you with the problems below.
In the <span style="background-color:#D8E4D8;">Problems</span> folder,
open <span style="background-color:#D8E4D8;">`Gear Toy.sln`</span>
with Visual Studio. 
Each level of the
Gear Toy corresponds to a problem below and it should react to the
key controls in \ref section2 "Section 2".

\anchor section6-1
## 6.1 Round Gear Problems

The first level of the Gear Toy corresponds to \ref problem6-1-1 "Problem 6.1.1"
and displays two gears in their start positions and orientations
as shown in \ref fig32 "Fig. 32".
The second level of the Gear Toy corresponds to \ref problem6-1-2 "Problem 6.1.2"
and displays two gears in their start positions and orientations
as shown in \ref fig33 "Fig. 33".
The third level of the Gear Toy corresponds to \ref problem6-1-3 "Problem 6.1.3"
and displays two gears in their start positions and orientations are also
as shown in \ref fig33 "Fig. 33".

In the following problems, an _external_ gear has teeth on the outside
and an _internal_ gear has teeth on the inside.

\anchor fig32
\image html externalstart.png "Fig. 32: Start position for the first level."  width=180

\anchor fig33
\image html internalstart.png "Fig. 33: Start position for the second and third levels."  width=256

\anchor problem6-1-1
### Problem 6.1.1

<div style="padding-left: 30px;" markdown="1">
Use two revolute joints and a gear joint to create a toy that has
an external gear rotating around a fixed external gear as shown in
\ref fig34 "Fig. 34". 
One revolute joint must have a motor and the other must not.
To make the space bar reverse the motor, simply place a pointer to the revolute
joint with the motor in local variable `m_pJoint` inherited from `CLevel::m_pJoint`.
Your code must go into the `CExternal` constructor `CExternal::CExternal` in
file <span style="background-color:#D8E4D8;">Round.cpp</span>. 
</div>

\anchor fig34
\image html external256.gif "Fig. 34: An external gear rotating around a fixed external gear." 

\anchor problem6-1-2
### Problem 6.1.2

<div style="padding-left: 30px;" markdown="1">
Use two revolute joints and a gear joint to create a toy that has
an external gear rotating inside a fixed internal gear as shown in
\ref fig35 "Fig. 35".
One revolute joint must have a motor and the other must not.
To make the space bar reverse the motor, simply place a pointer to the revolute
joint with the motor in local variable `m_pJoint` inherited from `CLevel::m_pJoint`.
Your code must go into the `CInternal` constructor `CInternal::CInternal` in
file <span style="background-color:#D8E4D8;">Round.cpp</span>. 
</div>

\anchor fig35
\image html internal256.gif "Fig. 35: An external gear rotating inside a fixed internal gear." 

\anchor problem6-1-3
### Problem 6.1.3

<div style="padding-left: 30px;" markdown="1">
Use two revolute joints and a gear joint to create a toy that has
an internal gear rotating around a fixed external gear as shown in
\ref fig36 "Fig. 36".
One revolute joint must have a motor and the other must not.
To make the space bar reverse the motor, simply place a pointer to the revolute
joint with the motor in local variable `m_pJoint` inherited from `CLevel::m_pJoint`.
Your code must go into the `CInternal2` constructor `CInternal2::CInternal2` in
file <span style="background-color:#D8E4D8;">Round.cpp</span>. 
</div>

\anchor fig36
\image html internal2-320.gif "Fig. 36: An internal gear rotating around a fixed external gear." 

\anchor section6-2
## 6.2 Elliptical Gear Problems

The fourth level of the Gear Toy corresponds to \ref problem6-2-1 "Problem 6.2.1"
and displays two elliptical gears with the left gear driven by a
motor as shown in \ref fig35 "Fig.35" and the right gear in its initial position.
The fifth level of the Gear Toy corresponds to \ref problem6-2-2 "Problem 6.2.2"
and displays two elliptical gears with the left gear driven by a
motor as shown in \ref fig35 "Fig.35" and the right gear in its initial position.
Before we start writing code we need some basic math facts about ellipses.

An _ellipse_ is a shape that is
formed as follows. Choose two distinct points
called the _foci_ (the singular of which is _focus_) and a distance \f$d\f$. The perimeter
of the ellipse is the set of all points \f$p\f$
such that the sum of the two distances from \f$p\f$ to the foci is equal to \f$d\f$.
In \ref fig37 "Fig. 37" (left), the point \f$p\f$ is on the perimeter of the ellipse
because \f$d_0 + d_1 = d\f$. 
If we place the foci on a horizontal line, then the ellipse is
symmetrical about horizontal and vertical lines through its center, and the foci are
on the horizontal center line equidistant from the center, as we can see in \ref fig37 "Fig. 37" (right).

\anchor fig37
\image html ellipsedef.png "Fig. 37: Some ellipse definitions." width=40%

Let \f$a\f$ be the length of the major (horizontal) axis, \f$b\f$ be the length of the minor (vertical)
axis, and \f$c\f$ be the _focal distance_, that is, the distance from the center to either focus
(see \ref fig37 "Fig. 37" (right)).
The focal distance \f$c\f$ is uniquely defined by the major and minor radii \f$a\f$ and \f$b\f$.
That is, if we know \f$a\f$ and \f$b\f$, then we can calculate \f$c\f$. This means that we can download
an image of an elliptical gear from the internet, measure its height and width, and
calculate \f$c\f$ as follows. 

Let \f$p_0\f$ be a point at the end of the horizontal axis through the center of the ellipse.
Then, as shown in \ref fig38 "Fig. 38" (left), the distance from \f$p_0\f$ to the leftmost
focus is \f$a-c\f$ and the distance from \f$p_0\f$ to the rightmost focus is \f$a-c+2c=a+c\f$. The sum of
the two distances is therefore \f$2a\f$. Let \f$p_1\f$ be a point at the end of the vertical axis
through the center of the ellipse. 
Then, as shown in \ref fig38 "Fig. 38" (right) \f$p_1\f$ is at distance \f$\sqrt{c^2+b^2}\f$ from each focus,
which means that the sum of the distances is \f$2\sqrt{c^2+b^2}\f$.
Since both \f$p_0\f$ and \f$p_1\f$ are on the perimeter of the ellipse, it must be the case that
\f$2\sqrt{c^2+b^2} = 2a\f$, that is, \f$c = \sqrt{a^2 - b^2}\f$.

\anchor fig38
\image html ellipse-f.png "Fig. 38: Calculating the focal distance." width=40%

Let \f$p = (x,y)\f$ be the coordinates of a point on an ellipse with major radius \f$a\f$
and minor radius \f$b\f$ centered at the origin. The sum of the distances from \f$p\f$ to the two focal points is
\f[
\sqrt{(x+c)^2 + y^2} + \sqrt{(x-c)^2 + y^2}  =  2a.
\f]
That is,
\f[
\sqrt{(x+c)^2 + y^2}  =  2a - \sqrt{(x-c)^2 + y^2}.
\f]
Squaring both sides,
\f[
\begin{align*}
(x+c)^2 + y^2  &=  \left( 2a - \sqrt{(x-c)^2 + y^2} \right)^2\\
x^2 + 2cx + c^2 + y^2 &=  4a^2 - 4a \sqrt{(x-c)^2 + y^2} + (x-c)^2 + y^2\\
2cx  &=  4a^2 - 4a \sqrt{(x-c)^2 + y^2} - 2cx\\
a^2 - cx  &=  a \sqrt{(x-c)^2 + y^2}.
\end{align*}
\f]
Squaring both sides again,
\f[
\begin{align*}
(a^2 - cx)^2  &=  a^2 ((x-c)^2 + y^2)\\
c^2x^2 + a^4 &=  a^2x^2 + a^2c^2 + a^2y^2\\
a^4 - a^2c^2 &=  a^2x^2 - c^2x^2 + a^2y^2\\
a^2 (a^2 - c^2) &=  (a^2 - c^2)x^2 + a^2y^2
\end{align*}
\f]
Since \f$c^2 = a^2 + b^2\f$, we can now substitute for \f$b^2 = c^2 - a^2\f$.
\f[
a^2b^2  =  b^2 x^2 + a^2 y^2.
\f]
Dividing both sides by \f$a^2b^2\f$,
\f[
\frac{x^2}{a^2} + \frac{y^2}{b^2} = 1. \label{eq1}\tag{Equation 1}
\f]
\f$\ref{eq1}\f$ is the equation for an ellipse in Cartesian coordinates.

Sometimes it is more useful to know the equation of an ellipse in polar coordinates.
Let \f$r\f$ be the length of a line at angle \f$\theta\f$ counterclockwise from the long axis.
This line ends at some point \f$p=(r\cos \theta, r \sin\theta)\f$ on the ellipse.
Therefore, by \f$\ref{eq1}\f$,
\f[
\frac{r^2\cos^2 \theta}{a^2} + \frac{r^2\sin^2 \theta}{b^2} = 1.
\f]
That is,
\f[
r = \frac{ab}{\sqrt{b^2\cos^2 \theta + a^2 \sin^2 \theta}}. \label{eq2}\tag{Equation 2}
\f]
\f$\ref{eq2}\f$ is the equation for an ellipse in polar coordinates.

As in \ref section6-1 "Section 6.1",
navigate to the <span style="background-color:#D8E4D8;">Problems</span> folder and
open <span style="background-color:#D8E4D8;">`Gears.sln`</span>
with Visual Studio. 
When you compile and run it,
each level will correspond to a problem below and it should react to the
key controls in \ref section2 "Section 2" with the exception
of the space bar, more of which later.
The first level corresponds to \ref problem6-1-1 "Problem 6.1.1"
and displays two gears in their start positions and orientations
as shown in \ref fig32 "Fig. 32".
The second level corresponds to \ref problem6-1-2 "Problem 6.1.2"
and displays two gears in their start positions and orientations
as shown in \ref fig37 "Fig. 37".

\anchor problem6-2-1
### Problem 6.2.1

<div style="padding-left: 30px;" markdown="1">
Consider the two meshed elliptical gears rotating around their centers shown in \ref fig35 "Fig.35".
The left gear is driven by a motor at a constant rate of rotation.
The gear rotates at a varying rate that has two local maxima and
two local minima per revolution. These are called _double lobe_ elliptical gears.
Suppose that the gear on the left of \ref fig36 "Fig. 36" is rotated counterclockwise
through angle \f$\theta_0\f$. Then the gear on the right rotates counterclockwise through some angle
\f$\pi/2 - \theta_1\f$
in order to keep the sum of the two radii along the line joining their centers \f$r_0+r_1\f$ constant.
</div>

\anchor fig35
\image html DoubleLobe.gif "Fig. 35: Double-lobe elliptical gears." width=300

\anchor fig36
\image html ellipserotate.png "Fig. 36: Double-lobe elliptical gears." width=50%

<div style="padding-left: 30px;" markdown="1">
We can calculate \f$\theta_1\f$ from \f$\theta_0\f$ in three steps.
First we calculate \f$r_0\f$ from \f$\theta_0\f$.
Then we calculate \f$r_1\f$ from \f$r_0\f$.
Then we calculate \f$\theta_1\f$ from \f$r_1\f$.
The first two steps are easy.
By \f$\ref{eq2}\f$,
\f[
r_0 = \frac{ab}{\sqrt{b^2 \cos^2 \theta_0 + a^2 \sin^2 \theta_0}}.
\f]
Since the initial position of the gears has one gear rotated by \f$\pi/2\f$ with respect to
the other (see \ref fig36 "Fig. 36", left), 
\f$r_0+r_1=a+b\f$. 
Therefore, \f$r_1 = a+b-r_0\f$.

Now that we have \f$r_1\f$
we can calculate \f$\theta_1\f$  as follows.
By \f$\ref{eq2}\f$,
\f[
r_1^2 = \frac{a^2b^2}{b^2 \cos^2 (\theta_1 + \pi/2) + a^2 \sin^2 (\theta_1 + \pi/2)},
\f]
and therefore, inverting both sides and multiplying by \f$ab\f$,
\f[
a^2 b^2/r_1^2 = b^2 \cos^2 (\theta_1 + \pi/2) + a^2 \sin^2 (\theta_1 + \pi/2) .
\f]
Since (by the Theorem of Pythagoras), 
\f$\sin^2 (\theta_1 + \pi/2) = 1 - \cos^2 (\theta_1 + \pi/2)\f$, we
Substitute for \f$\sin^2 \theta_1\f$ in the above,
\f[
b^2 \cos^2 (\theta_1 + \pi/2)_1 + a^2 (1 - (\theta_1 + \pi/2)^2 \theta_1) = a^2 b^2/r_1^2.
\f]
Therefore,
\f[
\cos^2 (\theta_1 + \pi/2) = (a^2 b^2/r_1^2 - a^2)/(b^2 - a^2),
\f]
that is, since \f$\cos (x + \pi/2) = \sin x\f$ for all angles \f$x\f$,
\f[
\sin^2 \theta_1  = (a^2 b^2/r_1^2 - a^2)/(b^2 - a^2).
\f]
Therefore,
\f[
\theta_1 =  \sin^{-1} (
\sqrt{a^2 - a^2 b^2/r_1^2}/f
) ,
\f]
where \f$f\f$ is the focal distance.
We can therefore compute \f$\theta_1\f$ from \f$\theta_0\f$ and the
major and minor radiuses of the elliptical gears \f$a\f$ and \f$b\f$ respectively
as follows:

    const float ComputeTheta1(const float a, const float b, const float theta0){
      const float x = b*cosf(theta0);
      const float y = a*sinf(theta0);
      const float r0 = a*b/(sqrtf(x*x + y*y));
      const float r1 = a + b - r0;
      const float f = sqrtf(a*a - b*b); //focal distance
      const float d = a*b/r1;
  
      return asinf(sqrt(a*a - d*d)/f); 
    } //ComputeTheta1

Therefore the right gear has to be rotated a quarter of a turn counterclockwise from its
initial orientation plus \f$\theta_1\f$ clockwise
to angle \f$b2_pi - \theta_1\f$. Finally, `asinf` returns a value in the first
or second quadrant,
whereas we want an angle that can be in any quadrant. The correct quadrant needs to be corrected in
code or else the right gear sprite will jump from one orientation to another at multiples of \f$\pi/2\f$..

Level 4 of the Gear Toy shows two elliptical gears with the left gear driven
by a motor as in \ref fig35 "Fig. 35" and the right gear static in its initial position.
Write code for function `CEllipticalGear2::Move` in
file <span style="background-color:#D8E4D8;">Elliptical.cpp</span>
to rotate the right gear meshed with the left gear as shown in \ref fig35 "Fig. 35". 
You may use function `ComputeTheta1` as described above.
</div>

\anchor problem6-2-2
### Problem 6.2.2

<div style="padding-left: 30px;" markdown="1">
Consider the two meshed elliptical gears rotating around their centers shown in \ref fig37 "Fig.37".
The left gear is driven by a motor at a constant rate of rotation.
The gear rotates at a varying rate that has one local maximum and
one local minimum per revolution. These are called _single lobe_ elliptical gears.
Suppose that the gear on the left of \ref fig37 "Fig. 37" is rotated counterclockwise
through angle \f$\theta_0\f$. Then the gear on the right rotates counterclockwise through some angle
\f$\pi + \theta_1\f$
in order to keep the sum of the two radii along the line joining their centers \f$r_0+r_1\f$ constant.
</div>

\anchor fig37
\image html SingleLobe.gif "Fig. 37: Single-lobe elliptical gears." width=400

<div style="padding-left: 30px;" markdown="1">
Level 5 of the Gear Toy shows two elliptical gears with the left gear driven
by a motor as in \ref fig37 "Fig. 37" and the right gear static in its initial position.
Write code for function `CEllipticalGear1::Move` in
file <span style="background-color:#D8E4D8;">Elliptical.cpp</span>
to rotate the right gear meshed with the left gear as shown in \ref fig37 "Fig. 37". 
</div>


\anchor section7
# 7. What Next?

Next, take a look at the <a href="../cannon/index.html">Box2D Cannon Game</a>.


**/

