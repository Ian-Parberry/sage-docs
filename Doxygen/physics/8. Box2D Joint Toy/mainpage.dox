/**
\mainpage notitle

\anchor section1
# 1. Introduction

The Box2D Joint Toy demonstrates some important Box2D joints, including
revolute, gear, prismatic, wheel, distance, and pulley joints.
It is divided into 7 levels.
This code demo has no sound.
The remainder of this page is divided into five sections.
\ref section2 "Section 2" lists the controls
and their corresponding actions,
\ref section3 "Section 3" tells you how to build it,
\ref section4 "Section 4" gives you a list of actions to take in the game to see some of its
important features,
\ref section5 "Section 5" gives a breakdown of the code,
and
\ref section6 "Section 6" addresses the question "what next?".

\anchor section2
# 2. Keyboard Controls

<center>
<table>
<tr>
<td><center><b>Key</b></center></td>
<td><center><b>Action</b></center></td>
<tr>
<td><center>F1</center></td>
<td>Help (this document)</td>
<tr>
<td><center>F2</center></td>
<td>Toggle draw mode from "sprites only", to "sprites and lines", to "lines only"</td>
<tr>
<td><center>Backspace</center></td>
<td>Reset current level</td>
<tr>
<td><center>Enter</center></td>
<td>Advance to next level</td>
<tr>
<td><center>Space</center></td>
<td>Do an interesting thing (see \ref section4-1 "Section 4.1" to \ref section4-7 "Section 4.7")</td>
<tr>
<td><center>PrtScr (hold down)</center></td>
<td>Save screenshot to a PNG file</td>
<tr>
<td><center>Esc</center></td>
<td>Quit game and close the window</td>
</table>
</center>

\anchor section3
# 3. Building the Game

This code uses <a href="../sage/index.html">SAGE</a>
and <a href="https://github.com/erincatto/Box2D">Box2D</a>.
Make sure that you have followed the
<a href="../install/index.html">SAGE Installation Instructions</a>
and the <a href="../installphysics/index.html">Box2D Installation Instructions</a>.
Navigate to the folder <span style="background-color:#D8E4D8;">`8. Box2D Joint Toy`</span> in your
copy of the <span style="background-color:#D8E4D8;">`sage-physics`</span> repository.
Run <span style="background-color:#D8E4D8;">`checkenv.bat`</span>
to verify that you have set the environment
variables correctly.
Open <span style="background-color:#D8E4D8;">`Box2D Joint Toy.sln`</span>
 with Visual Studio and build the Release configuration.
Alternatively, run <span style="background-color:#D8E4D8;">`Build.bat`</span>
to build both Release and Debug configurations. 

\anchor section4
# 4. Game Play

This toy has 7 levels. As mentioned in \ref section2 "Section 2",
the `Enter` key advances to the next level and the `Backspace` key resets
the current level to the initial conditions.
The levels are as follows:
the windmill (\ref section4-1 "Section 4.1"),
round and square gears (\ref section4-2 "Section 4.2"),
nautilus gears (\ref section4-3 "Section 4.3"),
rack-and-pinion (\ref section4-4 "Section 4.4"),
car and bridge (\ref section4-5 "Section 4.5"),
Newton's cradle (\ref section4-6 "Section 4.6"), and
elephant drop (\ref section4-7 "Section 4.7").
In every level the `Space` bar does an interesting things. These are
described more detail in the subsections below.

\anchor section4-1
## 4.1 The Windmill

\anchor fig1
\image html l1.png "Fig. 1: The windmill." width=60%

A windmill with a revolute joint connecting the vanes to the body.
The revolute joint has a motor (see \ref fig1 "Fig. 1"). 
The `Space` bar reverses the motor's direction of rotation. 
Notice that the vanes take a while to spin up to full speed,
and when the direction of the motor is reversed they slowly spin down
to zero before spinning up in the opposite direction. This is a property
of motors in Box2D and will depend of the mass of the body being rotated.

\anchor section4-2
## 4.2 Gears

\anchor fig2
\image html l2.png "Fig. 2: The gears." width=60%

A system of 9 interlocked gears constructed using revolute and
gear joints (see \ref fig2 "Fig. 2").
The largest
gear has a motor and the others are driven by their
gear joints. The `Space` bar reverses the motor's direction of
rotation. Notice that the gears take a while to spin up to full speed,
and when the direction of the motor is reversed they slowly spin down
to zero before spinning up in the opposite direction.
Notice also how the teeth of the gears appear to mesh.
However, if you look closely you will see that they do not
mesh exactly. This is because we are not computing the physics of the teeth,
we are simply rotating the gears at the right speeds assuming that the
sprites are drawn with teeth that mesh correctly.
The 4 square gears
mesh perfectly the same way that round gears do.
They are cheating in a way - they require no extra code over and
above what is necessary for ordinary round gears.

\anchor section4-3
## 4.3 Nautilus Gears

\anchor fig3
\image html l3.png "Fig. 3: The nautilus gears." width=60%

A system of 5 <em>nautilus gears</em>, which are gears
in the shape of a nautilus shell (see \ref fig3 "Fig. 3").
The center gear has a revolute joint with a motor. 
The other gears have variable speed, so they cannot be animated by Box2D.
We have to animate them ourselves which means doing a little math,
which we will cover in \ref section5-3 "Section 5.3".  The `Space` bar reverses the motor's direction of rotation. Notice that the gears take a while to spin up to full speed,
and when the direction of the motor is reversed they slowly spin down
to zero before spinning up in the opposite direction.

\anchor section4-4
## 4.4 Rack-and-Pinion

\anchor fig4
\image html l4.png "Fig. 4: The rack-and-pinion." width=60%

A <em>rack-and-pinion</em> consists of a round gear called a <em>pinion</em>
connected to a toothed rod called a <em>rack</em> (see \ref fig4 "Fig. 4").
When the pinion rotates, the rack moves horizontally. 
The pinion has a
revolute joint with a motor. 
The rack is connected to the pinion using a gear joint and a prismatic joint.
The `Space` bar reverses the motor's direction of rotation.
Notice that the pinion takes a while to spin up to full speed,
and when the direction of the motor is reversed it slowly spins down
to zero before spinning up in the opposite direction.
Also notice the sudden stop when the pinion reaches its extreme
left and right positions.

\anchor section4-5
## 4.5 Car and Bridge

\anchor fig5
\image html l5.png "Fig. 5: The car." width=60%

A car drives autonomously back and forth over a pair of ramps
(see \ref fig5 "Fig. 5"). 
The car is constructed using a pair of wheel joints that
have motors. The `Space` bar reverses the motors' directions of rotation.
Notice that the car takes a while to get to full speed,
and when the direction of the motors is reversed it slows down
to zero before speeding up in the opposite direction.
Also notice the suspension that makes the car bounce when
it goes over the ramps.
If you are fast with the `Space` bar you may be able to get
the car stuck. If you do, reset it with the `Backspace` key.

\anchor section4-6
## 4.6 Newton's Cradle

\anchor fig6
\image html l6.png "Fig. 6: Newton's cradle." width=60%

Distance joints are used to construct a 2D
<a href="../newton/index.html">Newton's Cradle</a>
with 6 balls (see \ref fig6 "Fig. 6").
When the balls are stopped, hitting the `Space` bar will lift and release
from 1 to 5 balls in sequence.
After that it should behave like a real Newton's Cradle.
\ref fig7 "Fig. 7" shows a screen shot with one ball raised (left),
and the result after the collision (right).
\ref fig8 "Fig. 8" shows a screen shot with two balls raised (left),
and the result after the collision (right).
When the balls are in motion, the `Space` bar stops them.

\anchor fig7
\image html newton1.png "Fig. 7: Newton's cradle with 1 ball raised (left) and after collision (right)." width=80%

\anchor fig8
\image html newton2.png "Fig. 8: Newton's cradle with 2 balls raised (left) and after collision (right)." width=80%

\anchor section4-7
## 4.7 Elephant Drop

\anchor fig9
\image html l7.png "Fig. 9: The elephant drop before (left) and after (right) the elephant is dropped." width=80%

A pulley joint is used to lift a safe when an elephant is dropped
into a wooden cradle (see \ref fig9 "Fig. 9"). The pulley wheels and ropes are animated in code.
When the elephant is not present, the `Space` bar makes it drop in from above.
When the elephant is present, the `Space` bar makes it disappear.
You can make the elephant appear and disappear at any point in the cradle's
travel, not just when it is at the top or bottom.
Notice that in \ref fig9 "Fig. 9" (right) the cradle is not immediately
below the left rim of the pulley wheel above so that the rope from
the pulley to the cradle is not vertical, whereas that portion of the
rope is perfectly vertical in \ref fig9 "Fig. 9" (left).
This is because the elephant
is not dropped exactly above the center of the cradle, causing it to
rock from side to side as it falls.

\anchor section5
# 5. Code Breakdown

Each of the levels has its own class, each of which is derived from
`CLevel`. `CLevel` contains code and data that will be used by
most of the levels. Some of its functions are stubs.
A pointer to a class representing the current level
is maintained in `CCommon::m_pLevel`, which is of type `CLevel*`.
Many of `CLevel`'s member functions are `virtual` so that they
can be overridden in any particular level class if desired.
Most importantly, `CLevel` has an `std::vector` of pointers to
`CObject` for you to store your objects, and
function `CLevel::Draw` to draw the objects in in
(although of course this may be overridden in derived classes)
and a function stub `CLevel::Action` to perform the "interesting action"
in response to the space bar
(see \ref section2 "Section 2").

The most interesting portions of the code for
each of the level classes is described in the following subsections:
the windmill (\ref section5-1 "Section 5.1"),
round and square gears (\ref section5-2 "Section 5.2"),
nautilus gears (\ref section5-3 "Section 5.3"),
rack-and-pinion (\ref section5-4 "Section 5.4"),
car and bridge (\ref section5-5 "Section 5.5"), and
Newton's cradle (\ref section5-6 "Section 5.6"),
and
elephant drop (\ref section5-7 "Section 5.7").

\anchor section5-1
## 5.1 The Windmill

The windmill level is implemented in class `CWindmill`, which is
derived from `CLevel`.
The `CWindmill` constructor calls `CWindmill::CreateFan` to create
an instance of `CObject` for the fan, which is drawn using the
sprite shown in \ref fig10 "Figure 10" (right);
and calls `CWindmill::CreateBase`
to create an instance of `CObject` for the base, which is drawn using the
sprite shown in \ref fig10 "Figure 10" (left).


\anchor fig10
\image html windmillspr.png "Fig. 10: The windmill sprites for the base (left), and the fan (right)." width=30%

`CObject` has a pointer to a Box2D body `CObject::m_pBody`
of type `b2Body*`.
`CWindmill::CreateFan` declares a body definition `bd`
and sets its `type` and `position` fields.
It then declares an instance of `b2CircleShape` called `s` and sets its
radius to half the width of the sprite in \ref fig10 "Figure 10" (right),
translated from Render World to Physics World coordinates.
It then declares a fixture definition `fd` and sets its shape to `s`
and its density somewhat arbitrarily to `0.1f`.
It then creates a Physics World body for the fan by calling

    m_pPhysicsWorld->CreateBody(&bd)

and saving the pointer to the Box2D body returned in a local
variable `pBody`.
The instance of `CObject` for the fan is then created by calling

    new CObject(eSprite::WindmillFan, pBody)

and pushing the pointer returned at the back of the inherited object list
`CLevel::m_stdObject`. 
Finally, the fixture for the shape is attached to the body by
calling

    pBody->CreateFixture(&fd);

although this could be called before the instance of `CObject` was created.

\anchor fig11
\image html windmill.png "Fig. 11: The windmill level drawn with Box2D bodies in black on top of sprites (left), and bodies only (right)." width=80%

`CWindmill::CreateBase`, on the other hand, creates an instance of `CObject`
with a pointer to a Box2D body that does not have a fixture attached to it.
This results in the sprite for the windmill base being drawn as
in \ref fig11 "Fig. 11" (left), but it does not participate in
Box2D collision detection and response and is not drawn when
only Box2D bodies are drawn as in \ref fig11 "Fig. 11" (right).
As far as Box2D is concerned, then, the world consists of two bodies,
one of which is a circle and the other of which is essentially the empty body.

Returning to the `CWindmill` constructor,
after calling `CWindmill::CreateFan` and `CWindmill::CreateBase`
and saving the `b2Body` pointers in local variables
`pFan` and `pBase`, respectively, it declares a
_revolute joint_ definition `wd`. The word _revolute_ is a synonym
for _rotation_. A revolute joint, then, allows two bodies to rotate
about a single point. If both bodies are dynamic, then the two 
bodies rotate freely, but in our case the body for the windmill base
is given type `b2_staticBody` in  `CWindmill::CreateBase`, which
results in the windmill fan rotating about its center in the expected way.
Various fields of the revolute joint definition `wd` are filled in,
including pointers to the two bodies from `pFan` and `pBase`,
a motor speed and the maximum torque to be applied.
Recall from \ref section4-1 "Section 4.1" that the fan slowly
spins up to speed. The rate at which it does so depends
upon the fan's mass (which depends on its shape and density)
and the motor's torque. Setting the torque ususally requires
a certain amount of try-it-and-see before you arrive at an
appropriate value.

The revolute joint is created from the description in `wd`
by calling

    m_pPhysicsWorld->CreateJoint(&wd)

Unfortunately `b2World::CreateJoint` returns a pointer to a `b2Joint`,
which is a base class from which all Box2D joints are derived.
It's up to us to cast this pointer to the correct
type as follows:

    m_pJoint = (b2RevoluteJoint*)m_pPhysicsWorld->CreateJoint(&wd);

We save this pointer in `CWindmill::m_pJoint` because we
will need to use it in  `CWindmill::Action` to change the
motor speed in response to the space bar in  `CGame::KeyboardHandler`.
This is easily done as follows using `b2RevoluteJoint`'s 
`GetMotorSpeed` and `SetMotorSpeed` functions.

    void CWindmill::Action(){
      m_pJoint->SetMotorSpeed(-m_pJoint->GetMotorSpeed());
    } //Action

A little care must be taken when leaving a level to
ensure that there are no memory leaks.
`CLevel` has a virtual destructor `CLevel::~CLevel` that `delete`s
all of the objects in the object list `CLevel::m_stdObject`.
In turn the `CObject` destructor `CObject::~CObject` calls

    m_pPhysicsWorld->DestroyBody(m_pBody)

to destroy the Box2D body associated with the object. This assumes
that the Box2D Physics World pointed to by `m_pPhysicsWorld`
still exists. This implies that the `CGame` destructor
`CGame::~CGame` must `delete` the current level before it
`delete`s Physics World. This is handled as follows.

    CGame::~CGame(){
      delete m_pRenderer;
      delete m_pLevel;
      delete m_pPhysicsWorld;
    } //destructor


\anchor section5-2
## 5.2 Gears

The Gear level is implemented in class `CGear`, which is
derived from `CLevel`.
It may come as a surprise that if you use `F2` to draw the
Physics World bodies, then you will see a collection
of small non-overlapping circles as shown in \ref fig12 "Fig. 12",
whereas in sprite mode you see gears of different size
as shown in \ref fig2 "Fig. 2" happily rotating at the right speeds.

\anchor fig12
\image html gears.png "Fig. 12: The gear level drawn with Box2D bodies." width=40%

This brings us to what I call the First Law of Computer Graphics:

> If it looks right, it is right.

and also what might be called the First Corollary of Computer Animation:

> The things that you see on the screen don't actually interact - they are just drawn that way.

In this case it might _look_ as if the gears mesh in such a way that the teeth
of one gear pushed against the teeth of the next gear, but that really isn't
so. All we need to do is make sure that the center of each gear
is in the correct place, and that gears that should "contact" rotate at
the correct relative speeds (and of course that the sprites have the correct number and shape of teeth for their size).

\anchor fig13
\image html gear0.png "Fig. 13: The five round gears." width=55%

Consider the five round gears in \ref fig2 "Fig. 2".
As seen in \ref fig13 "Fig. 13", we can number them
0 through 4. Note that gears 2 and 3 have the same diameter, but gears 0, 1, and
differ from them and each other. 

\anchor fig14
\image html gear1.png "Fig. 14: The five round gears drawn so that they appear to mesh." width=30%

These are drawn as shown in \ref fig14 "Fig. 14" positioned and oriented
so that their teeth
appear to mesh together.
As we animated the gears we just need to make sure that they stay that way.
The largest, gear 0, will have a motor, and the others will rotate
at the required speeds and directions.
The relative speeds of rotation are proportional to the radii of the
gears involved, which can be found by counting the teeth, as in \ref fig15 "Fig. 15".

\anchor fig15
\image html gear2.png "Fig. 15: A gear with 12 teeth." width=12%

The relative directions of rotation flip from one gear to the next.
For example, the largest gear in \ref fig16 "Fig. 16" is driven
clockwise by a motor in a clockwise direction as indicated by the
black arrows, while the other gears rotate in the directions indicated by the gray dotted arrows.

\anchor fig16
\image html gear3.png "Fig. 16: Directions of rotation." width=45%

The code for the creation of the gears and their revolute joints is
very similar to the code for the rotating fan in the
Windmill level (see \ref section5-3 "Section 5.3"). 
Pointers to the revolute joints are stored in an `std::vector` of
`b2RevoluteJoint` pointers `CGear::m_stdJoint` by the `CGear` constructor `CGear::CGear`.
`CGear::CreateGearJoint` creates a gear joint
that joins the revolute joints pointed to by `m_stdJoint[i]` and `m_stdJoint[j]`,
with gear ratio `r`, where the unsigned integers `i`, `j`, and the floating point value `r` are parameters.
It does this by declaring a gear joint definition `gd` and filling
in fields for the ratio, pointers to two revolute joints, and pointers to the corresponding two Box2D bodies.
The gear joint is then created by calling

    m_pPhysicsWorld->CreateJoint(&gd);

There is no need to save the joint pointer returned since it does not have any properties that we want to change, and it will be
destroyed when the two revolute joints are destroyed.

Then, for example, the `CGear` constructor `CGear::CGear` makes the four
following function calls for the gear joints joining gears
0 to 1, 2 to 2, 1 to 3, and 3 to 4.
The third parameter in each case the ratio of the number of
teeth in the second gear to the number of teeth in the first gear,
noting that gear 0 has 33 teeth, gear 1 and 4 have 18 teeth, and gears 2 and 3 have 12 teeth.

    CreateGearJoint(0, 1, 18.0f/33.0f); 
    CreateGearJoint(1, 2, 12.0f/18.0f);
    CreateGearJoint(1, 3, 12.0f/18.0f);
    CreateGearJoint(3, 4, 18.0f/12.0f);


\anchor section5-3
## 5.3 Nautilus Gears


The Nautilus Gear level is implemented in class `CNautilusGear`, which is
derived from `CLevel`.

\anchor fig5-3-1
\image html Nautilus2-342-96.gif "Fig. 5.3.1: The nautilus gears." width=25%
 

\anchor section5-4
## 5.4 Rack-and-Pinion


The Rack-and-Pinion level is implemented in class `CRackAndPinion`, which is
derived from `CLevel`. 

\anchor fig5-4-1
\image html rackandpinion.gif "Fig. 5.4.1: The rack-and-pinion." width=50%

\anchor section5-5
## 5.5 Car and Bridge

The Car and Bridge level is implemented in class `CCarAndBridge`, which is
derived from `CLevel`.

\anchor section5-6
## 5.6 Newton's Cradle

The Newton's Cradle level is implemented in class `CNewtonsCradle`, which is
derived from `CLevel`. 

\anchor section5-7
## 5.7 Elephant Drop

The Elephant Drop level is implemented in class `CPulley`, which is
derived from `CLevel`. 

\anchor section6
# 6. What Next?

Next, take a look at the <a href="../cannon/index.html">Box2D Cannon Game</a>.


**/

