<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The Top Down Game Prototype: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="sagedoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">The Top Down Game Prototype
   </div>
   <div id="projectbrief">A Basic Top Down Shooter</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="doc-content">
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="contents">
<div class="textblock"><p><a class="anchor" id="sec1"></a></p><h1>1. Introduction</h1>
<p>This is a simple top-down game with graphics, particle effects, and sound. The player character is a person in a brown cap with a rifle shown at bottom left in <a class="el" href="#fig1">Fig. 1</a>. There is a non-player character in a green cap standing guard in a bunker at the top right of <a class="el" href="#fig1">Fig. 1</a>. The guard will shoot at you if you are too close or if you draw attention to yourself by firing your gun. You control your character with either the the keyboard and mouse, or with an XBox controller (see <a class="el" href="#sec2">Section 2</a>). The controller takes precedence over the keyboard and mouse when it is plugged in.</p>
<p>The background is a simple image and the world size is its width and height, which are larger than the window. The camera follows the player but it stops at the edges of the world so that you never see anything that is outside the world. Bullets persist until they run into something, either the player, the guard, or the edges of the world, at which time a particle engine is used to mark the point of impact (a blood spatter or a small cloud of dust). The guard rotates but does not move from the bunker.</p>
<p><a class="anchor" id="fig1"></a></p><div class="image">
<img src="screenshot.png" alt="" width="50%"/>
<div class="caption">
Fig. 1: A screenshot of the Top Down Game.</div></div>
<p>The remainder of this page is divided into five sections. <a class="el" href="#sec2">Section 2</a> lists the controls and their corresponding actions, <a class="el" href="#sec3">Section 3</a> tells you how to build it, <a class="el" href="#sec4">Section 4</a> gives you a list of actions to take in the game to see some of its important features, <a class="el" href="#sec5">Section 5</a> gives a breakdown of the code, and <a class="el" href="#sec6">Section 6</a> addresses the question "what next?".</p>
<p><a class="anchor" id="sec2"></a></p><h1>2. Controls</h1>
<center> <table class="doxtable">
<tr>
<td><center><b>Keyboard</b></center> </td><td><center><b>Controller</b></center> </td><td><center><b>Mouse</b></center> </td><td><center><b>Action</b></center> </td></tr>
<tr>
<td><center>F1</center> </td><td><center>-</center> </td><td><center>-</center> </td><td>Help (this document) </td></tr>
<tr>
<td><center>F2</center> </td><td><center>-</center> </td><td><center>-</center> </td><td>Toggle frame rate display </td></tr>
<tr>
<td><center>F3</center> </td><td><center>-</center> </td><td><center>-</center> </td><td>Toggle show bounding circles </td></tr>
<tr>
<td><center>F4</center> </td><td><center>-</center> </td><td><center>-</center> </td><td>Toggle show NPC state </td></tr>
<tr>
<td><center>-</center> </td><td>Right thumb </td><td>Move left* </td><td>Rotate counterclockwise </td></tr>
<tr>
<td><center>-</center> </td><td>Right thumb </td><td>Move right* </td><td>Rotate clockwise </td></tr>
<tr>
<td><center>Space</center> </td><td>Right button </td><td>Left button </td><td>Shoot </td></tr>
<tr>
<td><center>A</center> </td><td>Digital pad left </td><td><center>-</center> </td><td>Strafe left </td></tr>
<tr>
<td><center>D</center> </td><td>Digital pad right </td><td><center>-</center> </td><td>Strafe right </td></tr>
<tr>
<td><center>G</center> </td><td><center>-</center> </td><td><center>-</center> </td><td>Toggle God mode </td></tr>
<tr>
<td><center>S</center> </td><td>Digital pad down </td><td><center>-</center> </td><td>Retreat </td></tr>
<tr>
<td><center>W</center> </td><td>Right trigger </td><td><center>-</center> </td><td>Move forwards </td></tr>
<tr>
<td><center>Backspace</center> </td><td><center>-</center> </td><td><center>-</center> </td><td>Restart game </td></tr>
<tr>
<td><center>PrtScr</center> </td><td><center>-</center> </td><td><center>-</center> </td><td>Save screenshot to a PNG file </td></tr>
<tr>
<td><center>Esc</center> </td><td><center>-</center> </td><td><center>-</center> </td><td>Quit game and close the window </td></tr>
</table>
</center><p><code>*</code> Note that the mouse cursor must be inside the game window for player rotation to occur.</p>
<p><a class="anchor" id="sec3"></a></p><h1>3. Building the Game</h1>
<p>This code uses <a href="../sage/index.html">SAGE</a>. Make sure that you have followed the <a href="../install/index.html">SAGE Installation Instructions</a>. Navigate to the folder <span style="background-color:#D8E4D8;"><code>1. Top Down Game</code></span> in your copy of the <span style="background-color:#D8E4D8;"><code>sage-games</code></span> repository. Run <span style="background-color:#D8E4D8;"><code>checkenv.bat</code></span> to verify that you have set the environment variables correctly. Open <span style="background-color:#D8E4D8;"><code>Top Down Game.sln</code></span> with Visual Studio and build the Release configuration. The Release executable file <span style="background-color:#D8E4D8;"><code>Top Down Game.exe</code></span> will appear. Alternatively, run <span style="background-color:#D8E4D8;"><code>Build.bat</code></span> to build both Release and Debug configurations.</p>
<p><a class="anchor" id="sec4"></a></p><h1>4. Game Play</h1>
<p>Run <span style="background-color:#D8E4D8;"><code>Top Down Game.exe</code></span> and do the following:</p>
<ol>
<li>
<p class="startli">Move the mouse cursor into the window. Notice that the player character in the bottom left corner of the window rotates to face the mouse pointer.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">With the mouse pointer over the guard, click the left mouse button to fire your gun a dozen or more times. Notice the muzzle flash from your gun and the blood spatter from the guard. At your first shot, the guard will become aware of you and rotate to start shooting at you. After the guard dies you will see its death animation, after which the game will restart.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Repeat the previous step with bounding circles and NPC state turned on (toggle these with <code>F3</code> and <code>F4</code>, respectively). Notice that blood spatters are centered on the point of impact between a bullet and a bounding circle. Observe the guard's state changes during this process.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Restart the game by hitting the <code>Backspace</code> key. Turn on God mode using the <code>G</code> key so that the player does not die. Move the player character toward the guard by placing the mouse cursor over the guard and keeping the <code>W</code> key down. Notice the following:</p>
<ol type="a">
<li>
The camera moves when you get far enough from the edge of the window. </li>
<li>
When you get close to the guard it will become aware of you and rotate to start shooting at you. </li>
<li>
Observe what happens when your bounding circle hits the guard's bounding circle. While this will never happen in a real game (without God mode) because the player will die before getting there, it's best to have code that handles it for safety. Examine the code to find out why this happens. </li>
</ol>
<p class="endli"></p>
</li>
<li>
Use the mouse and the <code>W</code> key to move the player to all four edges of the world. Observe what happens, and examine the code to find out why it happens. Fire the gun at the edge of the world to see the collision response particle effect. </li>
</ol>
<p><a class="anchor" id="sec5"></a></p><h1>5. Code Breakdown</h1>
<p>Open <span style="background-color:#D8E4D8;"><code>Top Down Game.sln</code></span> in Visual Studio and examine the code in the editor while you read the rest of this section. This section assumes that you have read and understood the documentation from <a href="../sage/index.html">SAGE</a> and <a href="../blank/index.html">The Blank Game</a>.</p>
<p><a class="anchor" id="sec5-1"></a></p><h2>5.1 Particle Engines</h2>
<p><code><a class="el" href="class_c_common.html" title="The common variables class.">CCommon</a></code> contains a pointer <code>m_pParticleEngine</code> to a <a href="../sage/index.html#sec3-8">2D particle engine</a> to be used for static particle effects, that is, particle effects that do not move with a particular object.</p>
<p><a class="anchor" id="sec5-2"></a></p><h2>5.2 Game Objects</h2>
<p>There are five kinds of game objects. The <a class="el" href="#sec5-2-1">base game object</a> adds properties and functionality to <a href="../sage/class_sage_1_1_c_object.html"><code>Sage::CObject</code></a> that are required by all objects in this game. Note that <code><a class="el" href="class_c_object.html" title="The game object.">CObject</a></code> is provided as a template parameter to <code><a class="el" href="class_c_object_manager.html" title="The object manager.">CObjectManager</a></code> and thus to <a href="../sage/class_sage_1_1_c_object_manager.html"><code>Sage::CObjectManager</code></a>, which means that its object list will be an array of pointers to <code><a class="el" href="class_c_object.html" title="The game object.">CObject</a></code>. Therefore, when object member functions are called from the object manager virtual functions will be used to elevate the call to the correct derived class.</p>
<p>The <a class="el" href="#sec5-2-2">armed object</a> <code><a class="el" href="class_c_armed_object.html" title="The armed object.">CArmedObject</a></code> adds to <code><a class="el" href="class_c_object.html" title="The game object.">CObject</a></code> the properties and functionality of carrying and firing a gun, which applies to both the player and the guard. The <a class="el" href="#sec5-2-3">player object</a> <code><a class="el" href="class_c_player.html" title="The player object.">CPlayer</a></code> adds code to <code><a class="el" href="class_c_armed_object.html" title="The armed object.">CArmedObject</a></code> for processing game inputs from the keyboard, mouse, and controller. The <a class="el" href="#sec5-2-4">guard object</a> <code><a class="el" href="class_c_guard.html" title="The guard object.">CGuard</a></code> adds some AI code to <code><a class="el" href="class_c_armed_object.html" title="The armed object.">CArmedObject</a></code>. The <a class="el" href="#sec5-2-5">bullet object</a> <code><a class="el" href="class_c_bullet.html" title="The bullet object.">CBullet</a></code> adds some code to <code><a class="el" href="class_c_object.html" title="The game object.">CObject</a></code> for bullets.</p>
<p><a class="anchor" id="sec5-2-1"></a></p><h3>5.2.1 Base Game Object</h3>
<p>The base game object <code><a class="el" href="class_c_object.html" title="The game object.">CObject</a></code> is declared in <code><a class="el" href="_object_8h.html" title="Interface for the game object class CObject.">Object.h</a></code> and defined in <code><a class="el" href="_object_8cpp.html" title="Code for the game object class CObject.">Object.cpp</a></code>. It is derived from <a href="../sage/class_sage_1_1_c_object.html"><code>Sage::CObject</code></a>. <code><a class="el" href="_game_defines_8h.html" title="Game specific defines and enumerated types.">GameDefines.h</a></code> contains the declaration of an object enumerated type <code>eObject</code> and a sprite enumerated type <code>eSprite</code>. <code><a class="el" href="class_c_object.html" title="The game object.">CObject</a></code> has a protected member variable <code>m_eObject</code> of type <code>eObject</code> to identify the object type and a protected member variable <code>m_eSprite</code> of type <code>eSprite</code> to identify the sprite type. It also has protected member variables for object position, orientation, and collision circle radius, <code>m_vPos</code>, <code>m_fRoll</code>, and <code>m_fRadius</code>, respectively.</p>
<p>Public member functions include a simple <code>Draw</code> function that draws the object's sprite with its center at <code>m_vPos</code> and at orientation <code>m_fRoll</code>. There is also a stub <code>Move</code> function that contains no code. Both of these are expected to be overridden by functions in classes derived from <code><a class="el" href="class_c_object.html" title="The game object.">CObject</a></code>.</p>
<p><code><a class="el" href="class_c_object.html" title="The game object.">CObject</a></code> also has a public member function <code><a class="el" href="class_c_object.html#a2cfe2c14ca84c5a06b60f29a57b64e3d" title="Collision response.">CObject::CollisionResponse</a></code> that is to be called whenever its collision circle overlaps that of another object. It has three parameters: a vector normal to the collision, the overlap distance, and a pointer to the object collided with. Although the latter is not used in the body of the function, which simply moves the object by the overlap distance in the direction of the collision normal, it will be used in functions overriding <code><a class="el" href="class_c_object.html#a2cfe2c14ca84c5a06b60f29a57b64e3d" title="Collision response.">CObject::CollisionResponse</a></code> in classes derived from <code><a class="el" href="class_c_object.html" title="The game object.">CObject</a></code>. Note that functions overriding <code><a class="el" href="class_c_object.html#a2cfe2c14ca84c5a06b60f29a57b64e3d" title="Collision response.">CObject::CollisionResponse</a></code> will call <code><a class="el" href="class_c_object.html#a2cfe2c14ca84c5a06b60f29a57b64e3d" title="Collision response.">CObject::CollisionResponse</a></code> as a default. <code><a class="el" href="class_c_object.html#a2cfe2c14ca84c5a06b60f29a57b64e3d" title="Collision response.">CObject::CollisionResponse</a></code> is called in <code><a class="el" href="class_c_object_manager.html#ae2487201156a62dc632609bc42a7d80b" title="Broad phase collision detection and response.">CObjectManager::BroadPhase</a></code> for collisions with the edge of the world, and <code><a class="el" href="class_c_object_manager.html#acee7c392319024d71772e2d290a1cc7d" title="Narrow phase collision detection and response.">CObjectManager::NarrowPhase</a></code> for collisions with other objects.</p>
<p><a class="anchor" id="sec5-2-2"></a></p><h3>5.2.2 Armed Object</h3>
<p>The armed object <code><a class="el" href="class_c_armed_object.html" title="The armed object.">CArmedObject</a></code> is declared in <code><a class="el" href="_armed_object_8h.html" title="Interface for the armed game object class CArmedObject.">ArmedObject.h</a></code> and defined in <code><a class="el" href="_armed_object_8cpp.html" title="Code for the game object class CArmedObject.">ArmedObject.cpp</a></code>. It is derived from <code><a class="el" href="class_c_object.html" title="The game object.">CObject</a></code> (see <a class="el" href="#sec5-2-1">Section 5.2.1</a>). Recall that the <a href="../sage/class_sage_1_1_c_sprite_renderer.html#ac3515ab913c5849c73bbf52532b3ca30"><code>Sage::CSpriteRenderer::Draw()</code></a> function draws sprites with their center at the position specified by a parameter and optionally rotates the sprite about its center by another parameter. We saw this in action when drawing the text ring at the center of the window in the and <a href="../blank/index.html">The Blank Game</a>. In this game the armed objects are the player and the guard, seen in <a class="el" href="#fig2">Fig. 2</a>. Notice that the sprites initially face along the positive X-axis.</p>
<p><a class="anchor" id="fig2"></a></p><div class="image">
<img src="PCandNPC.png" alt="" width="35%"/>
<div class="caption">
Fig. 2: The guard (left) and player (right) sprites.</div></div>
<p>These sprites will be drawn by <code><a class="el" href="class_c_armed_object.html#aad111986969a998621a865da7e0e562d" title="Draw object.">CArmedObject::Draw()</a></code> with the center of sprite's cap at the object's position and they should rotate about that point. In order to do this we need the vector offset from the center of the object to the center of the sprite, called the <em>center offset</em> (see <a class="el" href="#fig3">Fig. 3</a>). This will be stored in protected member variable <code><a class="el" href="class_c_armed_object.html#a83b57ecaefa829ef5442fcfbaee8830d" title="Sprite center offset.">CArmedObject::m_vCenterOffset</a></code>. We will also animate a muzzle flash particle effect at the end of the gun barrel. To do this we need the vector offset from the center of the sprite to the end of the gun barrel, called the <em>gun offset</em> (see also <a class="el" href="#fig3">Fig. 3</a>). This will be stored in protected member variable <code><a class="el" href="class_c_armed_object.html#a86b429611b2cbdf0ec856ddee7fd79f4" title="Sprite gun offset.">CArmedObject::m_vGunOffset</a></code>.</p>
<p><a class="anchor" id="fig3"></a></p><div class="image">
<img src="offsets.png" alt="" width="35%"/>
<div class="caption">
Fig. 3: The player sprite and offsets.</div></div>
<p><code><a class="el" href="class_c_armed_object.html" title="The armed object.">CArmedObject</a></code> contains a private pointer <code>m_pLocalParticleEngine</code> to a <a href="../sage/index.html#sec3-8">2D particle engine</a> for particle effects that move with that object. In particular we need to draw the muzzle flash (which is animated over several frames) at the end of the gun barrel, which may have moved and/or rotated from its position when the gun fired. In order to do this we will need to call <a href="../sage/class_sage_1_1_c_particle_engine.html#a5e4add4fdc2f94979d70ea3b1f10053b">Sage::CSpriteEngine2D::TranslateTo()</a> to the translated and rotated muzzle position along with <a href="../sage/class_sage_1_1_c_particle_engine.html#aebc9640270acf9d83595238d533c073f">Sage::CSpriteEngine2D::Step()</a> once per frame in <code><a class="el" href="class_c_armed_object.html#a3f6fe2f4bcdfefc75a7724343aadf5c2" title="Move object.">CArmedObject::Move()</a></code>.</p>
<p><a class="anchor" id="rotatetowards"></a> Another <code><a class="el" href="class_c_armed_object.html" title="The armed object.">CArmedObject</a></code> member function of interest is <code><a class="el" href="class_c_armed_object.html#ae851dd350dbe22f775100a4f7815d959" title="Swivel towards position.">CArmedObject::RotateTowards()</a></code>, which takes as parameter a 2D vector called the <em>target</em> and rotates the sprite so that the gun barrel is closer to pointing at the target, returning <code>true</code> if it is pointing "close enough" to it. See the full description of <code><a class="el" href="class_c_armed_object.html#ae851dd350dbe22f775100a4f7815d959" title="Swivel towards position.">CArmedObject::RotateTowards()</a></code> for more details on how this is done. <code><a class="el" href="class_c_armed_object.html#ae851dd350dbe22f775100a4f7815d959" title="Swivel towards position.">CArmedObject::RotateTowards()</a></code> will be used to smoothly rotate the player to face the mouse pointer (see <a class="el" href="#sec5-2-3">Section 5.2.3</a>) and for the guard to smoothly rotate to face the player under control of its AI (see <a class="el" href="#sec5-2-4">Section 5.2.4</a>).</p>
<p>Function <code><a class="el" href="class_c_armed_object.html#a2fb8a2d0fa6c8ddd0fd89a2cf505b0c2" title="Death special effects.">CArmedObject::DeathFX()</a></code> creates some particle effects to be played after the object dies. Note that this function uses the global particle engine <code>*m_pParticleEngine</code> inherited from <code><a class="el" href="class_c_common.html" title="The common variables class.">CCommon</a></code>, not the local particle engine <code>*m_pLocalParticleEngine</code> because the particle effects must persist after the object has been deleted. Firstly we create a particle that looks just like the armed object itself which fades out over a second's elapsed time and a skeleton sprite of type <code>eSprite::Skeleton</code> that fades in and out and moves to the upper left. <code><a class="el" href="class_c_armed_object.html#a2fb8a2d0fa6c8ddd0fd89a2cf505b0c2" title="Death special effects.">CArmedObject::DeathFX()</a></code> will be called from the collision response functions of <code><a class="el" href="class_c_player.html" title="The player object.">CPlayer</a></code> and <code><a class="el" href="class_c_guard.html" title="The guard object.">CGuard</a></code>, which will be derived from <code><a class="el" href="class_c_armed_object.html" title="The armed object.">CArmedObject</a></code> and are covered below.</p>
<p><a class="anchor" id="sec5-2-3"></a></p><h3>5.2.3 Player Object</h3>
<p>The player object <code><a class="el" href="class_c_player.html" title="The player object.">CPlayer</a></code> is declared in <code><a class="el" href="_player_8h.html" title="Interface for the player object class CPlayer.">Player.h</a></code> and defined in <code><a class="el" href="_player_8cpp.html" title="Code for the player object class CPlayer.">Player.cpp</a></code>. It is derived from <code><a class="el" href="class_c_armed_object.html" title="The armed object.">CArmedObject</a></code> (see <a class="el" href="#sec5-2-2">Section 5.2.2</a>).</p>
<h4>5.2.3.1 Vulnerability</h4>
<p>The player object is said to be <em>vulnerable</em> to attack from the guard object whenever the player fires their gun, and for a short period afterwards. <code><a class="el" href="class_c_player.html" title="The player object.">CPlayer</a></code> has a private member variable <code>m_bVulnerable</code> that will be set to <code>true</code> whenever the player is vulnerable. It has a public reader function <code><a class="el" href="class_c_player.html#a0768c2e56e93086b162adcdceb88b7df" title="Get the vulnerable flag.">CPlayer::IsVulnerable</a></code> and a public writer function `<code><a class="el" href="class_c_player.html#a0768c2e56e93086b162adcdceb88b7df" title="Get the vulnerable flag.">CPlayer::IsVulnerable</a></code>. The former will be used by the guard to determine whether the player is vulnerable, and the latter will be used by <code><a class="el" href="class_c_object_manager.html" title="The object manager.">CObjectManager</a></code> to make the player vulnerable when the player fires their gun, that is, when a bullet object is created. The player will remain vulnerable until the event timer <code>*m_pEndVulnerableEvent</code> (an instance of <a href="../sage/index.html#sec3-2"><code>Sage::CEventTimer</code></a>) triggers.</p>
<h4>5.2.3.2 Responding to Player Inputs</h4>
<p>Device inputs come to the player object via a public member function <code><a class="el" href="class_c_player.html#a8b8147d61d72e129e8c4528c6a37ee7f" title="Set movement direction.">CPlayer::SetMovement</a></code>, which has a parameter of type <code>eDirection</code>, an enumerated type defines in <code><a class="el" href="_game_defines_8h.html" title="Game specific defines and enumerated types.">GameDefines.h</a></code>. This is saved in private member variable <code>m_eDirection</code> and used in the call to <code><a class="el" href="class_c_player.html#a8cdce2b8fd7f5765c19d1d45f9899866" title="Move player object.">CPlayer::Move</a></code>, which overrides <code><a class="el" href="class_c_object.html#ae33d05b96b8b11fe621e42525a908041" title="Move object.">CObject::Move</a></code>. <code><a class="el" href="class_c_player.html" title="The player object.">CPlayer</a></code> also has a private member variable <code>m_vDesiredLookAtPt</code> which will be set to the current mouse position in <code><a class="el" href="class_c_game.html#a6978045dfc517814ff1a5674507cc56f" title="The mouse handler.">CGame::MouseHandler</a></code> by calling <code><a class="el" href="class_c_player.html#afdb4ed7083a7f4b4f19349e5d6d690b6" title="Rotate towards point.">CPlayer::LookAt</a></code>. <code><a class="el" href="class_c_player.html#a8cdce2b8fd7f5765c19d1d45f9899866" title="Move player object.">CPlayer::Move</a></code> will call <code><a class="el" href="class_c_armed_object.html#ae851dd350dbe22f775100a4f7815d959" title="Swivel towards position.">CArmedObject::RotateTowards</a></code> (see also <a class="el" href="#rotatetowards">Section 5.2.2</a>) to rotate a small amount in the direction of <code>m_vDesiredLookAtPt</code>. Finally, <code><a class="el" href="class_c_player.html#a8cdce2b8fd7f5765c19d1d45f9899866" title="Move player object.">CPlayer::Move</a></code> ends player vulnerability is the end vulnerable event is triggered, calls <code><a class="el" href="class_c_armed_object.html#a3f6fe2f4bcdfefc75a7724343aadf5c2" title="Move object.">CArmedObject::Move</a></code> and sets the sound player's <a href="../sage/class_sage_1_1_c_sound.html#a01cad4589a84b31f34a1d0c7f98be76e"><code>Sage::CSound::SetListenerPos</code></a> function to make sounds relative to the player's position in 2D space.</p>
<p><a class="anchor" id="sec5-2-4"></a></p><h3>5.2.4 Guard Object</h3>
<p>The guard object <code><a class="el" href="class_c_guard.html" title="The guard object.">CGuard</a></code> is declared in <code><a class="el" href="_guard_8h.html" title="Interface for the guard object class CGuard.">Guard.h</a></code> and defined in <code><a class="el" href="_guard_8cpp.html" title="Code for the guard object class CGuard.">Guard.cpp</a></code>. It is derived from <code><a class="el" href="class_c_armed_object.html" title="The armed object.">CArmedObject</a></code> (see <a class="el" href="#sec5-2-2">Section 5.2.2</a>). <code><a class="el" href="class_c_guard.html" title="The guard object.">CGuard</a></code> is different from <code><a class="el" href="class_c_player.html" title="The player object.">CPlayer</a></code> in that it has code for autonomous actions instead of code for responding to player inputs. It also rotates to face the player using much the same code as the player rotating to face the mouse cursor. The guard's actions are governed by a simple finite state machine whose states and transitions may also include a certain amount of randomness provided by the pseudo-random number generator pointed to by <code>m_pRandom</code> (inherited from <a href="../sage/class_sage_1_1_c_component.html"><code>Sage::CComponent</code></a>) an instance of <a href="../sage/class_sage_1_1_c_random.html"><code>Sage::CRandom</code></a>.</p>
<h4>5.2.4.1 The State Machine</h4>
<p><code><a class="el" href="class_c_guard.html" title="The guard object.">CGuard</a></code> includes the private definition of an enumerated type <code><a class="el" href="class_c_guard.html#aefa1c17763272aeb804575c9a762235f" title="State of mind.">CGuard::eState</a></code>, consisting of the following states.</p>
<ol type="1">
<li><code>CGuard::eState::Alert</code> - aware of player and firing at it.</li>
<li><code>CGuard::eState::Waiting</code> - not rotating, just staring off into the distance.</li>
<li><code>CGuard::eState::Scanning</code> - turning slowly either clockwise or counterclockwise.</li>
<li><code>CGuard::eState::Reloading</code> - reloading the gun and displaying the <a class="el" href="#reload-animation">Reload Animation</a>.</li>
</ol>
<p><code><a class="el" href="class_c_guard.html" title="The guard object.">CGuard</a></code> has a protected member variable <code>m_eState</code> of type <code><a class="el" href="class_c_guard.html#aefa1c17763272aeb804575c9a762235f" title="State of mind.">CGuard::eState</a></code> that stores the guard's current state. As described in <a class="el" href="#sec2">Section 2</a>, hitting <code>F4</code> on the keyboard will toggle the drawing of white text describing the guard's current state. For example <a class="el" href="#fig4">Fig. 4</a> shows the guard in state <code>CGuard::eState::Scanning</code>. This text is drawn by calling the protected member function <code><a class="el" href="class_c_guard.html#ac221cdeb835736a295b79384065a89ec" title="Draw state text.">CGuard::DrawState</a></code> from <code><a class="el" href="class_c_guard.html#a41e5204843c2ee44f37f2f55dbbe84e9" title="Draw.">CGuard::Draw</a></code>. <code><a class="el" href="class_c_guard.html#ac221cdeb835736a295b79384065a89ec" title="Draw state text.">CGuard::DrawState</a></code> calls <code><a class="el" href="class_c_guard.html#a2d1351bd30c8ebed2a8b437f1a53563d" title="Get state text.">CGuard::GetStateString</a></code> to convert <code>m_eState</code> to a (wide) string that is then drawn to the screen by calling <a href="../sage/class_sage_1_1_c_renderer3_d.html#a5868fca5687d4f44843af7a5119f0382"><code>Sage::CRenderer3D::DrawScreenText</code></a>, which is inherited by <a href="../sage/class_sage_1_1_c_sprite_renderer.html"><code>Sage::CSpriteRenderer</code></a>.</p>
<p><a class="anchor" id="fig4"></a></p><div class="image">
<img src="scanning.png" alt="" width="20%"/>
<div class="caption">
Fig. 4: The guard showing scanning state.</div></div>
<p><code><a class="el" href="class_c_guard.html#a3b22279349c76fa4e1966c5d776da07a" title="Change state.">CGuard::ChangeState</a></code> is called whenever the guard's state is to be changed. It sets <code>m_eState</code> to the new state and sets various other variables in a <code>switch</code> statement that depends on the new state. Instances of <a href="../sage/index.html#sec3-2"><code>Sage::CEventTimer</code></a> pointed to by <code>m_pWaitEvent</code>, <code>m_pAlertEvent</code>, and <code>m_pScanningEvent</code> are used to move out of <code>CGuard::eState::Waiting</code>, <code>CGuard::eState::Alert</code>, and <code>CGuard::eState::Scanning</code>, respectively, after the appropriate amount of time has passed. The guard moves out of state <code>CGuard::eState::Reloading</code> once all frames of the <a class="el" href="#reload-animation">reloading animation</a> have been displayed.</p>
<p><a class="anchor" id="fig5"></a></p><div class="image">
<img src="guardstates.png" alt="" width="40%"/>
<div class="caption">
Fig. 5: The guard state machine.</div></div>
<p>The guard state machine is shown in <a class="el" href="#fig5">Fig. 5</a>. The circles represent the four states. The arrow into the top state indicates that it is the initial state. The other arrows represent transitions between states and have labels indication the conditions required for a change of state along that transition. The blue arrows indicate Boolean conditions in the code. The green arrows indicate events that need to be triggered. The purple arrow are a combination of Boolean conditions and events. Recall that events trigger after a certain period of time.</p>
<p><a class="anchor" id="reload-animation"></a></p><h4>5.2.4.2 Reload Animation</h4>
<p>Every time the guard files a bullet, it displays a reload animation as shown in <a class="el" href="#fig6">Fig. 6</a>. The animation frames are loaded from a <em>sprite sheet</em> as shown in <a class="el" href="#fig7">Fig. 7</a>.</p>
<p><a class="anchor" id="fig6"></a></p><div class="image">
<img src="reload.gif" alt=""/>
<div class="caption">
Fig. 6: The guard reload animation.</div></div>
<p><a class="anchor" id="fig7"></a></p><div class="image">
<img src="sheet1.png" alt="" width="45%"/>
<div class="caption">
Fig. 7: The guard sprite sheet.</div></div>
<p>All that has to be done to enable sprite animation is to modify <code>GameSettings.xml</code> to describe where the individual frames are on the sprite sheet, add code to <code><a class="el" href="class_c_game.html#a7c1fa6038d453a578371caa9f01e2388" title="Load sprites.">CGame::LoadSprites</a></code> to load them in, and add code to <code><a class="el" href="class_c_guard.html#a41e5204843c2ee44f37f2f55dbbe84e9" title="Draw.">CGuard::Draw</a></code> function to change frames over time.</p>
<p>In addition to the single-frame-in-a-file <code>&lt;sprite&gt;</code> tags we used in <code>GameSettings.xml</code> in <a href="../blank/index.html">The Blank Game</a>, we can load multiple frames from a sprite sheet as follows. Firstly we create a <code>&lt;sprite&gt;</code> <code>&lt;/sprite&gt;</code> pair describing the sprite sheet, enclosing a list of <code>&lt;frame&gt;</code> tags describing the frames. The <code>&lt;sprite&gt;</code> tag has a <code>name</code> field for the name to be used in the code, a <code>sheet</code> field for the sprite sheet files name, and a <code>frames</code> field for the number of frames. The <code>&lt;frame&gt;</code> tag has a field <code>index</code> for the frame index and four fields describing the bounding rectangle in the sprite sheet, specifically its <code>left</code>, <code>right</code>, <code>top</code>, and <code>bottom</code> position measured in pixels. Note that the Y-coordinate is measured from the <em>top</em> of the image.</p>
<div class="fragment"><div class="line">&lt;<span class="keywordtype">sprite</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;guardreload&quot;</span> <span class="keyword">sheet</span>=<span class="stringliteral">&quot;sheet1&quot;</span> <span class="keyword">frames</span>=<span class="stringliteral">&quot;20&quot;</span>&gt;  </div>
<div class="line">  &lt;<span class="keywordtype">frame</span> <span class="keyword">index</span>=<span class="stringliteral">&quot;0&quot;</span>  <span class="keyword">left</span>=<span class="stringliteral">&quot;0&quot;</span>   <span class="keyword">top</span>=<span class="stringliteral">&quot;0&quot;</span>  <span class="keyword">right</span>=<span class="stringliteral">&quot;128&quot;</span> <span class="keyword">bottom</span>=<span class="stringliteral">&quot;78&quot;</span>/&gt;</div>
<div class="line">  &lt;<span class="keywordtype">frame</span> <span class="keyword">index</span>=<span class="stringliteral">&quot;1&quot;</span>  <span class="keyword">left</span>=<span class="stringliteral">&quot;128&quot;</span> <span class="keyword">top</span>=<span class="stringliteral">&quot;0&quot;</span>  <span class="keyword">right</span>=<span class="stringliteral">&quot;256&quot;</span> <span class="keyword">bottom</span>=<span class="stringliteral">&quot;78&quot;</span>/&gt;</div>
<div class="line">  ...</div>
<div class="line">  &lt;<span class="keywordtype">frame</span> <span class="keyword">index</span>=<span class="stringliteral">&quot;19&quot;</span> <span class="keyword">left</span>=<span class="stringliteral">&quot;384&quot;</span> <span class="keyword">top</span>=<span class="stringliteral">&quot;312&quot;</span> <span class="keyword">right</span>=<span class="stringliteral">&quot;512&quot;</span> <span class="keyword">bottom</span>=<span class="stringliteral">&quot;390&quot;</span>/&gt;</div>
<div class="line">&lt;/<span class="keywordtype">sprite</span>&gt;</div>
</div><!-- fragment --><p>We can then load the sprite from this description with the line</p>
<div class="fragment"><div class="line">media.Insert(eSprite::GuardReload, <span class="stringliteral">&quot;guardreload&quot;</span>);</div>
</div><!-- fragment --><p>in <code><a class="el" href="class_c_game.html#a7c1fa6038d453a578371caa9f01e2388" title="Load sprites.">CGame::LoadSprites</a></code> using the <code>name</code> field from the <code>&lt;sprite&gt;</code> tag as the second parameter. The frame number is a static local variable <code>nCurFrame</code> in <code><a class="el" href="class_c_guard.html#a41e5204843c2ee44f37f2f55dbbe84e9" title="Draw.">CGuard::Draw</a></code> which is incremented after a period of time governed by the <a href="../sage/index.html#sec3-2"><code>Sage::CEventTimer</code></a> pointed to by <code>m_pFrameEvent</code>. This is then put into the <code>m_nCurrentFrame</code> variable in a 2D sprite descriptor (see <a href="../sage/class_sage_1_1_c_sprite_desc2_d.html"><code>Sage::CSpriteDesc2D</code></a>), the remainder of which is filled in before being passed to the version of <a href="../sage/class_sage_1_1_c_sprite_renderer.html#ac3515ab913c5849c73bbf52532b3ca30"><code>Sage::CSpriteRenderer::Draw</code></a> that takes a pointer to a 2D sprite descriptor <a href="../sage/class_sage_1_1_c_sprite_desc2_d.html"><code>Sage::CSpriteDesc2D</code></a> as a parameter.</p>
<h4>5.2.4.3 Moving</h4>
<p><code><a class="el" href="class_c_guard.html#a2d1a319a8c34c47a065ca82390f2b279" title="Move.">CGuard::Move</a></code> takes action based on the guard's current state, and calls <code><a class="el" href="class_c_guard.html#a3b22279349c76fa4e1966c5d776da07a" title="Change state.">CGuard::ChangeState</a></code> to change state based on the player's position and vulnerability, and various <a href="../sage/index.html#sec3-2">event timers</a>. It finishes with a call to <code><a class="el" href="class_c_armed_object.html#a3f6fe2f4bcdfefc75a7724343aadf5c2" title="Move object.">CArmedObject::Move</a></code>.</p>
<h4>5.2.4.4 Collision Response</h4>
<p><code><a class="el" href="class_c_guard.html" title="The guard object.">CGuard</a></code> has a collision response function <code><a class="el" href="class_c_guard.html#a7100575b2f8b1a4ece0bf3b24d44bfca" title="Collision response.">CGuard::CollisionResponse</a></code> that overrides <code><a class="el" href="class_c_object.html#a2cfe2c14ca84c5a06b60f29a57b64e3d" title="Collision response.">CArmedObject::CollisionResponse</a></code>. It takes care of collisions with a bullet, including blood spatter particle effect, reduction in health, and death if appropriate.</p>
<p><a class="anchor" id="sec5-2-5"></a></p><h3>5.2.5 Bullet Object</h3>
<p>The bullet object <code><a class="el" href="class_c_bullet.html" title="The bullet object.">CBullet</a></code> is declared in <code><a class="el" href="_bullet_8h.html" title="Interface for the bullet object class CBullet.">Bullet.h</a></code> and defined in <code><a class="el" href="_bullet_8cpp.html" title="Code for the bullet object class CBullet.">Bullet.cpp</a></code>. It is derived from <code><a class="el" href="class_c_object.html" title="The game object.">CObject</a></code> (see <a class="el" href="#sec5-2-1">Section 5.2.1</a>). <code><a class="el" href="class_c_bullet.html" title="The bullet object.">CBullet</a></code> has a private member function <code>m_vVelocity</code>, which is used in <code><a class="el" href="class_c_bullet.html#a94460251d0cf3b2b4f6b8ab482a7b081" title="Move bullet.">CBullet::Move</a></code> to change the bullet's position by an amout proportional to the velocity multiplied by frame time. Bullets die when colliding with the edges of the world or another object in <code><a class="el" href="class_c_bullet.html#a13e3d4589c8e5f7b6099f71341236f8b" title="Collision response.">CBullet::CollisionResponse</a></code>, with the appropriate sound and particle effects (a puff of dust when colliding with the edge of the world, and a blood spatter when colliding with the player or the guard).</p>
<p><a class="anchor" id="sec5-3"></a></p><h2>5.3 The Object Manager</h2>
<p>The object manager <code><a class="el" href="class_c_object_manager.html" title="The object manager.">CObjectManager</a></code> is declared in <code><a class="el" href="_object_manager_8h.html" title="Interface for the object manager classCObjectManager.">ObjectManager.h</a></code> and defined in <code><a class="el" href="_object_manager_8cpp.html" title="Code for the the object manager class CObjectManager.">ObjectManager.cpp</a></code>. It is derived from <a href="../sage/class_sage_1_1_c_object_manager.html"><code>Sage::CObjectManager&lt;CObject&gt;</code></a>. <code><a class="el" href="class_c_object_manager.html#acee7c392319024d71772e2d290a1cc7d" title="Narrow phase collision detection and response.">CObjectManager::NarrowPhase</a></code> performs collision detection and response for two objects. It gets called once per pair of objects in <a href="../sage/class_sage_1_1_c_object_manager.html#a51d74fc1fb4e6379f119760b56b13185"><code>Sage::CObjectManager&lt;CObject&gt;::BroadPhase</code></a>. If the bounding circles of the two objects overlap, then it calls both object's <code>CollisionResponse</code> functions, which by the power of virtual functions will be either <code><a class="el" href="class_c_object.html#a2cfe2c14ca84c5a06b60f29a57b64e3d" title="Collision response.">CObject::CollisionResponse</a></code>, <code><a class="el" href="class_c_player.html#a257ff19b21196bf7a42bbaa36e7126a8" title="Collision response.">CPlayer::CollisionResponse</a></code>, <code><a class="el" href="class_c_guard.html#a7100575b2f8b1a4ece0bf3b24d44bfca" title="Collision response.">CGuard::CollisionResponse</a></code>, or <code><a class="el" href="class_c_bullet.html#a13e3d4589c8e5f7b6099f71341236f8b" title="Collision response.">CBullet::CollisionResponse</a></code>, depending on the object type. Bounding circles have a radius of <code><a class="el" href="class_c_object.html#afb97f8e0ea95db14d0f8dabb006ded9d" title="Bounding circle radius.">CObject::m_fRadius</a></code> and are centered at <code><a class="el" href="class_c_object.html#a0219c1e480987fa4f0f126a315bc2398" title="Position.">CObject::m_vPos</a></code>, that is, the object's center of rotation. As described in <a class="el" href="#sec2">Section 2</a>, hitting <code>F3</code> on the keyboard will toggle the drawing of the guard's and the player's collision circles as shown in <a class="el" href="#fig8">Fig. 8</a>. Note that since the bounding circle of the player and the guard are more-or-less tightly inscribed around their respective torsos, only bullet hits to the torso will count.</p>
<p><a class="anchor" id="fig8"></a></p><div class="image">
<img src="boundingcircle.png" alt="" width="20%"/>
<div class="caption">
Fig. 8: The guard showing its collision circle.</div></div>
<p><code><a class="el" href="class_c_object_manager.html#ae2487201156a62dc632609bc42a7d80b" title="Broad phase collision detection and response.">CObjectManager::BroadPhase</a></code> calls <a href="../sage/class_sage_1_1_c_object_manager.html#a51d74fc1fb4e6379f119760b56b13185"><code>Sage::CObjectManager&lt;CObject&gt;::BroadPhase</code></a> to do object-object collision detection and response, then does collision detection and response for objects and the edges of the world, using <code><a class="el" href="class_c_object_manager.html#a8fd3f8660bf6e9c30a681453d776c111" title="Test whether at the edge of the world.">CObjectManager::AtWorldEdge</a></code> to detect the edges of the world from the width and height of the background sprite.</p>
<p><code><a class="el" href="class_c_object_manager.html" title="The object manager.">CObjectManager</a></code> also has a handy function <code><a class="el" href="class_c_object_manager.html#a7f49b5b7c0da33dc53401a26aa865f39" title="Create new object.">CObjectManager::Create</a></code> to instantiate objects and insert them into the object list. In <a href="../blank/index.html">The Blank Game</a> this was handled in <a href="../blank/class_c_game.html#af7200bd66587e10002e7ed9e4a1f930e">CGame::BeginGame</a> but it makes sense to do it in the object manager now.</p>
<p><code><a class="el" href="class_c_object_manager.html#a90bf0be7ca1092d570e9d5660ad06261" title="Fire armed object&#39;s gun.">CObjectManager::FireGun</a></code> fires a gun from an instance of <code><a class="el" href="class_c_armed_object.html" title="The armed object.">CArmedObject</a></code> by creating a bullet object of the appropriate type and a muzzle flash particle effect at the exit of the gun barrel using <code><a class="el" href="class_c_armed_object.html#aad443c44e76a89026a2e8b02271d1242" title="Compute view vector.">CArmedObject::GetViewVector</a></code> to find the direction that the gun is pointing and <code><a class="el" href="class_c_armed_object.html#a0093f706ad2801801dd414ba797ad16e" title="Get gun offset.">CArmedObject::GetGunOffset</a></code> (see <a class="el" href="#fig3">Fig. 3</a>) to get the (rotated) offset from the sprite center to the end of the gun barrel. To make things a little harder a small random deflection is added to each bullet so that consecutive bullets follow slightly different paths. Pseudo-randomness is provided an the instance of <a href="../sage/class_sage_1_1_c_random.html"><code>Sage::CRandom</code></a>, a pointer to which is inherited from <a href="../sage/class_sage_1_1_c_component.html"><code>Sage::CComponent</code></a>.</p>
<p><a class="anchor" id="sec5-4"></a></p><h2>5.4 Changes to <a class="el" href="class_c_game.html" title="The game class.">CGame</a></h2>
<p>The most significant changes to <a class="el" href="class_c_game.html" title="The game class.">CGame</a> are for <a class="el" href="#sec5-4-1">processing inputs</a> from the mouse and controller, a <a class="el" href="#sec5-4-2">follow camera</a> that moves the window with the player, and a new <a class="el" href="#sec5-4-3">game state</a> that allows the game to restart after a few seconds delay to allow death animations to complete when the game is over.</p>
<p><a class="anchor" id="sec5-4-1"></a></p><h3>5.4.1 Processing Inputs</h3>
<p>In addition to the keyboard handler <code><a class="el" href="class_c_game.html#a74a75ef02b07f0f785de8aa6e7631b5d" title="The keyboard handler.">CGame::KeyboardHandler</a></code> modified from <a href="../blank/index.html">The Blank Game</a>, <code><a class="el" href="class_c_game.html" title="The game class.">CGame</a></code> now has a mouse handler <code><a class="el" href="class_c_game.html#a6978045dfc517814ff1a5674507cc56f" title="The mouse handler.">CGame::MouseHandler</a></code> and an XBox controller handler <code><a class="el" href="class_c_game.html#a1ef415ad921f0a1b97149ec59ecbe7ea" title="The controller handler.">CGame::ControllerHandler</a></code> (refer back to <a class="el" href="#sec2">Section 2</a> for the mouse and controller input mappings). The former uses a pointer to a mouse handler <code>m_pMouse</code> and the latter uses a pointer to a controller handler <code>m_pController</code>, both of which are inherited from <a href="../sage/class_sage_1_1_c_component.html"><code>Sage::CComponent</code></a>.</p>
<p><a class="anchor" id="sec5-4-2"></a></p><h3>5.4.2 Follow Camera</h3>
<p>In <a href="../blank/index.html">The Blank Game</a> you probably weren't even aware of the camera, which is positioned above the center of the background along the Z axis (see <a class="el" href="#fig9">Fig. 9</a>). Everything in the <em>view frustum</em>, the pyramid drawn with its apex at the camera position in <a class="el" href="#fig9">Fig. 9</a>, is projected onto the window, so that everything appears to be in 2D, not 3D.</p>
<p><a class="anchor" id="fig9"></a></p><div class="image">
<img src="camera0.png" alt="" width="80%"/>
<div class="caption">
Fig. 9: The default camera in the Blank Game.</div></div>
<p>Now function <code><a class="el" href="class_c_game.html#a7f54d0f4d35f427ddfd5a4442c6d885d" title="Make camera follow player character.">CGame::FollowCamera</a></code> positions the camera above the player (see <a class="el" href="#fig10">Fig. 10),</a>except when the player object is close to the top, bottom, left, or right of the world, in which case the camera stops with the edge of the background image at the corresponding edge of the window (see <a class="el" href="#fig11">Fig. 11). </a> <a class="anchor" id="fig10"></a></p><div class="image">
<img src="camera1.png" alt="" width="80%"/>
<div class="caption">
Fig. 10: The follow camera keeps the player at the center of the window whenever possible.</div></div>
<p><a class="anchor" id="fig11"></a></p><div class="image">
<img src="camera2.png" alt="" width="80%"/>
<div class="caption">
Fig. 11: The follow camera when the player is near an edge of the world.</div></div>
<p>The new position of the camera is computed in local variable <code>vCameraPos</code> and passed to the renderer using <a href="../sage/class_sage_1_1_c_sprite_renderer.html#acfb173389d223b51774f5c0500a88aad"><code>Sage::CSpriteRenderer::SetCameraPos</code></a>. <code><a class="el" href="class_c_game.html#a7f54d0f4d35f427ddfd5a4442c6d885d" title="Make camera follow player character.">CGame::FollowCamera</a></code> is called once per frame in <code><a class="el" href="class_c_game.html#aec83638cb2fdd94ef098132eb59617d8" title="Process an animation frame.">CGame::ProcessFrame</a></code>.</p>
<p><a class="anchor" id="sec5-4-3"></a></p><h3>5.4.3 Game State</h3>
<p><code>CGame::ProcessState</code> is slightly more complicated than it was in <a href="../blank/index.html">The Blank Game</a>. The enumerated type <code>eGameState</code> in <code><a class="el" href="_game_defines_8h.html" title="Game specific defines and enumerated types.">GameDefines.h</a></code> now has a third member <code>eGameState::Waiting</code>. The game will be in this state for a few seconds after the game has been completed by the death and death animation of either the player of the guard, after which the game will be restarted and again enter state <code>eGameState::Playing</code>.</p>
<p><a class="anchor" id="fig12"></a></p><div class="image">
<img src="gamestates.png" alt="" width="30%"/>
<div class="caption">
Fig. 12: The game state machine.</div></div>
<p>The game state machine is shown in <a class="el" href="#fig9">Fig. 12</a>. The circles represent the three states. The arrow into the top state indicates that it is the initial state. The other arrows represent transitions between states and have labels indication the conditions required for a change of state along that transition. The blue arrows indicate Boolean conditions in the code. The green arrows indicate events that need to be triggered.</p>
<p><a class="anchor" id="sec6"></a></p><h1>6. What Next?</h1>
<p>Next, take a look at the <a href="../topdowntiled">Top Down Tiled Game</a>. </p>
</div></div><!-- PageDoc -->
<a href="doxygen_crawl.html"></a>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
