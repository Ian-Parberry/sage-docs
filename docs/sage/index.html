<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SAGE: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="doxylogo.png"/></td>
  <td id="projectalign">
   <div id="projectname">SAGE
   </div>
   <div id="projectbrief">A Simple Academic Game Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="contents">
<div class="textblock"><p><a class="anchor" id="sec1"></a></p><h1>1. Introduction</h1>
<p>SAGE, the Simple Academic Game Engine, is a simple game engine for instructional applications. It is called <em>simple</em> because it consists of approximately 10,500 lines of open-source C++ code (exclusive of blank lines and block comments), whereas commercial game engines typically have millions of lines of code. It uses Microsoft DirectX 12 for graphics, DirectXTK 12 for graphics helpers and audio support, and TinyXML2 for reading XML files. It has been used by students in <a href="https://ianparberry.com/">Ian Parberry</a>'s game programming classes to code 2D, 2.5D, and 3D games using Visual C++ under 64-bit Windows 11. It must be emphasized that SAGE is an <em>instructional</em> game engine. It is <b>not</b> intended for use outside the classroom and it is definitely <b>not</b> intended for commercial use. SAGE is currently a private, members-only repository. If you are an instructor and you wish to test it out for use in your game programming class, please email <a href="https://ianparberry.com/">Ian Parberry</a>.</p>
<p>The remainder of this page is divided into four sections. <a class="el" href="index.html#sec2">Section 2</a> explains the design patterns used in SAGE, <a class="el" href="index.html#sec3">Section 3</a> goes over some of the more important SAGE classes, <a class="el" href="index.html#sec4">Section 4</a> covers some of the conventions used in SAGE code, and <a class="el" href="index.html#sec5">Section 5</a> addresses the question "what next?"</p>
<p><a class="anchor" id="sec2"></a></p><h1>2. Design Patterns</h1>
<p>A <em>design pattern</em> is a general reusable solution to a commonly occurring problem within a given context in software design. It is not a finished design that can be transformed directly into source or machine code. Design patterns began with the so-called gang of four consisting of Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides. In 1994 they published a book called <em>Design Patterns: Elements of Reusable Object-Oriented Software</em>. SAGE uses what are called <em>implementation strategy design patterns</em>, which relate to source code organization. There are two types of implementation strategy design pattern: <em>algorithm</em> and <em>data</em>. SAGE uses three algorithm design patterns and four data design patterns.</p>
<p><a class="anchor" id="sec2-1"></a></p><h2>2.1 Algorithm Design Patterns</h2>
<p>The three algorithm design patterns used by SAGE are <em>entity</em>, <em>manager</em>, and <em>component</em>.</p>
<ol type="1">
<li>An <em>entity</em> is a simple class that is concerned only with its own state and actions. Entities typically rely on components to perform tasks for them. Access to entities is typically through a manager.</li>
<li>A <em>manager</em> contains a collection of entities. Managers are responsible for entity creation and destruction, and delegation of tasks to all entities for which the manager has responsibility. A manager typically stores its entities in a private container such as <code>std::vector</code> or <code>std::list</code>. The manager's entities typically list the manager as a friend so that the manager has direct access to the entity's data without the need for cumbersome access functions.</li>
<li>A <em>component</em> is a class that provides services typically provided by the operating system such as graphics and sound.</li>
</ol>
<p><a class="anchor" id="sec2-2"></a></p><h2>2.2 Data Design Patterns</h2>
<p>The four data design patterns used by SAGE are <em>descriptor</em>, <em>monostate</em>, <em>accessor</em>, and <em>aggregator</em>.</p>
<ol type="1">
<li>A <em>descriptor</em> encapsulates information in the form of public member variables. They are typically used to replace a long parameter list with a single parameter.</li>
<li>A <em>monostate</em> is a class that encapsulates a single instance of data to be shared between classes using class variables (static member variables). A monostate may be instantiated in the code, but it more generally has classes derived from it. Monostates are used to provide data to multiple entities, managers, components, without the need for global variables, long parameter lists, or local copies of the data. The Monostate Design Pattern is also called the <em>Borg Idiom</em> in the Python community.</li>
<li>An <em>accessor</em> is a monostate consisting only of protected member variables.</li>
<li>An <em>aggregator</em> is an accessor consisting of static protected pointers to components.</li>
</ol>
<p><a class="anchor" id="sec3"></a></p><h1>3. SAGE Classes</h1>
<p>The following classes are provided by SAGE in <code>namespace Sage</code>. Do not instantiate them in your game unless instructed otherwise. Some have already been instantiated for you. Others have been designed to be derived from. Do not modify SAGE code in order to make your game run. Instead, you should derive your own class from the relevant SAGE class and add your functionality in overloaded member functions.</p>
<p><a class="anchor" id="sec3-1"></a></p><h2>3.1 Input Devices</h2>
<p><a class="anchor" id="table-1"></a></p><center> <table class="doxtable">
<caption>Table 1. SAGE input device classes.</caption>
<tr>
<td><center><b>SAGE Class</b></center> </td><td><center><b>Design Pattern</b></center> </td><td><center><b>Description</b></center> </td><td><center><b>Usage</b></center> </td></tr>
<tr>
<td><code><a class="el" href="class_sage_1_1_c_controller.html" title="The controller class.">Sage::CController</a></code> </td><td>Component </td><td>XBox controller handler </td><td>Instantiated by SAGE </td></tr>
<tr>
<td><code><a class="el" href="class_sage_1_1_c_keyboard.html" title="The keyboard handler.">Sage::CKeyboard</a></code> </td><td>Component </td><td>Keyboard handler </td><td>Instantiated by SAGE </td></tr>
<tr>
<td><code><a class="el" href="class_sage_1_1_c_mouse.html" title="The mouse handler.">Sage::CMouse</a></code> </td><td>Component </td><td>Mouse position handler </td><td>Instantiated by SAGE </td></tr>
</table>
</center><p>SAGE provides device handlers for an X-Box controller, the keyboard, and the mouse (see <a class="el" href="index.html#table-1">Table 1</a>). For efficiency, these handlers are polled, and are not dependent on the Windows message passing system. All three components have a <code>GetState</code> function that should be called once per frame to capture the current state of the device. This state snapshot can then be examined by calling device-specific reader functions. One thing that you may not be expecting is that <code><a class="el" href="class_sage_1_1_c_mouse.html" title="The mouse handler.">Sage::CMouse</a></code> handles only the position of the mouse. Mouse buttons are handled by <code><a class="el" href="class_sage_1_1_c_keyboard.html" title="The keyboard handler.">Sage::CKeyboard</a></code>. This is a foible of the way Windows handles its devices.</p>
<h3>Important Member Functions</h3>
<p>Important <code><a class="el" href="class_sage_1_1_c_keyboard.html" title="The keyboard handler.">Sage::CKeyboard</a></code> public member functions include the following. See <code><a class="el" href="class_sage_1_1_c_keyboard.html" title="The keyboard handler.">Sage::CKeyboard</a></code> to see how other keyboard tests.</p>
<ul>
<li><code><a class="el" href="class_sage_1_1_c_keyboard.html#ad8c9a823c7eebe930c7bd59e244f8748" title="Poll the keyboard state.">Sage::CKeyboard::GetState</a></code>, which must be called once per animation frame to poll the current keyboard state;</li>
<li><code><a class="el" href="class_sage_1_1_c_keyboard.html#afa172e4d3f693fdc01b723df869e13cf" title="Check for key going down.">Sage::CKeyboard::TriggerDown</a></code>, which returns <code>true</code> if a key described by a <code>WPARAM</code> was up and went down in the current animation frame.</li>
<li><code><a class="el" href="class_sage_1_1_c_keyboard.html#a453b7b81fe507f7270d82b2190c3f984" title="Check for key down.">Sage::CKeyboard::Down</a></code>, which returns <code>true</code> if a key described by a <code>WPARAM</code> is currently down.</li>
</ul>
<p>Important <code><a class="el" href="class_sage_1_1_c_mouse.html" title="The mouse handler.">Sage::CMouse</a></code> public member functions include the following. See <code><a class="el" href="class_sage_1_1_c_mouse.html" title="The mouse handler.">Sage::CMouse</a></code> to see how to get other mouse data.</p>
<ul>
<li><code><a class="el" href="class_sage_1_1_c_mouse.html#aae373e7bd08642e7e117034a7ef1b7c9" title="Poll the mouse state.">Sage::CMouse::GetState</a></code>, which must be called once per animation frame to poll the current mouse state;</li>
<li><code><a class="el" href="class_sage_1_1_c_mouse.html#ab6a03fc5f6e1f0abe2c3003afb762634" title="Get amount of motion.">Sage::CMouse::GetMove</a></code>, which returns a vector describing the mouse motion since the last frame.</li>
</ul>
<p>Important <code><a class="el" href="class_sage_1_1_c_controller.html" title="The controller class.">Sage::CController</a></code> public member functions include the following. See <code><a class="el" href="class_sage_1_1_c_controller.html" title="The controller class.">Sage::CController</a></code> to see how to test other controller buttons and controls.</p>
<ul>
<li><code><a class="el" href="class_sage_1_1_c_controller.html#aa92398d82aa123c29b4a5d5a6929438f" title="Get controller&#39;s current state.">Sage::CController::GetState</a></code>, which must be called once per animation frame to poll the current controller state;</li>
<li><code><a class="el" href="class_sage_1_1_c_controller.html#af2f9db3f321d9eea8dcf0a86e9a99bb0" title="Query whether controller is connected.">Sage::CController::IsConnected</a></code>, which returns <code>true</code> if a controller is connected;</li>
<li><code><a class="el" href="class_sage_1_1_c_controller.html#a0fefb86519688febe750cb69ad474042" title="Set left and right rumble.">Sage::CController::Vibrate</a></code>, which sets the left and right rumble; and</li>
<li><code><a class="el" href="class_sage_1_1_c_controller.html#a5309ae583d84aa3f3a3a191be03dfbe7" title="Get button A toggle state.">Sage::CController::GetButtonAToggle</a></code>, which returns <code>true</code> if button A on the controller was up and went down in the current animation frame.</li>
</ul>
<p><a class="anchor" id="sec3-2"></a></p><h2>3.2 Time</h2>
<p><a class="anchor" id="table-2"></a></p><center> <table class="doxtable">
<caption>Table 2. SAGE timer classes.</caption>
<tr>
<td><center><b>SAGE Class</b></center> </td><td><center><b>Design Pattern</b></center> </td><td><center><b>Description</b></center> </td><td><center><b>Usage</b></center> </td></tr>
<tr>
<td><code><a class="el" href="class_sage_1_1_c_event_timer.html" title="The event timer.">Sage::CEventTimer</a></code> </td><td>Component </td><td>Timer for regularly scheduled events </td><td>Instantiated in your game </td></tr>
<tr>
<td><code><a class="el" href="class_sage_1_1_c_timer.html" title="The timer class.">Sage::CTimer</a></code> </td><td>Component </td><td>High-accuracy timer </td><td>Instantiated by SAGE </td></tr>
</table>
</center><p>Your game must be able to measure your computers frame rate and frame interval, which is the amount of time between frames. This will typically vary between 30 frames per second (around 33 milliseconds per frame) and over 300 frame per second (around 3 milliseconds per frame). SAGE provides two timer classes (see <a class="el" href="index.html#table-2">Table 2</a>). <code><a class="el" href="class_sage_1_1_c_timer.html" title="The timer class.">Sage::CTimer</a></code> is a high-accuracy frame timer. It has a function <code><a class="el" href="class_sage_1_1_c_timer.html#ab24d65d62c636f7b2a09d30380cc4ef0" title="One tick per frame.">Sage::CTimer::Tick</a></code> that must be called once per frame to capture a snapshot of the time. Then, for example, the current frame time in seconds can be obtained as a floating point value by calling <code><a class="el" href="class_sage_1_1_c_timer.html#a253daf5d5f2fb68c7584f9edf20dead1" title="Get time in seconds since last Tick.">Sage::CTimer::GetFrameTime</a></code>.</p>
<p><code><a class="el" href="class_sage_1_1_c_event_timer.html" title="The event timer.">Sage::CEventTimer</a></code> lets you handle regularly scheduled events such as flashing lights or the reloading of a weapon. The events can be scheduled with an optional amount of variability. To use it, instantiate one instance of <code><a class="el" href="class_sage_1_1_c_event_timer.html" title="The event timer.">Sage::CEventTimer</a></code> for each event, providing the delay and optional amount of variability as parameters to the constructor. Thereafter, call the event timer's function <code><a class="el" href="class_sage_1_1_c_event_timer.html#a2fbd2f1faae4af217eec280a60b6d4e8" title="Check if triggered.">Sage::CEventTimer::Triggered</a></code> once per frame. This function will return <code>true</code> and reset the event if the delay time plus the variability time are greater than the elapsed time since the event was last triggered (or the time it was created, if it has never been triggered). Otherwise it will return <code>false</code>.</p>
<p><a class="anchor" id="sec3-3"></a></p><h2>3.3 Sound</h2>
<p><a class="anchor" id="table-3"></a></p><center> <table class="doxtable">
<caption>Table 3. SAGE sound classes.</caption>
<tr>
<td><center><b>SAGE Class</b></center> </td><td><center><b>Design Pattern</b></center> </td><td><center><b>Description</b></center> </td></tr>
<tr>
<td><code><a class="el" href="class_sage_1_1_c_sound.html" title="The Sound Player.">Sage::CSound</a></code> </td><td>Component </td><td>Sound player </td></tr>
<tr>
<td><code><a class="el" href="class_sage_1_1_c_sound_desc.html" title="The sound descriptor.">Sage::CSoundDesc</a></code> </td><td>Descriptor </td><td>Sound descriptor </td></tr>
<tr>
<td><code><a class="el" href="class_sage_1_1_c_playable_sound_desc.html" title="The playable sound descriptor.">Sage::CPlayableSoundDesc</a></code> </td><td>Descriptor </td><td>Playable sound descriptor </td></tr>
</table>
</center><p>SAGE provides a sound player <code><a class="el" href="class_sage_1_1_c_sound.html" title="The Sound Player.">Sage::CSound</a></code> that will let you play and mix multiple copies of multiple sounds in 3D audio at varying pitches and volumes. If all you wish to do is play the sound at default pitch and volume, or perhaps specify only the pitch and/or the volume, <code><a class="el" href="class_sage_1_1_c_sound.html" title="The Sound Player.">Sage::CSound</a></code> has specific member functions for you. Anything more complicated needs you provide an instance of a sound descriptor <code><a class="el" href="class_sage_1_1_c_sound_desc.html" title="The sound descriptor.">Sage::CSoundDesc</a></code> as a parameter. <code><a class="el" href="class_sage_1_1_c_playable_sound_desc.html" title="The playable sound descriptor.">Sage::CPlayableSoundDesc</a></code> is intended for internal use in SAGE only, which means that you should never need to use it in your game. Loading sounds from <code>wav</code> files will be covered in <a class="el" href="index.html#sec3-7">Section 3.7</a>.</p>
<p>There are three basic functions for playing a sound:</p>
<ol type="1">
<li><code><a class="el" href="class_sage_1_1_c_sound.html#a1be9551e2557b2be52c8138cdfa0181b" title="Play sound.">Sage::CSound::Play</a></code> takes a sound index (usually a member of an enumerated type) and a position at which to play the sound (which defaults to the center of the world), and optionally the volume, or volume and pitch.</li>
<li><code><a class="el" href="class_sage_1_1_c_sound.html#a4bbfaa727641c4a3536933dcdaf99c51" title="Loop a sound.">Sage::CSound::Loop</a></code> takes a sound index and optionally a position at which to play the sound, and it plays the sound repeatedly until some version of the <code><a class="el" href="class_sage_1_1_c_sound.html#a37ccd37b4e00ff0daf110f888ee24280" title="Stop all sounds.">Sage::CSound::Stop</a></code> function is called.</li>
<li><code><a class="el" href="class_sage_1_1_c_sound.html#a2b3522a7cab6678044df4415eb668f56" title="Play a randomly varied sound.">Sage::CSound::Vary</a></code> takes a sound index, a position at which to play the sound, a coefficient of variability (which defaults to <code>0.25f</code>) and plays the sound at a different volume and pitch each time it is called, varying by the coefficient of variability. A base volume and pitch may also be provided.</li>
</ol>
<p>See <code><a class="el" href="class_sage_1_1_c_sound.html" title="The Sound Player.">Sage::CSound</a></code> for more functions.</p>
<p><a class="anchor" id="sec3-4"></a></p><h2>3.4 Game Objects</h2>
<p><a class="anchor" id="table-4"></a></p><center> <table class="doxtable">
<caption>Table 4. SAGE game object classes.</caption>
<tr>
<td><center><b>SAGE Class</b></center> </td><td><center><b>Design Pattern</b></center> </td><td><center><b>Description</b></center> </td></tr>
<tr>
<td><code><a class="el" href="class_sage_1_1_c_object.html" title="A basic game object.">Sage::CObject</a></code> </td><td>Entity </td><td>Basic game object </td></tr>
<tr>
<td><code><a class="el" href="class_sage_1_1_c_object_manager.html" title="A basic object manager.">Sage::CObjectManager</a></code> </td><td>Manager </td><td>Basic object manager </td></tr>
</table>
</center><p>A <em>game object</em> is the abstract representation of a thing in your game, such as a character, a wall, or a missile. SAGE best practice is to derive your own game object class <code>CObject</code> from <code><a class="el" href="class_sage_1_1_c_object.html" title="A basic game object.">Sage::CObject</a></code>, which provides base functionality to game objects. <code><a class="el" href="class_sage_1_1_c_object.html" title="A basic game object.">Sage::CObject</a></code> provides stubs for the move and draw virtual functions <code><a class="el" href="class_sage_1_1_c_object.html#ae33d05b96b8b11fe621e42525a908041" title="Move object stub.">Sage::CObject::Move</a></code> and <code><a class="el" href="class_sage_1_1_c_object.html#ae060ffb1aa3bf6148614cf6506074e42" title="Draw object stub.">Sage::CObject::Draw</a></code>, which are stubs that you should definitely override in your implementation of <code>CObject</code>.</p>
<p>It is also SAGE best practice to manage your objects with an <em>object manager</em> <code>CObjectManager</code> derived from <code><a class="el" href="class_sage_1_1_c_object_manager.html" title="A basic object manager.">Sage::CObjectManager</a></code>, which provides base functionality to manage game objects. <code><a class="el" href="class_sage_1_1_c_object_manager.html" title="A basic object manager.">Sage::CObjectManager</a></code> maintains an <em>object list</em> containing pointers to game objects, which are assumed to have been derived from <code><a class="el" href="class_sage_1_1_c_object.html" title="A basic game object.">Sage::CObject</a></code>. It has a virtual function <code><a class="el" href="class_sage_1_1_c_object_manager.html#a8f06559d62161b1c63e3cc2286be7364" title="Draw all objects.">Sage::CObjectManager::Draw</a></code> which calls the virtual <code>Draw</code> function of every object in the object list, and a virtual function <code><a class="el" href="class_sage_1_1_c_object_manager.html#a1f0837f301ca52d81a3751f7bfb6b0a7" title="Move all objects.">Sage::CObjectManager::Move</a></code> which calls the virtual <code>Move</code> function of every object in the object list, then performs collision detection and response between pairs of objects in the object list.</p>
<p>When an instance of your game object class <code>CObject</code> derived from <code><a class="el" href="class_sage_1_1_c_object.html" title="A basic game object.">Sage::CObject</a></code> dies in your game, you must call its inherited function <code><a class="el" href="class_sage_1_1_c_object.html#a7e838dcbf825211c5fc89a06c8c24c07" title="Mark as ready for deletion.">Sage::CObject::MarkForDeletion</a></code>. At the end of <code><a class="el" href="class_sage_1_1_c_object_manager.html#a1f0837f301ca52d81a3751f7bfb6b0a7" title="Move all objects.">Sage::CObjectManager::Move</a></code>, after collision detection and response, all objects in the object list that have been marked for deletion are removed from the object list and <code>delete</code>d. Your <code>CObjectManager::Move</code> function which over-rides <code><a class="el" href="class_sage_1_1_c_object_manager.html#a1f0837f301ca52d81a3751f7bfb6b0a7" title="Move all objects.">Sage::CObjectManager::Move</a></code> can either call <code><a class="el" href="class_sage_1_1_c_object_manager.html#a1f0837f301ca52d81a3751f7bfb6b0a7" title="Move all objects.">Sage::CObjectManager::Move</a></code> or perform its own object motion and collision detection and response, and then call <code><a class="el" href="class_sage_1_1_c_object_manager.html#a20ad5ed14e5a024f2b1924bd54679bb1" title="Cull dead objects.">Sage::CObjectManager::DeleteMarkedObjects</a></code>.</p>
<p><a class="anchor" id="sec3-5"></a></p><h2>3.5 Rendering</h2>
<p><a class="anchor" id="table-5"></a></p><center> <table class="doxtable">
<caption>Table 5. SAGE rendering classes.</caption>
<tr>
<td><center><b>SAGE Class</b></center> </td><td><center><b>Design Pattern</b></center> </td><td><center><b>Description</b></center> </td></tr>
<tr>
<td><code><a class="el" href="class_sage_1_1_c_camera.html" title="A basic camera.">Sage::CCamera</a></code> </td><td>Component </td><td>Camera </td></tr>
<tr>
<td><code><a class="el" href="class_sage_1_1_c_camera_common.html" title="The camera common variables class.">Sage::CCameraCommon</a></code> </td><td>Accessor </td><td>Camera common variables </td></tr>
<tr>
<td><code><a class="el" href="class_sage_1_1_c_renderer3_d.html" title="The renderer.">Sage::CRenderer3D</a></code> </td><td>Component </td><td>3d renderer </td></tr>
<tr>
<td><code><a class="el" href="class_sage_1_1_c_screenshot_flag.html" title="Screenshot flag.">Sage::CScreenshotFlag</a></code> </td><td>Accessor </td><td>Screenshot flag </td></tr>
<tr>
<td><code><a class="el" href="class_sage_1_1_c_sprite_renderer.html" title="The sprite renderer class.">Sage::CSpriteRenderer</a></code> </td><td>Component </td><td>Sprite renderer </td></tr>
<tr>
<td><code><a class="el" href="class_sage_1_1_c_texture_desc.html" title="The texture descriptor.">Sage::CTextureDesc</a></code> </td><td>Descriptor </td><td>Texture descriptor </td></tr>
</table>
</center><p>SAGE provides two rendering classes, <code><a class="el" href="class_sage_1_1_c_sprite_renderer.html" title="The sprite renderer class.">Sage::CSpriteRenderer</a></code> for 2D and 2.5D sprite games, and <code><a class="el" href="class_sage_1_1_c_renderer3_d.html" title="The renderer.">Sage::CRenderer3D</a></code>. Control of the camera is provided by accessing the variables in <code><a class="el" href="class_sage_1_1_c_camera_common.html" title="The camera common variables class.">Sage::CCameraCommon</a></code>. <code><a class="el" href="class_sage_1_1_c_camera.html" title="A basic camera.">Sage::CCamera</a></code> is intended only for internal use in SAGE and should not be instantiated in your game. The camera can be accessed through the renderer using, for example, <code><a class="el" href="class_sage_1_1_c_sprite_renderer.html#ad42ed608e0480651f4c6da83a956b823" title="Get camera position.">Sage::CSpriteRenderer::GetCameraPos</a></code> and <code><a class="el" href="class_sage_1_1_c_sprite_renderer.html#acfb173389d223b51774f5c0500a88aad" title="Set camera position.">Sage::CSpriteRenderer::SetCameraPos</a></code>. <code><a class="el" href="class_sage_1_1_c_screenshot_flag.html" title="Screenshot flag.">Sage::CScreenshotFlag</a></code>, which enables screen shotting when the player presses the <code>print screen</code> button, is also intended only for internal use in SAGE and should not be instantiated in your game. The texture descriptor <code><a class="el" href="class_sage_1_1_c_texture_desc.html" title="The texture descriptor.">Sage::CTextureDesc</a></code> is intended for use in 3D games only and should not be instantiated in a 2D or 2.5D sprite game.</p>
<p><code><a class="el" href="class_sage_1_1_c_sprite_renderer.html" title="The sprite renderer class.">Sage::CSpriteRenderer</a></code> has several versions of <code><a class="el" href="class_sage_1_1_c_sprite_renderer.html#ac3515ab913c5849c73bbf52532b3ca30" title="Draw single 2D sprite.">Sage::CSpriteRenderer::Draw</a></code> to draw a sprite, the simplest of which takes as parameters a sprite index, a position, and (optionally) an orientation angle in radians. If more control is desired, such as scaling and tinting, construct an instance of <code><a class="el" href="class_sage_1_1_c_sprite_desc2_d.html" title="The 2D sprite descriptor.">Sage::CSpriteDesc2D</a></code> and pass a pointer to it to <code><a class="el" href="class_sage_1_1_c_sprite_renderer.html#ac3515ab913c5849c73bbf52532b3ca30" title="Draw single 2D sprite.">Sage::CSpriteRenderer::Draw</a></code> instead. Since neither DirectX12 nor the DirectX12 Toolkit provide functions for drawing lines, rectangles, or circles, these functions are provided by <code><a class="el" href="class_sage_1_1_c_sprite_renderer.html" title="The sprite renderer class.">Sage::CSpriteRenderer</a></code>, although frankly they are a kluge.</p>
<p>The <code><a class="el" href="class_sage_1_1_c_sprite_renderer.html" title="The sprite renderer class.">Sage::CSpriteRenderer</a></code> constructor allows it to be used in three modes, specified by a parameter of the enumerated type <code><a class="el" href="_sage_sprite_renderer_8h.html#a375d1121f311fdd0e83ceb43c6544367" title="Render mode type.">Sage::eSpriteMode</a></code>. <code>Sage::eSpriteMode::Batched2D</code> renders sprites using <code>SpriteBatch</code> from the DirectX12 Toolkit. <code>Sage::eSpriteMode::Unbatched2D</code> renders sprites natively. Both of these modes render using <em>painter's algorithm</em>, that is, sprites are drawn on top of each other in the order in which they are rendered. This means that the background must be drawn first, and that anything that must be drawn on top of anything, such as text or instrumentation, must be drawn last.</p>
<p><code>Sage::eSpriteMode::Unbatched3D</code> is for use in 3D games (experimental at the moment) or in 2D or 2.5D games in which you want or need the capability to draw the sprites in any order, with the depth specified by the third dimension of a 3D vector. In this case, instead of calling <code><a class="el" href="class_sage_1_1_c_sprite_renderer.html#ac3515ab913c5849c73bbf52532b3ca30" title="Draw single 2D sprite.">Sage::CSpriteRenderer::Draw</a></code> for each sprite, collect the 3D sprite descriptors in an instance of <code>std::vector&lt;<a class="el" href="class_sage_1_1_c_sprite_desc3_d.html" title="The 3D sprite descriptor.">Sage::CSpriteDesc3D</a>&gt;</code> and pass that as a parameter to <code><a class="el" href="class_sage_1_1_c_sprite_renderer.html#ac3515ab913c5849c73bbf52532b3ca30" title="Draw single 2D sprite.">Sage::CSpriteRenderer::Draw</a></code> which will sort them by depth (in Z-order) before rendering them.</p>
<p>For 2D games in particular, <code><a class="el" href="class_sage_1_1_c_sprite_renderer.html" title="The sprite renderer class.">Sage::CSpriteRenderer</a></code> includes multiple ways of drawing 2D sprites using <code><a class="el" href="class_sage_1_1_c_sprite_renderer.html#ac3515ab913c5849c73bbf52532b3ca30" title="Draw single 2D sprite.">Sage::CSpriteRenderer::Draw</a></code> by providing the following parameters.</p>
<ol type="1">
<li>The sprite index (usually a member of an enumerated type), a position, and optionally the orientation angle (in radians, measured counter-clockwise from the positive X-axis), which defaults to zero.</li>
<li>A pointer to an instance of the 2D sprite descriptor <code>CSpriteDesc2D</code>. See <a class="el" href="index.html#spritedesc">Section 3.6</a> for more details.</li>
</ol>
<p><a class="anchor" id="sec3-6"></a></p><h2>3.6 Sprites</h2>
<p><a class="anchor" id="table-6"></a></p><center> <table class="doxtable">
<caption>Table 6. SAGE sprite classes.</caption>
<tr>
<td><center><b>SAGE Class</b></center> </td><td><center><b>Design Pattern</b></center> </td><td><center><b>Description</b></center> </td></tr>
<tr>
<td><code><a class="el" href="class_sage_1_1_c_sprite.html" title="The sprite.">Sage::CSprite</a></code> </td><td>Component </td><td>Sprite </td></tr>
<tr>
<td><code><a class="el" href="class_sage_1_1_c_sprite_desc.html" title="The base sprite descriptor.">Sage::CSpriteDesc</a></code> </td><td>Descriptor </td><td>Base sprite descriptor </td></tr>
<tr>
<td><code><a class="el" href="class_sage_1_1_c_sprite_desc2_d.html" title="The 2D sprite descriptor.">Sage::CSpriteDesc2D</a></code> </td><td>Descriptor </td><td>2D sprite descriptor </td></tr>
<tr>
<td><code><a class="el" href="class_sage_1_1_c_sprite_desc3_d.html" title="The 3D sprite descriptor.">Sage::CSpriteDesc3D</a></code> </td><td>Descriptor </td><td>3D sprite descriptor </td></tr>
</table>
</center><p><code><a class="el" href="class_sage_1_1_c_sprite.html" title="The sprite.">Sage::CSprite</a></code> is the abstract representation of a multi-frame sprite. It is intended only for internal use in SAGE and should not be instantiated in your game. <code><a class="el" href="class_sage_1_1_c_sprite_renderer.html" title="The sprite renderer class.">Sage::CSpriteRenderer</a></code> maintains a list of pointers to instances of <code><a class="el" href="class_sage_1_1_c_sprite.html" title="The sprite.">Sage::CSprite</a></code> and will take care of their management without any need for additional code in your game. The 2D sprite descriptor <code><a class="el" href="class_sage_1_1_c_sprite_desc2_d.html" title="The 2D sprite descriptor.">Sage::CSpriteDesc2D</a></code> describes the properties of a two-dimensional sprite in a 2D or 2.5D game, and <code><a class="el" href="class_sage_1_1_c_sprite_desc3_d.html" title="The 3D sprite descriptor.">Sage::CSpriteDesc3D</a></code> does the same for a three-dimensional sprite in a 3D game.</p>
<p><code><a class="el" href="class_sage_1_1_c_sprite_desc.html" title="The base sprite descriptor.">Sage::CSpriteDesc</a></code> describes the properties common to 2D and 3D sprites, and <code><a class="el" href="class_sage_1_1_c_sprite_desc2_d.html" title="The 2D sprite descriptor.">Sage::CSpriteDesc2D</a></code> and <code><a class="el" href="class_sage_1_1_c_sprite_desc3_d.html" title="The 3D sprite descriptor.">Sage::CSpriteDesc3D</a></code> are derived from it. It is intended only for internal use in SAGE and should not be instantiated in your game.</p>
<h3>Important Sprite Properties</h3>
<p>Important sprite properties in <code><a class="el" href="class_sage_1_1_c_sprite.html" title="The sprite.">Sage::CSprite</a></code> include an array <code><a class="el" href="class_sage_1_1_c_sprite.html#ab5fb355100cf90ab77c6708910c35a61" title="Bounding rectangle in sprite sheet.">Sage::CSprite::m_pRect</a></code> of bounding rectangles for a multi-frame sprite contained in a sprite sheet (a single image containing multiple frames) and useful reader functions such as <code><a class="el" href="class_sage_1_1_c_sprite.html#a30dea0b1985ce1e31f7cccd8b7465b89" title="Get sprite width.">Sage::CSprite::GetWidth</a></code> and <code><a class="el" href="class_sage_1_1_c_sprite.html#a79573e321b70516aaa0de4c50e2b8f3e" title="Get sprite height.">Sage::CSprite::GetHeight</a></code> to get the width and height (respectively) of the sprite in pixels after it has been loaded.</p>
<p><a class="anchor" id="spritedesc"></a></p><h3>Important Sprite Descriptor Properties</h3>
<p>Important properties of <code><a class="el" href="class_sage_1_1_c_sprite_desc.html" title="The base sprite descriptor.">Sage::CSpriteDesc</a></code>, and therefore <code><a class="el" href="class_sage_1_1_c_sprite_desc2_d.html" title="The 2D sprite descriptor.">Sage::CSpriteDesc2D</a></code> and <code><a class="el" href="class_sage_1_1_c_sprite_desc3_d.html" title="The 3D sprite descriptor.">Sage::CSpriteDesc3D</a></code> include the sprite index, current animation frame, scale along the local X-axis of the sprite, scale along the local Y-axis of the sprite, roll angle (orientation), tint (which lets you color the non-black pixels of the sprite), and alpha value (amount of transparency).</p>
<p><a class="anchor" id="sec3-7"></a></p><h2>3.7 Loading Media</h2>
<p><a class="anchor" id="table-7"></a></p><center> <table class="doxtable">
<caption>Table 7. SAGE media loading classes.</caption>
<tr>
<td><center><b>SAGE Class</b></center> </td><td><center><b>Design Pattern</b></center> </td><td><center><b>Description</b></center> </td></tr>
<tr>
<td><code><a class="el" href="class_sage_1_1_c_loading_thread.html" title="A thread class for loading images and sounds.">Sage::CLoadingThread</a></code> </td><td>Component </td><td>Media loading thread </td></tr>
<tr>
<td><code><a class="el" href="class_sage_1_1_c_media_desc.html" title="Media descriptor.">Sage::CMediaDesc</a></code> </td><td>Descriptor </td><td>Media descriptor </td></tr>
<tr>
<td><code><a class="el" href="class_sage_1_1_c_media_list.html" title="The media descriptor list.">Sage::CMediaList</a></code> </td><td>Component </td><td>Media descriptor list </td></tr>
</table>
</center><p>SAGE provides the ability to read media, that is, sprites and sounds sequentially or in parallel threads. The problem with the former is that your game window will freeze up while the media loads from disk, which can be for several seconds depending on the size of the media and the speed of your computers HD or SSD. While multi-threaded loading is preferable, sequential loading is provided for debugging and testing purposes.</p>
<p>In either case, SAGE makes use of a <em>media descriptor</em> class <code><a class="el" href="class_sage_1_1_c_media_desc.html" title="Media descriptor.">Sage::CMediaDesc</a></code> which consists of a an index and a string. The index is used to store the piece of media in an array, and the string is used to search for an XML tag that specifies the media file from which it is to be read. To load sounds, insert the corresponding media descriptors into an instance of <code><a class="el" href="class_sage_1_1_c_media_list.html" title="The media descriptor list.">Sage::CMediaList</a></code> and pass that as a parameter to <code><a class="el" href="class_sage_1_1_c_sound.html#a50299d4b69d084660b473d4e54c34ee8" title="Load sounds multithreaded.">Sage::CSound::LoadMT</a></code> for asynchronous (i.e. multi-threaded) loading or to <code><a class="el" href="class_sage_1_1_c_sound.html#ab0963bf4377958e9df04ea925c8a29ea" title="Load sounds.">Sage::CSound::Load</a></code> for sequential loading (see <a class="el" href="index.html#sec3-3">Section 3.3</a> for more information about <code><a class="el" href="class_sage_1_1_c_sound.html" title="The Sound Player.">Sage::CSound</a></code>). To load sprites, insert the corresponding media descriptors into an instance of <code><a class="el" href="class_sage_1_1_c_media_list.html" title="The media descriptor list.">Sage::CMediaList</a></code> and pass that as a parameter to <code><a class="el" href="class_sage_1_1_c_sprite_renderer.html#adc58cbeb01e943290082ba84d2e54704" title="Load sprites multithreaded.">Sage::CSpriteRenderer::LoadMT</a></code> for asynchronous (i.e. multi-threaded) loading or to <code><a class="el" href="class_sage_1_1_c_sprite_renderer.html#aef2c9196aae92e3118adf7755f9b9b8d" title="Load sprite.">Sage::CSpriteRenderer::Load</a></code> for sequential loading (see <a class="el" href="index.html#sec3-6">Section 3.6</a> for more information about <code><a class="el" href="class_sage_1_1_c_sprite_renderer.html" title="The sprite renderer class.">Sage::CSpriteRenderer</a></code>).</p>
<p><a class="anchor" id="sec3-8"></a></p><h2>3.8 Particle Engine</h2>
<p><a class="anchor" id="table-8"></a></p><center> <table class="doxtable">
<caption>Table 8. SAGE particle engine classes.</caption>
<tr>
<td><center><b>SAGE Class</b></center> </td><td><center><b>Design Pattern</b></center> </td><td><center><b>Description</b></center> </td></tr>
<tr>
<td><code><a class="el" href="_sage_particle_8h.html#a6c10245758fab1c82a8a3d632092f588" title="2D particle descriptor.">Sage::CParticleDesc2D</a></code> </td><td>Descriptor </td><td>2D particle descriptor </td></tr>
<tr>
<td><code><a class="el" href="_sage_particle_8h.html#af445bd7e754b5b0b548632f818d0466d" title="3D particle descriptor.">Sage::CParticleDesc3D</a></code> </td><td>Descriptor </td><td>3D particle descriptor </td></tr>
<tr>
<td><code><a class="el" href="class_sage_1_1_c_particle_engine2_d.html" title="The 2D particle engine.">Sage::CParticleEngine2D</a></code> </td><td>Component </td><td>2D particle engine </td></tr>
<tr>
<td><code><a class="el" href="class_sage_1_1_c_particle_engine3_d.html" title="The 3D particle engine.">Sage::CParticleEngine3D</a></code> </td><td>Component </td><td>3D particle engine </td></tr>
</table>
</center><p>SAGE provides a 2D particle engine <code><a class="el" href="class_sage_1_1_c_particle_engine2_d.html" title="The 2D particle engine.">Sage::CParticleEngine2D</a></code> and a 3D particle engine <code><a class="el" href="class_sage_1_1_c_particle_engine3_d.html" title="The 3D particle engine.">Sage::CParticleEngine3D</a></code> (under development), both derived from <code><a class="el" href="class_sage_1_1_c_particle_engine.html" title="An abstract particle engine.">Sage::CParticleEngine</a></code>. The latter is intended only for internal use in SAGE and should not be instantiated in your game. <code><a class="el" href="class_sage_1_1_c_particle.html" title="A particle.">Sage::CParticle</a></code> represents a particle and should also not be instantiated in your game. To create a particle in a 2D game, fill in a <em>2D particle descriptor</em> <code><a class="el" href="_sage_particle_8h.html#a6c10245758fab1c82a8a3d632092f588" title="2D particle descriptor.">Sage::CParticleDesc2D</a></code> with the particle properties (including fade in, fade out, scale in, scale out) and pass it as a parameter to <code><a class="el" href="class_sage_1_1_c_particle_engine.html#a658946afe6b97cb098b8b3b19d212926" title="Create particle.">Sage::CParticleEngine2D::Create</a></code>. Function <code><a class="el" href="class_sage_1_1_c_particle_engine.html#aebc9640270acf9d83595238d533c073f" title="Animation step.">Sage::CParticleEngine2D::Step</a></code> must be called once per frame to animate 2D particles. To create a particle in a 3D game, fill in a <em>3D particle descriptor</em> <code><a class="el" href="_sage_particle_8h.html#af445bd7e754b5b0b548632f818d0466d" title="3D particle descriptor.">Sage::CParticleDesc3D</a></code> with the particle properties and pass it as a parameter to <code><a class="el" href="class_sage_1_1_c_particle_engine.html#a658946afe6b97cb098b8b3b19d212926" title="Create particle.">Sage::CParticleEngine3D::Create</a></code>. Function <code><a class="el" href="class_sage_1_1_c_particle_engine.html#aebc9640270acf9d83595238d533c073f" title="Animation step.">Sage::CParticleEngine3D::Step</a></code> must be called once per frame to animate 3D particles.</p>
<h3>Important Particle Descriptor Properties</h3>
<p>Important properties of <code><a class="el" href="class_sage_1_1_c_particle_desc.html" title="The particle descriptor.">Sage::CParticleDesc</a></code>, and therefore <code><a class="el" href="_sage_particle_8h.html#a6c10245758fab1c82a8a3d632092f588" title="2D particle descriptor.">Sage::CParticleDesc2D</a></code> and <code><a class="el" href="_sage_particle_8h.html#af445bd7e754b5b0b548632f818d0466d" title="3D particle descriptor.">Sage::CParticleDesc3D</a></code> include the particle's velocity, acceleration, friction, rotational velocity, lifetime in seconds, scale-in and scale-out fractions (as a fraction of lifetime), and fade-in and fade-out fractions (also as a fraction of lifetime). For example, with lifetime equal to <code>1.5f</code> seconds, scale-in equal to <code>0.2f</code> and scale-out equal to <code>0.5f</code>, the particle grows from zero to full size in <code>0.2f*1.5f = 0.3f</code> seconds, remains at full size for <code>0.45</code> seconds, and shrinks to zero in <code>1.5f*0.5f = 0.75f</code> seconds. Similarly, with lifetime equal to <code>1.5f</code> seconds, fade-in equal to <code>0.2f</code> and fades-out equal to <code>0.5f</code>, the particle fades in from fully transparent to fully opaque in <code>0.2f*1.5f = 0.3f</code> seconds, remains at full opaqueness for <code>0.45</code> seconds, and fades out to full transparency in <code>1.5f*0.5f = 0.75f</code> seconds. Both scaling and transparency may be used together.</p>
<p><a class="anchor" id="sec3-9"></a></p><h2>3.9 Windows and Settings</h2>
<p><a class="anchor" id="table-9"></a></p><center> <table class="doxtable">
<caption>Table 9. SAGE windows and settings classes.</caption>
<tr>
<td><center><b>SAGE Class</b></center> </td><td><center><b>Design Pattern</b></center> </td><td><center><b>Description</b></center> </td></tr>
<tr>
<td><code><a class="el" href="class_sage_1_1_c_settings.html" title="Settings.">Sage::CSettings</a></code> </td><td>Accessor </td><td>Game settings </td></tr>
<tr>
<td><code><a class="el" href="class_sage_1_1_c_settings_manager.html" title="Settings manager.">Sage::CSettingsManager</a></code> </td><td>Manager </td><td>Game settings manager </td></tr>
<tr>
<td><code><a class="el" href="class_sage_1_1_c_window.html" title="The window class.">Sage::CWindow</a></code> </td><td>Component </td><td>Window handler </td></tr>
<tr>
<td><code><a class="el" href="class_sage_1_1_c_window_desc.html" title="The window descriptor.">Sage::CWindowDesc</a></code> </td><td>Descriptor </td><td>Window descriptor </td></tr>
</table>
</center><p><code><a class="el" href="class_sage_1_1_c_settings.html" title="Settings.">Sage::CSettings</a></code> contains game settings that are read from an XML file by <code><a class="el" href="class_sage_1_1_c_settings_manager.html" title="Settings manager.">Sage::CSettingsManager</a></code>. Any of your game classes that require these settings should be derived from <code><a class="el" href="class_sage_1_1_c_settings.html" title="Settings.">Sage::CSettings</a></code>. The <em>window descriptor</em> <code><a class="el" href="class_sage_1_1_c_window_desc.html" title="The window descriptor.">Sage::CWindowDesc</a></code> contains some important Windows properties such as the window and instance handles for your game. Any of your game classes that require these properties should be derived from <code><a class="el" href="class_sage_1_1_c_window_desc.html" title="The window descriptor.">Sage::CWindowDesc</a></code>. <code><a class="el" href="class_sage_1_1_c_window.html" title="The window class.">Sage::CWindow</a></code> handles Windows specific operations required to manage your game. It should be instantiated in your <code>main.cpp</code>.</p>
<p><a class="anchor" id="sec3-10"></a></p><h2>3.10 Other</h2>
<p><a class="anchor" id="table-10"></a></p><center> <table class="doxtable">
<caption>Table 10. Other SAGE classes.</caption>
<tr>
<td><center><b>SAGE Class</b></center> </td><td><center><b>Design Pattern</b></center> </td><td><center><b>Description</b></center> </td></tr>
<tr>
<td><code><a class="el" href="class_sage_1_1_c_component.html" title="The component accessor.">Sage::CComponent</a></code> </td><td>Aggregator </td><td>Component pointers </td></tr>
<tr>
<td><code><a class="el" href="class_sage_1_1_c_random.html" title="A Pseudorandom Number Generator (PRNG for short).">Sage::CRandom</a></code> </td><td>Component </td><td>Pseudo-random number generator </td></tr>
</table>
</center><p><code><a class="el" href="class_sage_1_1_c_random.html" title="A Pseudorandom Number Generator (PRNG for short).">Sage::CRandom</a></code> is a pseudo-random number generator that can be used to generate pseudo-random integers, floating point values, and colors. It can be set to generate a different sequence of pseudo-random values every time your game is played, or, for debugging purposes, to generate the same sequence of pseudo-random values every time your game is played.</p>
<p><code><a class="el" href="class_sage_1_1_c_component.html" title="The component accessor.">Sage::CComponent</a></code> contains pointers to important components that are instantiated for you by SAGE. These include a sound player, a timer, a pseudo-random number generator, and handlers for a keyboard, mouse, and XBox controller. Any of your game classes that require these components should be derived from <code><a class="el" href="class_sage_1_1_c_component.html" title="The component accessor.">Sage::CComponent</a></code>.</p>
<p><a class="anchor" id="sec4"></a></p><h1>4. Some Sage Code Conventions</h1>
<ol type="1">
<li>SAGE class names always start with an upper-case <code>C</code> for <em>class</em>, for example, <code>CRandom</code> and <code>CSprite</code>.</li>
<li>SAGE code is in namespace <code>Sage</code>, so you will have to access tham as, for example, <code><a class="el" href="class_sage_1_1_c_random.html" title="A Pseudorandom Number Generator (PRNG for short).">Sage::CRandom</a></code> and <code><a class="el" href="class_sage_1_1_c_sprite.html" title="The sprite.">Sage::CSprite</a></code>. This will help you to distinguish the SAGE code from the non-SAGE code in the examples.</li>
<li>Generally, a class <code>Sage::XXX</code> will have its declaration in a header file called <code>SageXXX.h</code> and its implementation in a code file called <code>SageXXX.cpp</code>. There are some exceptions, for example, templated code.</li>
<li>Class member variables have names that start with a lower-case <code>m</code> for <em>member</em> followed by the underline character, like this: <code>m_</code>. The next character or two will be a lower-case string indicative of the variable type, followed by the first letter of the variable's descriptive name, which will always be upper-case. For example, <code>m_fFriction</code> is a floating point variable for friction, <code>m_nNumFrames</code> is an integer variable for the number of frames (which could be <code>int</code>, <code>UINT</code>, or <code>size_t</code>), and <code>m_pTimer</code> is a pointer to a timer.</li>
<li>In 2D SAGE games the Origin of the coordinate space it at the lower-leftmost point of the window. The positive X-axis goes to the right, the positive Y-axis does up, and the positive Z-axis does into the screen.</li>
<li>The <em>orientation</em> of a sprite in SAGE, that is, the angle that it is to be rotated, is called <code>m_fRoll</code>, because in 3D games we have three orientation angles, <em>yaw</em> (rotation about the Y-axis), <em>pitch</em> (rotation about the X-axis) and <em>roll</em> (rotation about the Z-axis).</li>
<li>SAGE is documented using <a href="https://www.doxygen.nl/">Doxygen</a> which allows us to generate html documentation from programmer-readable comments. Doxygen comments start with <code>///</code> for a block comment and <code>//&lt;</code> for an in-line comment.</li>
<li>Public member functions that simply return the value stored in a private or protected member variables start with <code>Get</code>, for example, <br  />
 <code><a class="el" href="class_sage_1_1_c_camera.html#a05b6b3579ca3f643f1ef406ef23df390" title="Get yaw.">Sage::CCamera::GetYaw</a></code> returns <code><a class="el" href="class_sage_1_1_c_camera.html#a77e9417f6c40b0ed97efb51e4d4e25e7" title="Yaw angle.">Sage::CCamera::m_fYaw</a></code>.</li>
<li>Public member functions that modify the values stored in private or protected member variables start with <code>Set</code>, for example, <br  />
 <code><a class="el" href="class_sage_1_1_c_camera.html#a33a9fe002bf74b84c5a0d5380ce313b6" title="Set yaw.">Sage::CCamera::SetYaw</a></code> sets <code><a class="el" href="class_sage_1_1_c_camera.html#a77e9417f6c40b0ed97efb51e4d4e25e7" title="Yaw angle.">Sage::CCamera::m_fYaw</a></code> and recomputes the camera's orientation matrix and view frustum.</li>
</ol>
<p><a class="anchor" id="sec5"></a></p><h1>5. What Next?</h1>
<p>If SAGE is not already installed on your computer, please read and follow <a href="../install/index.html">the installation instructions</a>. Finally, the <code>sage</code> repository comes with a simple game called the <a href="../blank/index.html">Blank Game</a>. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7
</small></address>
</body>
</html>
