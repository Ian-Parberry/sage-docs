<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Collision Math Toy: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="sagedoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">Collision Math Toy
   </div>
   <div id="projectbrief">Game Physics with Bespoke Code</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="doc-content">
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="contents">
<div class="textblock"><p><a class="anchor" id="section1"></a></p><h1>1. Introduction</h1>
<p>This is a collision detection and response toy intended to help you visualize what's going on in the in the <a href="../shapes/index.html">Shapes Library</a> by experimenting with various settings and measurements using a dialog box. <a class="el" href="#fig1">Fig. 1</a> shows a screenshot of the toy before any balls are launched. Balls are launched from the bottom right corner and travel vertically before hitting the arc in the top right corner and entering the main play area. There are various shapes to collide with, including line segments, points, arcs, and circles. Two objects, the convex arc at the top left corner and the pinball bumper at the middle right, have an <a href="../shapes/index.html#section5-4">elasticity</a> greater than <code>1.0f</code>, that is, they increase the velocity of balls that collide with them. Some of the line segments and arcs have motion type <a href="../shapes/index.html#section5-3"><code>Shapes::eMotion::Kinematic</code></a>, although they start out with rotational velocity zero until you select the Rotate checkbox in the <a class="el" href="#section2-7">Other</a> area of the <a class="el" href="#section2">dialog box</a> controls, at which time they will have a constant but non-zero rotational velocity.</p>
<p><a class="anchor" id="fig1"></a></p><div class="image">
<img src="screenshot.png" alt="" width="60%"/>
<div class="caption">
Fig. 1: Screen shot.</div></div>
<p>The remainder of this page is divided into five sections. <a class="el" href="#section2">Section 2</a> lists the controls and their corresponding actions, <a class="el" href="#section3">Section 3</a> tells you how to build it, <a class="el" href="#section4">Section 4</a> gives you a list of actions to take in the game to see some of its important features, <a class="el" href="#section5">Section 5</a> gives a breakdown of the code, <a class="el" href="#section6">Section 6</a> contains some programming problems, and <a class="el" href="#section7">Section 7</a> addresses the question "what next?".</p>
<p><a class="anchor" id="section2"></a></p><h1>2. Controls</h1>
<p><a class="anchor" id="fig2"></a></p><div class="image">
<img src="dialogbox.png" alt="" width="50%"/>
<div class="caption">
Fig. 2: The dialog box containing the controls.</div></div>
<p>The Collision Math Toy is controlled by the dialog box shown in <a class="el" href="#fig2">Fig. 2</a>, which is divided up into regions as described below.</p>
<p><a class="anchor" id="section2-1"></a></p><h2>2.1 Balls in Play</h2>
<p><a class="anchor" id="fig3"></a></p><div class="image">
<img src="dialogbox1.png" alt="" width="197px"/>
<div class="caption">
Fig. 3: The Balls in Play region.</div></div>
<ul>
<li>Launched: The number of balls launched.</li>
<li>Overlaps: The number of balls that have position identical to another ball. This will happen if two balls overlap by too much as a result of, say, inaccurate collision-response. Clearly code should be written to exclude this behavior, but it hasn't been implemented so that you can see that it happens.</li>
<li>Strays: The number of balls that have tunneled through the outside walls. This will happen if a small ball is moving quickly and the number of motion and collision iterations is inadequate. Clearly code should be written to exclude this behavior, but it hasn't been implemented so that you can see that it happens.</li>
</ul>
<p><a class="anchor" id="section2-2"></a></p><h2>2.2 Load</h2>
<p><a class="anchor" id="fig4"></a></p><div class="image">
<img src="dialogbox2.png" alt="" width="61px"/>
<div class="caption">
Fig. 4: The Load region.</div></div>
<ul>
<li>FPS: The current number of animation frames per second.</li>
<li>Load bar: A rough estimate of the amount of CPU time being used per animation frame as a fraction of the frame time.</li>
</ul>
<p><a class="anchor" id="section2-3"></a></p><h2>2.3 Next Ball</h2>
<p><a class="anchor" id="fig5"></a></p><div class="image">
<img src="dialogbox3.png" alt="" width="154px"/>
<div class="caption">
Fig. 5: The Next Ball region.</div></div>
<ul>
<li>Size: The size of the next ball to be launched is controlled by a slider.</li>
<li>Speed: The speed of the next ball to be launched is controlled by a slider.</li>
</ul>
<p><a class="anchor" id="section2-4"></a></p><h2>2.4 Collision Detection and Response</h2>
<p><a class="anchor" id="fig6"></a></p><div class="image">
<img src="dialogbox4.png" alt="" width="166px"/>
<div class="caption">
Fig. 6: The Collision Detection and Response region.</div></div>
<ul>
<li>AABB tests per iteration: The number of AABB overlap tests performed per collision iteration.</li>
<li>AABB tests per second: The number of AABB overlap tests performed per second.</li>
<li>Full tests per second: The number of full tests performed per second. These are performed only when AABBs overlap.</li>
<li>Collisions per second: The number of actual collisions per second, that is, the number of full tests that indicate an overlap.</li>
</ul>
<p><a class="anchor" id="section2-5"></a></p><h2>2.5 Quadtree</h2>
<p><a class="anchor" id="fig7"></a></p><div class="image">
<img src="dialogbox5.png" alt="" width="149px"/>
<div class="caption">
Fig. 7: The Quadtree region.</div></div>
<p>See <a class="el" href="#section5-4">Section 5.4</a> for more details on quadtrees.</p><ul>
<li>Active: Toggle the use of quadtrees for space subdivision.</li>
<li>Levels: Set the number of levels in the quadtree.</li>
<li>Nodes: The number of nodes in an active quadtree.</li>
<li>Leaves: The number of leaves in an active quadtree.</li>
<li>Leaf area: The dimension of the rectangle covered by each quadtree leaf.</li>
<li>Max shapes per leaf: The maximum over all leaves of the number of shapes in a leaf.</li>
</ul>
<p><a class="anchor" id="section2-6"></a></p><h2>2.6 Iterations</h2>
<p><a class="anchor" id="fig8"></a></p><div class="image">
<img src="dialogbox6.png" alt="" width="88px"/>
<div class="caption">
Fig. 8: The Iterations region.</div></div>
<ul>
<li>Motion: The number of motion iterations per animation frame.</li>
<li>Collision: The number of collision iterations per motion iteration.</li>
</ul>
<p><a class="anchor" id="section2-7"></a></p><h2>2.7 Other</h2>
<p><a class="anchor" id="fig9"></a></p><div class="image">
<img src="dialogbox7.png" alt="" width="82px"/>
<div class="caption">
Fig. 9: The Other region.</div></div>
<ul>
<li>Mute: Toggle the collision sounds. You will want to check this box when there are more that a few balls in motion.</li>
<li>Rotate: Toggle rotation of the kinematic shapes.</li>
<li>Help: Show help (this page).</li>
</ul>
<p><a class="anchor" id="section2-8"></a></p><h2>2.8 Show</h2>
<p><a class="anchor" id="fig10"></a></p><div class="image">
<img src="dialogbox8.png" alt="" width="213px"/>
<div class="caption">
Fig. 10: The Show region.</div></div>
<p><a class="anchor" id="fig11"></a></p><div class="image">
<img src="show.png" alt="" width="95%"/>
<div class="caption">
Fig. 11: Show (a) Hit points and Tracks, (b) Tangents, (c) AABBs, (d) Reticles, (e) Velocity, and (f) Sectors.</div></div>
<ul>
<li>Hit points: Draw a colored dot at each point of impact of a ball with a static or kinematic shape. The dot color will be the same as the ball color. For example, <a class="el" href="#fig11">Fig. 11</a>(a) shows an orange dot where the orange ball collides with the vertical black line. The hit point dots will persist for a few seconds then fade away.</li>
<li>Tracks: Draw a track behind each ball. For example, <a class="el" href="#fig11">Fig. 11</a>(a) shows the track behind the orange ball shortly after it collides with the vertical black line. The tracks will persist for a few seconds then fade away.</li>
<li>Tangents: Draw tangents to arcs and line segments. For example, <a class="el" href="#fig11">Fig. 11</a>(b) shows tangents to two line segments and an arc.</li>
<li>AABBs: Draw AABBs for the collision shapes. For example, <a class="el" href="#fig11">Fig. 11</a>(c) shows the AABBs for two arcs and a circle. If quadtrees are active, then also draw the quadtree grid (see <a class="el" href="#section5-4">Section 5.4</a>).</li>
<li>Reticles: Draw a spinning reticle at each point of impact of a ball. The reticle color and style will vary with the type of collision and its rotation speed will vary with the collision speed. For example, <a class="el" href="#fig11">Fig. 11</a>(d) shows two reticles, the upper one in blue and magenta with the straight edges for a collision between a blue ball and a magenta ball and the lower one in magenta for a collision between the magenta ball and the black line.</li>
<li>Velocity: Draw an arrow on each ball in the direction of travel with size proportional to speed. For example, <a class="el" href="#fig11">Fig. 11</a>(e) shows arrows whose direction and size depend on the velocity of the ball that it is attached to.</li>
<li>Sectors: Draw the interior part of arc sectors. For example, <a class="el" href="#fig11">Fig. 11</a>(f) shows the interior sectors of two arcs.</li>
<li>Lights: Light up static and kinematic shapes briefly after each collision. For example, <a class="el" href="#fig12">Fig. 12</a> shows an arc (and an associated sprite) light up when hit by a ball, and <a class="el" href="#fig13">Fig. 13</a> shows a guard point light up when hit by a ball.</li>
</ul>
<p><a class="anchor" id="fig12"></a></p><div class="image">
<img src="arclit.gif" alt="" width="100px"/>
<div class="caption">
Fig. 12: Ball colliding with arc with Show Lights set.</div></div>
<p><a class="anchor" id="fig13"></a></p><div class="image">
<img src="pointlit.gif" alt="" width="100px"/>
<div class="caption">
Fig. 13: Ball colliding with point with Show Lights set.</div></div>
<p><a class="anchor" id="section2-9"></a></p><h2>2.9 Launch</h2>
<p><a class="anchor" id="fig14"></a></p><div class="image">
<img src="dialogbox9.png" alt="" width="108px"/>
<div class="caption">
Fig. 14: The Launch region.</div></div>
<ul>
<li>Launch: The launch button will launch the number of balls entered into the edit box beside it. The balls will have pseudo-random colors and a size and speed determined by the sliders in the <a class="el" href="#section2-3">Next Ball</a> region of the dialog box.</li>
</ul>
<p><a class="anchor" id="section2-10"></a></p><h2>2.10 Buttons</h2>
<p><a class="anchor" id="fig15"></a></p><div class="image">
<img src="dialogbox10.png" alt="" width="89px"/>
<div class="caption">
Fig. 15: The Buttons region.</div></div>
<ul>
<li>Clear: Delete all of the balls.</li>
<li>Quit: Exit the program.</li>
</ul>
<p><a class="anchor" id="section3"></a></p><h1>3. Building the Game</h1>
<p>This code uses <a href="../sage/index.html">SAGE</a> and the <a href="../shapes/index.html">Shapes Library</a>. Make sure that you have followed the <a href="../install/index.html">SAGE Installation Instructions</a> and the <a href="../shapes/index.html#section3">Shapes Library Build Instructions</a>. Navigate to the folder <span style="background-color:#D8E4D8;"><code>3. Collision Math Toy</code></span> in your copy of the <span style="background-color:#D8E4D8;"><code>sage-physics</code></span> repository. Run <span style="background-color:#D8E4D8;"><code>checkenv.bat</code></span> to verify that you have set the environment variables correctly. Open <span style="background-color:#D8E4D8;"><code>Collision Math Toy.sln</code></span> with Visual Studio and build the Release configuration. The Release executable file <span style="background-color:#D8E4D8;"><code>Collision Math Toy.exe</code></span> will appear. Alternatively, run <span style="background-color:#D8E4D8;"><code>Build.bat</code></span> to build both Release and Debug configurations.</p>
<p><a class="anchor" id="section4"></a></p><h1>4. Game Play</h1>
<p>Use the dialog box controls described in <a class="el" href="#section2">Section 2</a> to explore collision detection and response of dynamic circles colliding with other shapes from the <a href="../shapes/index.html">Shapes Library</a>. It is important to keep in mind that the settings in this toy can be set to values that make bad things happen, in particular, balls may escape from the play area and balls may be co-located, that is, drawn on top of one another.</p>
<p><a class="anchor" id="section5"></a></p><h1>5. Code Breakdown</h1>
<p>The most important thing in this project is to see how the code interacts with the <a href="../shapes/index.html">Shapes Library</a>. The high points of the code are the object class <code><a class="el" href="class_c_object.html" title="The game object.">CObject</a></code> covered in <a class="el" href="#section5-1">Section 5.1</a>, the object manager class <code><a class="el" href="class_c_object_manager.html" title="The object manager.">CObjectManager</a></code> covered in <a class="el" href="#section5-2">Section 5.2</a>, the gate class <code><a class="el" href="class_c_gate.html" title="A gate.">CGate</a></code> covered in <a class="el" href="#section5-3">Section 5.3</a>, and the quadtree class <code><a class="el" href="class_c_quad_tree.html" title="A quadtree.">CQuadTree</a></code> covered in <a class="el" href="#section5-4">Section 5.4</a>.</p>
<p><a class="anchor" id="section5-1"></a></p><h2>5.1 CObject</h2>
<p>Unlike the game object in <a href="../pool/class_c_object.html">The Pool End Game</a>, this game object does not have member variable <code>m_vPos</code> for its position nor does it have <code>m_vVel</code> for its velocity. Instead it has a pointer to a shapes from the <code>Shapes</code> library, </p><pre class="fragment">Shapes::CShape* m_pShape = nullptr;
</pre><p><code><a class="el" href="class_c_object.html" title="The game object.">CObject</a></code> gets the value of this pointer from its constructor. <code><a class="el" href="class_c_object.html" title="The game object.">CObject</a></code> is managed by <code><a class="el" href="class_c_object_manager.html" title="The object manager.">CObjectManager</a></code>, which is the subject of the next subsection.</p>
<p><a class="anchor" id="section5-2"></a></p><h2>5.2 CObjectManager</h2>
<p>The object manager's job is, of course, to manage the objects. The most interesting functions are <code><a class="el" href="class_c_object_manager.html#aee994b178d5774f081865796a03709f2" title="Move all objects.">CObjectManager::Move</a></code> covered in <a class="el" href="#section5-2-1">Section 5.2.1</a>, <code><a class="el" href="class_c_object_manager.html#ab0783c768fcb9e8450df530217d29802" title="Broad phase collision detection and response, brute force.">CObjectManager::BroadPhase</a></code> covered in <a class="el" href="#section5-2-2">Section 5.2.2</a>, and <code><a class="el" href="class_c_object_manager.html#a3c574bccab311aa7259137f9bcf096af" title="Narrow phase collision detection and response.">CObjectManager::NarrowPhase</a></code> covered in <a class="el" href="#section5-2-3">Section 5.2.3</a>.</p>
<p><a class="anchor" id="section5-2-1"></a></p><h3>5.2.1 CObjectManager::Move</h3>
<p><code><a class="el" href="class_c_object_manager.html#aee994b178d5774f081865796a03709f2" title="Move all objects.">CObjectManager::Move</a></code> iterates through the dynamic and kinematic shapes pointed to by its objects, calling <code>Shapes::CShape::move</code> or in most cases, the appropriate function derived from it. More correctly, <code><a class="el" href="class_c_object_manager.html#aee994b178d5774f081865796a03709f2" title="Move all objects.">CObjectManager::Move</a></code> does this in a loop <code><a class="el" href="class_c_common.html#a2f94f56ce12b22424dd206964fd1317d" title="Current number of motion iterations.">CCommon::m_nMIterations</a></code> times (the <code>M</code> stands for <em>motion</em> iterations). This value can be modifed in real time using the <a class="el" href="#section2-6">Iterations region</a> of the <a class="el" href="#section2">Controls dialog box</a>. Why would you have more than one motion iteration? It is so that the shapes move less far in each motion so that tunneling is mitigated or avoided. How is that handled in our code? When the number of iterations is changed in the dialog box, a callback function <code><a class="el" href="class_c_dialog_box.html#adae4102995724f6950028c936ff7bf13" title="Dialog box procedure.">CDialogBox::DlgProc</a></code> in <span style="background-color:#D8E4D8;"><code><a class="el" href="_dialog_box_8cpp.html" title="Code for the dialog box class CDialogBox.">DialogBox.cpp</a></code></span> changes the value of <code>Shapes::CShapeCommon::m_fTimeStep</code>. This value then gets used in <code>Shapes::CDynamicCircle::move</code> and <code>Shapes::CShape::move</code> to scale back translation and rotation, respectively.</p>
<p><a class="anchor" id="section5-2-2"></a></p><h3>5.2.2 CObjectManager::BroadPhase</h3>
<p><em>Broad phase</em> collision detection and response is a function that detects and computes responses for collisions with all game objects. Broad phase will call <em>narrow phase</em> collision detection and response, which is a function that detects and computes responses for collisions between two game objects. You might be tempted to use the following naive implementation of a broad phase collision detection and response function which calls <code>NarrowPhase</code> once for each pair of shapes in an <code>std::vector</code> of pointers to <code>CShape</code>. </p><pre class="fragment">void CObjectManager::BroadPhase(std::vector&lt;CShape*&gt; v){
  for(auto i: v) 
    for(auto j: v)
      if(i != j)
        NarrowPhase(*i, *j); 
} //BroadPhase
</pre><p><a class="anchor" id="bruteforcebroadphase"></a> We call this function <em>naive</em> because <code>NarrowPhase</code> is actually called twice for each pair of <code>CShape</code>s. Instead, we change the second <code>for</code> loop to iterate through the shapes <em>following</em> the one chosen in the first <code>for</code> loop. Let's call this <em>brute force</em> broad phase, since it calls narrow phase for each and every unordered pair of objects, even though some may be ridiculously far apart. </p><pre class="fragment">void CObjectManager::BroadPhase(std::vector&lt;CShape*&gt; v){
  for(auto i=v.begin(); i!=v.end(); i++) 
    for(auto j=next(i, 1); j!=v.end(); j++)
      NarrowPhase(*i, *j); 
} //BroadPhase
</pre><p>If there are \(n\) shapes in the parameter <code>v</code>, then the number of calls to <code>NarrowPhase</code> is:</p>
<p class="formulaDsp">
\[
\sum_{i=1}^{n - 1} \sum_{j=i+1}^n 1 = \sum_{i=1}^{n - 1} (n-i)
 = \sum_{i=1}^{n - 1} n - \sum_{i=1}^{n - 1} i
 = n(n-1) - n(n-1)/2
 = n(n-1)/2
 = \Theta (n^2).
\]
</p>
<p>You can see that we have halved the number of calls to <code>NarrowPhase</code> which is a pretty good speed-up in practice. However, \(\Theta(n^2)\) is pretty bad when you consider that there can be only \(O(n)\) collisions between \(n\) bounding spheres at any one time (see <a href="../kappa/index.html">Kissing Numbers</a>). Fortunately, there are many space partitioning data structures and algorithms that can be used to speed up broad phase collision detection. A <em>quadtree</em> (see <a class="el" href="#section5-4">Section 5.4</a>) is one of them.</p>
<p>More correctly, <code><a class="el" href="class_c_object_manager.html#ab0783c768fcb9e8450df530217d29802" title="Broad phase collision detection and response, brute force.">CObjectManager::BroadPhase</a></code> does this in a loop <code><a class="el" href="class_c_common.html#a916918bfd96d2576faa69aa561b3c868" title="Current number of collision iterations.">CCommon::m_nCIterations</a></code> times (the <code>C</code> stands for <em>collision</em> iterations). This value can be modifed in real time using the <a class="el" href="#section2-6">Iterations region</a> of the <a class="el" href="#section2">Controls dialog box</a>. The code therefore looks more similar to this: </p><pre class="fragment">void CObjectManager::BroadPhase(std::vector&lt;CShape*&gt; v){
  for(int i=0; i&lt;m_nCIterations; i++)
    for(auto i=v.begin(); i!=v.end(); i++) 
      for(auto j=next(i, 1); j!=v.end(); j++)
        NarrowPhase(*i, *j); 
} //BroadPhase
</pre><p>Notice that this means that <code><a class="el" href="class_c_object_manager.html#a3c574bccab311aa7259137f9bcf096af" title="Narrow phase collision detection and response.">CObjectManager::NarrowPhase</a></code> is called <code>m_nMIterations*m_nCIterations</code> per frame for each unordered pair of shapes (see also <a class="el" href="#section5-2-1">Section 5.2.1</a>).</p>
<p><a class="anchor" id="fig16"></a></p><div class="image">
<img src="c-iteration.png" alt="" width="17%"/>
<div class="caption">
Fig. 16: Collisions rippling through four circles that touch.</div></div>
<p>The reason for doing more than one collision iteration per frame is because collision detection and response may move a shape in such a way that it now collides with an object that it formerly didn't. For example, consider a 2D simulation of <a href="../newton/index.html">Newton's Cradle</a> with four circles numbered 1 through 4 that touch in a straight line. Suppose that circle 4 has been moved so that it overlaps circle 3, as shown in <a class="el" href="#fig16">Fig. 16</a>. Now suppose that the object manager has these shapes in ascending order, that is, Shape 1, then 2, then 3, then 4. <a class="el" href="#bruteforcebroadphase">Brute force broad phase</a> collision detection and response will call narrow phase for the following unordered pairs of circles. However, only the last one (in red) will detect a collision.</p>
<blockquote class="doxtable">
<p>&zwj;(1, 2), (1,3), (1, 4), (2, 3), (2, 4), <span style="color: red;">(3, 4)</span> </p>
</blockquote>
<p>The response will be to move circle 3 to the right where it overlaps circle 2 as shown in <a class="el" href="#fig16">Fig. 16</a>. This won't be caught until the next iteration.</p>
<blockquote class="doxtable">
<p>&zwj;(1, 2), (1,3), (1, 4), <span style="color: red;">(2, 3)</span>, (2, 4), (3, 4) </p>
</blockquote>
<p>The response will be to move circle 2 to the right where it overlaps circle 1 as shown in <a class="el" href="#fig16">Fig. 16</a>. Again, this won't be caught until the next iteration.</p>
<blockquote class="doxtable">
<p>&zwj;<span style="color: red;">(1, 2)</span>, (1,3), (1, 4), (2, 3), (2, 4), (3, 4) </p>
</blockquote>
<p>The response will be to move circle 1 to the right as shown in <a class="el" href="#fig16">Fig. 16</a>.</p>
<p>Of course, you can argue that these collisions can usually be safely postponed until the next frame, but then you risk instability. It's best to handle as many as possible in the current frame. You can also argue that it is a contrived example that would rarely come up in practice. Nonetheless, you should probably use 4 to 6 collision iterations just to be on the safe side.</p>
<p><a class="anchor" id="section5-2-3"></a></p><h3>5.2.3 CObjectManager::NarrowPhase</h3>
<p><code><a class="el" href="class_c_object_manager.html#a3c574bccab311aa7259137f9bcf096af" title="Narrow phase collision detection and response.">CObjectManager::NarrowPhase</a></code> performs narrow phase collision detection and response, and takes as parameters pointers to two shapes, the second of which is a dynamic circle <code>Shapes::CDynamicCircle</code> (since other collisions haven't been implemented yet). The necessary alterations to the simplified <a class="el" href="#bruteforcebroadphase">brute force broad phase</a> have been made in the code. A fast rejection is then performed using AABBs, <code>Shapes::CShape::CAabb2D</code>, because if shapes' AABBs don't overlap, then the shapes do not overlap. This saves us having to do any more wasted computation on this non-collision. <code><a class="el" href="class_c_object_manager.html#a3c574bccab311aa7259137f9bcf096af" title="Narrow phase collision detection and response.">CObjectManager::NarrowPhase</a></code> uses <code>Shapes::CShape::CollisionDetected</code> to fill in a contact descriptor <code>Shapes::CShape::CContactDesc</code> that is then passed to <code>Shapes::CCircle::CollisionResponse</code>, which performs collision response for both of the shapes.</p>
<p>If <code><a class="el" href="class_c_object_manager.html#a3c574bccab311aa7259137f9bcf096af" title="Narrow phase collision detection and response.">CObjectManager::NarrowPhase</a></code> detects a collision, then it is responsible for collision sounds and particles. However, since it is given as parameters only pointers to shapes in the <a href="../shapes/index.html">Shapes Library</a>, it needs a way to find out which instances of <code><a class="el" href="class_c_object.html" title="The game object.">CObject</a></code> correspond to the colliding shapes. We use the <em>user pointer</em> in <code>Shapes::CShape</code> for this purpose. <code><a class="el" href="class_c_object_manager.html#a6c230a9e32ea2869acc9d1916e490df0" title="Make a shape.">CObjectManager::MakeShape</a></code> makes a shape, given a shape descriptor and an object descriptor, creates a shape and an object. It makes the object's shape pointer <code><a class="el" href="class_c_object.html#a842acd98e83e19ae71d23390b3948916" title="Pointer to shape.">CObject::m_pShape</a></code> point to the shape, and makes the shape's user pointer point to the object by calling <code>Shapes::CShape::SetUserPtr</code>. Functions such as <code><a class="el" href="class_c_object_manager.html#a3c574bccab311aa7259137f9bcf096af" title="Narrow phase collision detection and response.">CObjectManager::NarrowPhase</a></code> that have only a pointer <code>pShape</code> to an instance of <code>Shapes::CShape</code> can get a pointer to the object that it belongs to as follows: </p><pre class="fragment">CObject* pObj = (CObject*)(pCirc-&gt;GetUserPtr());
</pre><p><code><a class="el" href="class_c_object_manager.html#a3c574bccab311aa7259137f9bcf096af" title="Narrow phase collision detection and response.">CObjectManager::NarrowPhase</a></code> uses this to, for example, change the sprite of an object involved in a collision from an unlit sprite to a lit sprite as shown in <a class="el" href="#fig12">Fig. 12</a>.</p>
<p><a class="anchor" id="section5-3"></a></p><h2>5.3 Gates</h2>
<p>A <em>gate</em> (see <a class="el" href="#fig17">Fig. 17</a>) allows balls to pass in one direction only, and are reflected back otherwise.</p>
<p><a class="anchor" id="fig17"></a></p><div class="image">
<img src="clip.png" alt=""/>
<div class="caption">
Fig. 17: The clip used to cover up the line segment used in a gate.</div></div>
<p>Gates are implemented as an instance of <code><a class="el" href="class_c_gate.html" title="A gate.">CGate</a></code>. <code><a class="el" href="class_c_gate.html" title="A gate.">CGate</a></code> has a pointer <code>m_pLineSeg</code> to an instance of <a href="../shapes/index.html#section5-8"><code>Shapes::CLineSeg</code></a> and has a function <code><a class="el" href="class_c_gate.html#ac58a5ceb4cb14d4fa6be61c914cec859" title="Narrow phase.">CGate::NarrowPhase</a></code> to do narrow-phase collision detection and response allowing balls to pass only in the direction of the normal to the line segment.</p>
<p><a class="anchor" id="section5-4"></a></p><h2>5.4 Quadtrees</h2>
<p>Quadtrees are a data structure used to speed up broad-phase collision detection and response. This section is divided into 5 subsections. <a class="el" href="#section5-4-1">Section 5.4.1</a> gives the formal definition of a quadtree as an abstract data type. <a class="el" href="#section5-4-2">Section 5.4.2</a> lists some useful facts about quadtrees. <a class="el" href="#section5-4-3">Section 5.4.3</a> describes the implementation of the quadtree abstract data type as the quadtree data structure. <a class="el" href="#section5-4-4">Section 5.4.4</a> describes how quadtrees are used for collision detection. <a class="el" href="#section5-4-5">Section 5.4.5</a> contains an analysis of the running time of broad-phase collision detection using quadtrees compared to he brute-force method.</p>
<p><a class="anchor" id="section5-4-1"></a></p><h3>5.4.1 Quadtree Definition</h3>
<p><a class="anchor" id="fig18"></a></p><div class="image">
<img src="quadtree0.png" alt="" width="50%"/>
<div class="caption">
Fig. 18: A quadtree of depth 3.</div></div>
<p>A <em>quadtree</em> is a full 4-ary tree in which each node represents an AABB covering part of the game world. That is, it is a tree in which every non-leaf node has exactly 4 children and every leaf is at exactly depth \(d\) from the root, where the <em>depth</em> of a node is the minimum number of edges that must be traversed from the node to the root. For example, <a class="el" href="#fig18">Fig. 18</a> shows the depth of the nodes at each level. The <em>depth</em> of a quadtree is the depth of its leaves, which is 3 in <a class="el" href="#fig18">Fig. 18</a>.</p>
<p><a class="anchor" id="fig19"></a></p><div class="image">
<img src="quadtree1.png" alt="" width="50%"/>
<div class="caption">
Fig. 19: A quadtree and its AABBs.</div></div>
<p>The root of a quadtree contains an AABB that contains the whole of the game world. The 4 children of a node subdivide the AABBs of their parent into 4 equal quadrants. For example, <a class="el" href="#fig19">Fig. 19</a> shows the AABBs stored at the nodes of each level of the quadtree.</p>
<p><a class="anchor" id="section5-4-2"></a></p><h3>5.4.2 Quadtree Facts</h3>
<p>The number of nodes in a quadtree of depth \(d\) is   </p><p class="formulaDsp">
\[
\sum_{i=0}^d 4^i = \frac{4^{d+1}-1}{3}.
\]
</p>
<p>For example, the number of nodes in the quadtree shown in <a class="el" href="#fig18">Fig. 18</a> is (summing by level) \(1 + 4 + 16 + 64 = 85\) and   </p><p class="formulaDsp">
\[
\sum_{i=0}^3 4^i = \frac{4^{4}-1}{3} = 255/3 = 85.
\]
</p>
<p>The number of leaves in a quadtree of depth \(d\) is \(4^d\). For example, the number of leaves in the quadtree shown in <a class="el" href="#fig18">Fig. 18</a> is \(4^3 = 64\).</p>
<p><a class="anchor" id="section5-4-3"></a></p><h3>5.4.3 Quadtree Data Structure</h3>
<p><a class="anchor" id="fig20"></a></p><div class="image">
<img src="quadtree2.png" alt="" width="50%"/>
<div class="caption">
Fig. 20: The index of each node in the quadtree array.</div></div>
<p><a class="anchor" id="fig21"></a></p><div class="image">
<img src="quadtree3.png" alt="" width="50%"/>
<div class="caption">
Fig. 21: The index of each AABB in the quadtree array.</div></div>
<p>We can store an \(n\)-node quadtree in an array \(A[n]\) as follows. The root node is stored at \(A[0]\). The children of the node in \(A[i]\) are stored in nodes \(A[4i+1]\), \(A[4i+2]\), \(A[4i+3]\), and \(A[4i+4]\). The parent of the node in \(A[i]\) is in node \(A[\lfloor (i-1)/4 \rfloor]\). <a class="el" href="#fig20">Fig. 20</a> shows the indices into \(A\) for the nodes of a depth 3, 85-node quadtree. <a class="el" href="#fig21">Fig. 21</a> shows the AABBs labeled with the indices into \(A\) for the nodes of a depth 3, 85-node quadtree.</p>
<p><a class="anchor" id="fig22"></a></p><div class="image">
<img src="quadtree4.png" alt="" width="50%"/>
<div class="caption">
Fig. 22: The children of the green node at left are the green nodes at right.</div></div>
<p>For example, since \(4 \times 18 = 72\), the children of the node at \(A[18]\) are at nodes \(A[73]\), \(A[74]\), \(A[75]\), and \(A[76]\), and since \(\lfloor 72/4\rfloor = \lfloor 73/4\rfloor = \lfloor 74/4\rfloor = \lfloor 75/4\rfloor = 18\), the parent of nodes \(A[73]\), \(A[74]\), \(A[75]\), and \(A[76]\) is in \(A[18]\) (see <a class="el" href="#fig22">Fig. 22</a>).</p>
<p>As mentioned in <a class="el" href="#section2-8">Section 2.8</a>, selecting Show AABBs from the dialog box will draw the leaf node areas of the AABB in magenta as shown in <a class="el" href="#fig23">Fig. 23</a>.</p>
<p><a class="anchor" id="fig23"></a></p><div class="image">
<img src="quadtree7.png" alt="" width="80%"/>
<div class="caption">
Fig. 23: Quadtree leaf areas for a quadtree with, from left to right, 2, 3, 4, and 5 levels.</div></div>
<p><a class="anchor" id="section5-4-4"></a></p><h3>5.4.4 Quadtrees for Collision Detection</h3>
<p><a class="anchor" id="fig24"></a></p><div class="image">
<img src="quadtree5.png" alt="" width="60%"/>
<div class="caption">
Fig. 24: Four ball bearings in a the areas covered by quadtree nodes.</div></div>
<p>Consider the areas covered by the nodes of the quadtree of depth 3 shown in <a class="el" href="#fig24">Fig. 24</a> with four colored balls drawn at their places in the game world.</p>
<ul>
<li>The depth 3 (leaf) node areas of the quadtree are shown in the bottom right rectangle of <a class="el" href="#fig24">Fig. 24</a> with indices 21&ndash;84. There are four ball bearings shown there. The red ball has its AABB completely in leaf 21, the green ball has its AABB completely in leaf 34, the yellow ball has its AABB overlap leaves 34, 45, 36, and 47, and the blue ball has its AABB completely in leaf 72.</li>
<li>The depth 2 node areas of the quadtree are shown in the bottom left rectangle of <a class="el" href="#fig24">Fig. 24</a> with indices 5&ndash;20. The red ball has its AABB completely in node 5, the green ball has its AABB completely in node 8, the yellow ball has its AABB overlap nodes 8 and 11, and the blue ball has its AABB completely in node 17.</li>
<li>The depth 1 node areas of the quadtree are shown in the top right rectangle of <a class="el" href="#fig24">Fig. 24</a> with indices 1&ndash;4. The red ball has its AABB completely in node 1, the green ball has its AABB completely in node 1, the yellow ball has its AABB overlap nodes 1 and 2, and the blue ball has its AABB completely in node 4.</li>
<li>The depth 0 node (root) area of the quadtree is shown in the top left rectangle of <a class="el" href="#fig24">Fig. 24</a> with index 0. All of the balls have their AABBs completely within node 0, as expected.</li>
</ul>
<p><a class="anchor" id="fig25"></a></p><div class="image">
<img src="quadtree6.png" alt="" width="60%"/>
<div class="caption">
Fig. 25: Four ball bearings in a quadtree.</div></div>
<p><a class="anchor" id="section5-4-5"></a></p><h3>5.4.5 Quadtrees Analysis</h3>
<p>Suppose our game world has dimensions \(N \times N\) and has \(n\) shapes in it. We begin by building the quadtree structure of depth \(\lceil \log_4 N\rceil\). This takes time \(O(N)\). On each broad phase iteration, we delete the shapes in the quadtree and reinsert them at their new positions. This takes \( \log N\) time per shape, which gives total time of \(O(n \log N)\). If there are \(m\) non-empty leaves each of which has at most \(k\) shapes in it, then each iteration of broad phase makes at most \(O(mk^2)\) calls to narrow phase. Assume that each call to narrow phase takes time \(O(1)\). The running time of broad phase is therefore \(O(m \log N + mk^2)\). If we assume that on average shapes are somewhst widely distributed, that is, \(m = \theta(n)\) and \(k = O(1)\), then   </p><p class="formulaDsp">
\[
O(m \log N + mk^2) = O(n \log N + n) = O(n \log N).
\]
</p>
<p>If we take \(N\) to be constant for the duration of gameplay and gradually increase the number of shapes \(n\) over time, then the asymptotic time complexity will be \(O(n)\), which is much better than the <a class="el" href="#bruteforcebroadphase">bruteforcebroadphase</a> brute force \(\Theta ( n^2 )\) broad phase collision detection and response algorithm. Most importantly though, is this true in practice for reasonable values of \(n\), \(N\), \(m\), and \(k\)?</p>
<p>Suppose we measure the number of AABB tests performed by the brute force method and by quadtrees. Each measurement records 60 seconds of motion, gathering data 60 times per second. The quadtree has 4 levels, and each leaf covers 60 × 44 pixels. The moving circles have a diameter of 42 pixels, so at most \(k=4\) balls can be in a leaf.</p>
<p><a class="anchor" id="fig26"></a></p><div class="image">
<img src="qtest0.png" alt="" width="50%"/>
<div class="caption">
Fig. 26: Number of intersection tests for up to 32 balls.</div></div>
<p><a class="el" href="#fig26">Fig. 26</a> shows the number of AABB intersection tests used during broad phase collision detection and response for \(2 \leq n \leq 32\) balls, with the brute force figures in red and the quadtree figures in green. Note that the quadtree method very quickly becomes more efficient than the brute force method with quadtrees winning by a factor of 5 for \(n=32\) balls.</p>
<p><a class="anchor" id="fig27"></a></p><div class="image">
<img src="qtest2.png" alt="" width="50%"/>
<div class="caption">
Fig. 27: Number of intersection tests for up to 10 balls in more detail.</div></div>
<p>Since the far left of <a class="el" href="#fig26">Fig. 26</a> is hard to read, it is reasonable to ask where the two graphs cross, that is, for which value of \(n\) does quadtrees become more efficient. <a class="el" href="#fig27">Fig. 27</a> shows the results for up to 10 balls in more detail, from which we can see that quadtrees become more efficient for 6 balls or more.</p>
<p><a class="anchor" id="fig28"></a></p><div class="image">
<img src="qtest1.png" alt="" width="50%"/>
<div class="caption">
Fig. 28: Line fitting for quadtree implementation.</div></div>
<p>We made the claim above that for reasonable values of \(N\), \(k\), and \(m\), quadtree collision detection and response runs in time \(O(n)\). <a class="el" href="#fig28">Fig. 28</a> shows the result of curve-fitting our results to a linear function using Microsoft Excel. It reports that the number of AABB intersection tests is slightly less than 3 times the number of balls with certainty \(R^2 = 0.996\), which is pretty close to linear in \(n\).</p>
<p><a class="anchor" id="section6"></a></p><h1>6. What Next?</h1>
<p>For the following problems, copy the folder <span style="background-color:#D8E4D8;"><code>3. Collision Math Toy</code></span> from your copy of the <span style="background-color:#D8E4D8;"><code>sage-physics</code></span> repository to some place convenient (for example, the Desktop or your <code>Documents</code> folder) and work there.</p>
<p><a class="anchor" id="problem1"></a></p><h2>Problem 1</h2>
<div style="padding-left: 30px;" markdown="1"> The <span style="background-color:#D8E4D8;"><code>Collision Math Toy</code></span> was designed so that there will almost always be balls in motion. The following changes will make sure that they always will eventually come to a halt. First, we give the launched balls some Z-axis friction by adding the line</div><div style="padding-left: 30px;" markdown="1"><div class="fragment"><div class="line">d.m_fFriction = 0.001f;</div>
</div><!-- fragment --> to function <code><a class="el" href="class_c_game.html#acbbc4c1ec3e3ce0cf871d9deb993a4a1" title="Create and launch a ball.">CGame::Launch()</a></code> in <code><a class="el" href="_game_8cpp.html" title="Code for the game class CGame.">Game.cpp</a></code> after the line that sets <code>d.m_fElasticity</code>. Next, in function <code><a class="el" href="class_c_object_manager.html#a1dcdb4b8172c7657d398b966381ae006" title="Create shapes for world edges.">CObjectManager::MakeWorldEdges</a></code> in <code><a class="el" href="_object_manager_8cpp.html" title="Code for the object manager class CObjectManager.">ObjectManager.cpp</a></code>, find the line</div><div style="padding-left: 30px;" markdown="1"><div class="fragment"><div class="line">arcDesc.m_fElasticity = 700.0f;</div>
</div><!-- fragment --> and change the elasticity from <code>700.0f</code> to <code>0.9f</code>. Similarly, in the line</div><div style="padding-left: 30px;" markdown="1"><div class="fragment"><div class="line">ptDesc.m_fElasticity = 1.0f;</div>
</div><!-- fragment --></div><div style="padding-left: 30px;" markdown="1">change the elasticity from <code>1.0f</code> to <code>0.9f</code>. Finally, in function <code><a class="el" href="class_c_object_manager.html#a31136d0aefd25d97932dca283f7e58a0" title="Create shapes.">CObjectManager::MakeShapes</a></code>, find the line</div><div style="padding-left: 30px;" markdown="1"><div class="fragment"><div class="line">ptDesc.m_fElasticity = 500.0f;</div>
</div><!-- fragment --></div><div style="padding-left: 30px;" markdown="1">and change the elasticity from <code>500.0f</code> to <code>0.9f</code>. Towards the end of the function you will find a line</div><div style="padding-left: 30px;" markdown="1"><div class="fragment"><div class="line">Shapes::CCircleDesc circleDesc(Vector2(0.75f*w, h/2.0f), r, 700.0);</div>
</div><!-- fragment --></div><div style="padding-left: 30px;" markdown="1">in which you must change the last parameter (elasticity) from <code>700.0f</code> to <code>0.9f</code> as follows.</div><div style="padding-left: 30px;" markdown="1"><div class="fragment"><div class="line">Shapes::CCircleDesc circleDesc(Vector2(0.75f*w, h/2.0f), r, 0.9f);</div>
</div><!-- fragment --></div><div style="padding-left: 30px;" markdown="1">Compile and run the resulting program, and launch a few balls. If you have done everthing correctly, the balls will bounce around for a few seconds and then stop. Notice that the collision detection and response numbers shown in the dialog box (AABB tests per iteration, AABB tests per second, full tests per second, and collisions per second, see <a class="el" href="#section2-4">Section 2.4</a>) remain high even though nothing can actually collide when the balls are stopped (see <a class="el" href="#section2-4">Section 2.4</a>). We will address this in the next problem. </div><p><a class="anchor" id="problem2"></a></p><h2>Problem 2</h2>
<div style="padding-left: 30px;" markdown="1"> It makes sense that balls that are stopped should go into a dormant, or <em>sleep</em> mode in which they do not participate in collision detection and response unless they collide with a dynamic object, in which case they should stop sleeping. To this end, start with your code from <a class="el" href="#problem1">Problem 1</a> and add the following private member variable to <code><a class="el" href="class_c_object.html" title="The game object.">CObject</a></code> in <code><a class="el" href="_object_8h.html" title="Interface for the game object class CObject.">Object.h</a></code>.</div><div style="padding-left: 30px;" markdown="1"><div class="fragment"><div class="line"><span class="keywordtype">bool</span> m_bSleep = <span class="keyword">false</span>;  </div>
</div><!-- fragment --> Also in <code><a class="el" href="_object_8h.html" title="Interface for the game object class CObject.">Object.h</a></code>, add the following public writer and reader functions to <code><a class="el" href="class_c_object.html" title="The game object.">CObject</a></code> to enable other entities to access the sleep flag <code>m_bSleep</code>.</div><div style="padding-left: 30px;" markdown="1"><div class="fragment"><div class="line"><span class="keywordtype">void</span> SetSleep(<span class="keyword">const</span> <span class="keywordtype">bool</span>); </div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">bool</span> GetSleep() <span class="keyword">const</span>;</div>
</div><!-- fragment --></div><div style="padding-left: 30px;" markdown="1">Add the code for these functions to <code><a class="el" href="_object_8cpp.html" title="Code for the game object class CObject.">Object.cpp</a></code> as follows.</div><div style="padding-left: 30px;" markdown="1"><div class="fragment"><div class="line"><span class="keywordtype">void</span> CObject::SetSleep(<span class="keyword">const</span> <span class="keywordtype">bool</span> b){</div>
<div class="line">  m_bSleep = b;</div>
<div class="line">} <span class="comment">//SetSleeping</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">bool</span> CObject::GetSleep()<span class="keyword"> const</span>{</div>
<div class="line">  <span class="keywordflow">return</span> m_bSleep;</div>
<div class="line">} <span class="comment">//GetSleeping</span></div>
</div><!-- fragment --></div><div style="padding-left: 30px;" markdown="1">In <code><a class="el" href="_object_manager_8cpp.html" title="Code for the object manager class CObjectManager.">ObjectManager.cpp</a></code>, add the following code to <code><a class="el" href="class_c_object_manager.html#aee994b178d5774f081865796a03709f2" title="Move all objects.">CObjectManager::Move</a></code> after the quadtree is updated and before the number of out of bounds balls is counted.</div><div style="padding-left: 30px;" markdown="1"><div class="fragment"><div class="line"><span class="keywordflow">for</span>(<span class="keyword">auto</span> <span class="keyword">const</span>&amp; p:m_stdShapes[(UINT)Shapes::eMotion::Dynamic]){</div>
<div class="line">  Shapes::CDynamicCircle* pCirc = (Shapes::CDynamicCircle*)p;</div>
<div class="line">  <a class="code hl_class" href="class_c_object.html">CObject</a>* pObj = (<a class="code hl_class" href="class_c_object.html">CObject</a>*)(p-&gt;GetUserPtr());</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">bool</span> bGoToSleep = pCirc-&gt;GetVel().LengthSquared() &lt; 0.0001f;</div>
<div class="line">  <span class="keywordflow">if</span>(bGoToSleep)pCirc-&gt;SetVel(Vector2(0.0f));</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span>(pObj != <span class="keyword">nullptr</span>){</div>
<div class="line">    <span class="keywordflow">if</span>(bGoToSleep)pObj-&gt;SetSleep(bGoToSleep);</div>
<div class="line">    pObj-&gt;<a class="code hl_variable" href="class_c_object.html#a98c0db9913a5a24553bcaefc08e3c57f">m_eUnlitSprite</a> = bGoToSleep? eSprite::Circle: eSprite::Ball;</div>
<div class="line">  } <span class="comment">//if</span></div>
<div class="line">} <span class="comment">//for</span></div>
<div class="ttc" id="aclass_c_object_html"><div class="ttname"><a href="class_c_object.html">CObject</a></div><div class="ttdoc">The game object.</div><div class="ttdef"><b>Definition</b> Object.h:33</div></div>
<div class="ttc" id="aclass_c_object_html_a98c0db9913a5a24553bcaefc08e3c57f"><div class="ttname"><a href="class_c_object.html#a98c0db9913a5a24553bcaefc08e3c57f">CObject::m_eUnlitSprite</a></div><div class="ttdeci">eSprite m_eUnlitSprite</div><div class="ttdoc">Unlit sprite.</div><div class="ttdef"><b>Definition</b> Object.h:37</div></div>
</div><!-- fragment --></div><div style="padding-left: 30px;" markdown="1">The for-loop iterates through all dynamic shapes. The first two lines of its body gets pointers to the dynamic circle the the corresponding object. The next two lines sets a local variable <code>bGoToSleep</code> to <code>true</code> iff the dynamic circle's velocity is very small, and if so, reduces the velocity to the zero vector. The if-statement is defensive programming since <code>pObj</code> will never be <code>nullptr</code> unless some far-reaching bug such as a buffer over-run makes it so. The body of the if-statement (which is always executed) sets the current objects's sleep flag if necessary, and changes its sprite from the usual <code>eSprite::Ball</code> to <code>eSprite::Circle</code> when sleeping. For example, in <a class="el" href="#fig29">Fig. 29</a> you can see ten balls, six of which are sleeping (the colored circles) and four of which are not (the green and blue ball-bearings).</div><div style="padding-left: 30px;" markdown="1"><a class="anchor" id="fig29"></a><div class="image">
<img src="sleeping.png" alt="" width="60%"/>
<div class="caption">
Fig. 29: Sleeping and non-sleeping balls.</div></div>
</div><div style="padding-left: 30px;" markdown="1">Below the for-loop you will find the following code that counts the number of out of bounds balls.</div><div style="padding-left: 30px;" markdown="1"><div class="fragment"><div class="line"><span class="keywordflow">for</span>(<span class="keyword">auto</span> <span class="keyword">const</span>&amp; p: m_stdShapes[(UINT)Shapes::eMotion::Dynamic]){ </div>
<div class="line">  <span class="keyword">const</span> Shapes::CAabb2D&amp; aabb = p-&gt;GetAABB();</div>
<div class="line">  <span class="keywordflow">if</span>(!(aabb &amp;&amp; m_cAABB))</div>
<div class="line">    ++m_nLostBalls;</div>
<div class="line">} <span class="comment">//for</span></div>
</div><!-- fragment --></div><div style="padding-left: 30px;" markdown="1">There's no need to do this for out of bounds balls that are sleeping, so replace that code with the following.</div><div style="padding-left: 30px;" markdown="1"><div class="fragment"><div class="line"><span class="keywordflow">for</span>(<span class="keyword">auto</span> <span class="keyword">const</span>&amp; p: m_stdShapes[(UINT)Shapes::eMotion::Dynamic]){ </div>
<div class="line">  <a class="code hl_class" href="class_c_object.html">CObject</a>* pObj = (<a class="code hl_class" href="class_c_object.html">CObject</a>*)(p-&gt;GetUserPtr());</div>
<div class="line">  <span class="keywordflow">if</span>(!pObj-&gt;GetSleep()){</div>
<div class="line">    <span class="keyword">const</span> Shapes::CAabb2D&amp; aabb = p-&gt;GetAABB();</div>
<div class="line">    <span class="keywordflow">if</span>(!(aabb &amp;&amp; m_cAABB))</div>
<div class="line">      ++m_nLostBalls;</div>
<div class="line">  } <span class="comment">//if</span></div>
<div class="line">} <span class="comment">//for</span></div>
</div><!-- fragment --></div><div style="padding-left: 30px;" markdown="1"><code><a class="el" href="class_c_object_manager.html#ab0783c768fcb9e8450df530217d29802" title="Broad phase collision detection and response, brute force.">CObjectManager::BroadPhase</a></code> has two nested <code>for</code>-loops, the first repeating for the number of broad-phase iterations <code>m_nCIterations</code> and the second for each dynamic shape. After the first line of the body of the nested <code>for</code>-loop declare an object pointer <code>pObj1</code> and make it point to the first object (whose shape is a dynamic circle), then declare a <code>boolean</code> variable <code>bObj1Sleep</code> and set it to <code>true</code> if that object is asleep:</div><div style="padding-left: 30px;" markdown="1"><div class="fragment"><div class="line"><a class="code hl_class" href="class_c_object.html">CObject</a>* pObj1 = (<a class="code hl_class" href="class_c_object.html">CObject</a>*)pCirc-&gt;GetUserPtr();</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">bool</span> bObj1Sleep = pObj1-&gt;GetSleep();</div>
</div><!-- fragment --></div><div style="padding-left: 30px;" markdown="1">The following lines do narrow-phase collision detection response of the dynamic circle against the gate and all static shapes.</div><div style="padding-left: 30px;" markdown="1"><div class="fragment"><div class="line">m_pGate-&gt;NarrowPhase(pCirc); </div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span>(<span class="keyword">auto</span> <span class="keyword">const</span>&amp; k: v[(UINT)Shapes::eMotion::Static]) </div>
<div class="line">  NarrowPhase(k, pCirc);</div>
</div><!-- fragment --></div><div style="padding-left: 30px;" markdown="1">The above three lines need only be executed if the object is not asleep, so enclose them in an <code>if</code>-statement as follows.</div><div style="padding-left: 30px;" markdown="1"><div class="fragment"><div class="line"><span class="keywordflow">if</span>(!bObj1Sleep){</div>
<div class="line">  m_pGate-&gt;NarrowPhase(pCirc);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span>(<span class="keyword">auto</span> <span class="keyword">const</span>&amp; k: v[(UINT)Shapes::eMotion::Static])</div>
<div class="line">    NarrowPhase(k, pCirc);</div>
<div class="line">} <span class="comment">//if</span></div>
</div><!-- fragment --> The following lines do narrow-phase collision detection response of the dynamic circle against all kinematic shapes.</div><div style="padding-left: 30px;" markdown="1"><div class="fragment"><div class="line"><span class="keywordflow">for</span>(<span class="keyword">auto</span> <span class="keyword">const</span>&amp; k: v[(UINT)Shapes::eMotion::Kinematic]) </div>
<div class="line">  NarrowPhase(k, pCirc);</div>
</div><!-- fragment --></div><div style="padding-left: 30px;" markdown="1">The above two lines need only be executed if the object is not asleep or the kinematic shapes are rotating, so enclose them in an <code>if</code>-statement as follows.</div><div style="padding-left: 30px;" markdown="1"><div class="fragment"><div class="line"><span class="keywordflow">if</span>(!bObj1Sleep || m_bRotate)</div>
<div class="line">  <span class="keywordflow">for</span>(<span class="keyword">auto</span> <span class="keyword">const</span>&amp; k: v[(UINT)Shapes::eMotion::Kinematic]) </div>
<div class="line">    NarrowPhase(k, pCirc);</div>
</div><!-- fragment --></div><div style="padding-left: 30px;" markdown="1">The following lines do narrow-phase collision detection response of the dynamic circle against all (later numbered) dynamic shapes.</div><div style="padding-left: 30px;" markdown="1"><div class="fragment"><div class="line"><span class="keywordflow">for</span>(<span class="keyword">auto</span> k=next(j); k!=dEnd; k++)</div>
<div class="line">  NarrowPhase(*k, pCirc);</div>
</div><!-- fragment --></div><div style="padding-left: 30px;" markdown="1">Replace those two lines with the following:</div><div style="padding-left: 30px;" markdown="1"><div class="fragment"><div class="line"><span class="keywordflow">for</span>(<span class="keyword">auto</span> k=next(j); k!=dEnd; k++){</div>
<div class="line">  <a class="code hl_class" href="class_c_object.html">CObject</a>* pObj2 = (<a class="code hl_class" href="class_c_object.html">CObject</a>*)(*k)-&gt;GetUserPtr();</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span>(!(bObj1Sleep &amp;&amp; pObj2-&gt;GetSleep()))</div>
<div class="line">    <span class="keywordflow">if</span>(NarrowPhase(*k, pCirc)){</div>
<div class="line">      pObj1-&gt;SetSleep(<span class="keyword">false</span>);</div>
<div class="line">      pObj2-&gt;SetSleep(<span class="keyword">false</span>);</div>
<div class="line">    } <span class="comment">//if</span></div>
<div class="line">} <span class="comment">//for</span></div>
</div><!-- fragment --> Check that you have done this correctly by launching a large number of balls (say 100) and waiting until they all come to rest. The dialog box will show that no collision tests are being done, as shown in <a class="el" href="#fig30">Fig. 30</a>.</div><div style="padding-left: 30px;" markdown="1"><a class="anchor" id="fig30"></a><div class="image">
<img src="sleeping100.png" alt="" width="50%"/>
<div class="caption">
Fig. 30: One hundred sleeping balls with no collision detection happening.</div></div>
</div><div style="padding-left: 30px;" markdown="1"></div><p><a class="anchor" id="section7"></a></p><h1>7. What Next?</h1>
<p>Next, take a look at the <a href="../pinball/index.html">Pinball Game</a>. </p>
</div></div><!-- PageDoc -->
<a href="doxygen_crawl.html"></a>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
