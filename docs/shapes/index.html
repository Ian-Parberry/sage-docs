<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The Shapes Library: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="sagedoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">The Shapes Library
   </div>
   <div id="projectbrief">Game Physics with Bespoke Code</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="contents">
<div class="textblock"><p><a class="anchor" id="section1"></a></p><h1>1. Introduction</h1>
<p>This project consists of a collection of basic shapes that can be collided. It's not intended to be a full collision module, but it will give you a sense of some of the math and physics used in collision detection and response. It's implemented as a separate project that compiles to a library file that is linked into the <a href="../collisionmath/index.html">Collision Math Toy</a> and the <a href="../pinball/index.html">Pinball Game</a>. Note that unlike the code in the <a href="../pool/index.html">Pool End Game</a>, the collision detection and response code here does not compute exact responses, but instead computes an approximation using faster methods. As a result, tunneling and overlap may occur.</p>
<p><a class="anchor" id="section2"></a></p><h1>2. Keyboard Controls</h1>
<p>This project compiles into a library, so there are no keyboard controls here.</p>
<p><a class="anchor" id="section3"></a></p><h1>3. Building the Library</h1>
<p>This code uses the DirectX12 Toolkit. Make sure that you have followed the instructions in <a href="../install/index.html#directxtk12">Section 3</a> of the <a href="../install/index.html">SAGE Installation Instructions</a>. Note that this project is independent of <a href="../sage/index.html">SAGE</a>. Navigate to the folder <span style="background-color:#D8E4D8;"><code>2. Shapes Library</code></span> in your copy of the <span style="background-color:#D8E4D8;"><code>sage-physics</code></span> repository. Run <span style="background-color:#D8E4D8;"><code>checkenv.bat</code></span> to verify that you have set the environment variables correctly. Open <span style="background-color:#D8E4D8;"><code>Shapes.sln</code></span> with Visual Studio and build the Release and Debug configurations. Alternatively, run <span style="background-color:#D8E4D8;"><code>Build.bat</code></span> to build both Release and Debug configurations.</p>
<p><a class="anchor" id="section4"></a></p><h1>4. Game Play</h1>
<p>There's no executable file to run here, remember, it just compiles into a library file. If you're interested, the library files are <span style="background-color:#D8E4D8;"><code>x64\Release\Shapes.lib</code></span> and <span style="background-color:#D8E4D8;"><code>x64\Debug\Shapes.lib</code></span>.</p>
<p><a class="anchor" id="section5"></a></p><h1>5. Code Breakdown</h1>
<p>All of the code in this library is in a namespace called <code>Shapes</code>.</p>
<p><a class="anchor" id="section5-1"></a></p><h2>5.1 Helper Functions</h2>
<p><code><a class="el" href="_shape_math_8h.html" title="Handy math functions for the collision module.">ShapeMath.h</a></code> and <code><a class="el" href="_shape_math_8cpp.html" title="Handy math functions for the collision module.">ShapeMath.cpp</a></code> contain some handy helper functions for this project. Since this project is independent of <a href="../sage/index.html">SAGE</a>, some <a href="../sage/index.html">SAGE</a> functions are duplicated here. Of particular interest is <code>FailIf</code>, which will be used inside functions in this project to test a Boolean condition and bail out from the function returning <code>false</code> if the condition is <code>true</code>. </p><pre class="fragment">#define FailIf(x) if(x)return false; 
</pre><p> This will make our code easier to read when we have multiple failure points within a function.</p>
<p><a class="anchor" id="section5-2"></a></p><h2>5.2 Axially Aligned Bounding Boxes</h2>
<p><a class="anchor" id="fig1"></a></p><div class="image">
<img src="aabb.png" alt="" width="25%"/>
<div class="caption">
Fig. 1: AABBs (green) for a circle and an arc.</div></div>
<p>An <em>axially aligned bounding box</em> (AABB for short) is a minimal-size rectanle that bounds a shape and has its edges parallel to the X and Y axes. For example, <a class="el" href="index.html#fig1">Fig. 1</a> shows the AABB for a circle and an arc. AABBs are used in narrow phase collision detection to quickly and efficiently reject things that are too far apart to collide. Our AABBs are implemented by a class <code><a class="el" href="class_shapes_1_1_c_aabb2_d.html" title="2D Axially Aligned Bounding Box.">Shapes::CAabb2D</a></code>, which has two private member variables of type <code>Vector2</code>, <code>Shapes::CAabb2D::vTopLeft</code> and <code>Shapes::CAabb2D::vBottomRt</code> which store the coordinates of its top left and bottom right corners as shown in <a class="el" href="index.html#fig2">Fig. 2</a>.</p>
<p><a class="anchor" id="fig2"></a></p><div class="image">
<img src="corners.png" alt="" width="40%"/>
<div class="caption">
Fig. 2: An AABB is defined by its top left and bottom right corners.</div></div>
<p><a class="anchor" id="section5-2-1"></a></p><h3>5.2.1 Building AABBs</h3>
<p>AABBs can be built by creating one that encloses a single point using the overloaded assignment operator <code><a class="el" href="class_shapes_1_1_c_aabb2_d.html#a32633ea446b6ac2acb2c69d0fa872b4b" title="Set AABB to point.">Shapes::CAabb2D::operator=()</a></code>, and expanding them to include a new point using <code><a class="el" href="class_shapes_1_1_c_aabb2_d.html#aa1da21e24ab7ae58b7406db9ac930b50" title="Add point to AABB.">Shapes::CAabb2D::operator+=()</a></code>.</p>
<p><a class="anchor" id="section5-2-2"></a></p><h3>5.2.2 AABB Intersection Tests</h3>
<p>There are two intersection tests involving AABBs which are implemented by overriding <code>Shapes::operator&amp;&amp;</code>. The first one returns <code>true</code> if two AABBs have non-empty intersection: <a href="_a_a_b_b_8h.html#ae71c3550e2d92b21fd23bc51c34bf4d0"><code>bool operator&amp;&amp;(const CAabb2D&amp;, const CAabb2D&amp;)</code></a>. The best way to think about this is to consider how this function fails, that is, how two AABBs don't intersect. Suppose we have two AABBs \(A\) and \(B\), and that \(A\) has top left corner \([a_l, a_t]\) and bottom right corner \([a_r,a_b]\) and \(B\) has top left corner \([b_l, b_t]\) and bottom right corner \([b_r,b_b]\). One way that \(A\) and \(B\) can be drawn without overlap is for \(A\) to be completely to the left of \(B\), as shown in <a class="el" href="index.html#fig3">Fig. 3</a>, in which case \(a_r &lt; b_l\).</p>
<p><a class="anchor" id="fig3"></a></p><div class="image">
<img src="aabbintersect.png" alt="" width="25%"/>
<div class="caption">
Fig. 3: AABB intersection test.</div></div>
<p>Similarly, \(A\) could be completely to the right of \(B\), in which case \(a_l &gt; b_r\); \(A\) could be completely above \(B\), in which case \(a_b &gt; b_t\); or \(A\) could be completely below \(B\), in which case \(a_t &lt; b_b\). These are the only ways that \(A\) can not overlap \(B\). Therefore \(A\) and \(B\) don't intersect iff  </p><p class="formulaDsp">
\[
(a_r &lt; b_l) \vee (a_l &gt; b_r) \vee (a_b &gt; b_t) \vee (a_t &lt; b_b),
\]
</p>
<p>That is, using <a href="https://en.wikipedia.org/wiki/De_Morgan%27s_laws">De Morgan's Law</a>, \(A\) and \(B\) <em>do</em> intersect iff  </p><p class="formulaDsp">
\[
(a_r \geq b_l) \wedge (a_l \leq b_r) \wedge (a_b \leq b_t) \wedge (a_t \geq b_b).
\]
</p>
<p>This AABB intersection test is therefore extremely fast, using at most four floating point comparisons and three logical operations.</p>
<p>The second AABB intersection test returns <code>true</code> if a point is inside an AABB: <a href="_a_a_b_b_8h.html#a1f0ed51adcd95498db5fe30237772fc1"><code>bool operator&amp;&amp;(const CAabb2D&amp;, const Vector2&amp;)</code></a>. Suppose the AABB has top left point \([u_x, u_y]\), bottom right point \([v_x, v_y]\), and the point to be tested for intersection with it is \(\vec{p} = [p_x, p_y]\), as shown in <a class="el" href="index.html#fig4">Fig. 4</a>.</p>
<p><a class="anchor" id="fig4"></a></p><div class="image">
<img src="ptinaabb.png" alt="" width="20%"/>
<div class="caption">
Fig. 4: Point in AABB test.</div></div>
<p>Then \(\vec{p}\) is inside the bounding box iff  </p><p class="formulaDsp">
\[
(u_x \leq p_x) \wedge (p_x \leq v_x) \wedge (v_y \leq p_y) \wedge (p_y \leq u_y)
\]
</p>
<p>The point-in-AABB intersection test is also extremely fast, using at most four floating point comparisons and three logical operations.</p>
<p><a class="anchor" id="section5-3"></a></p><h2>5.3 Shape and Motion Types</h2>
<p>The Shapes library has four main shapes: point, line segment, circle, and arc. There is also a line shape for internal use only. Shape types are identified using <code><a class="el" href="_shape_8h.html#a709ea6b747b4002fa997395a7e3cb1c7" title="Shape type.">Shapes::eShape</a></code>, defined in <code><a class="el" href="_shape_8h.html" title="Interface for CShapeDesc and CShape.">Shape.h</a></code>. It also has three motion types, static, kinematic, and dynamic.</p>
<ol type="1">
<li>Static shapes neither move nor rotate and are not affected by collisions.</li>
<li>Kinematic shapes do not move but can rotate about a static point. They are not affected by collisions.</li>
<li>Dynamic shapes (currently only circles) can move and rotate fully and are affected by collisions.</li>
</ol>
<p>Motion types are identified using <code><a class="el" href="_shape_8h.html#ab2faf0dd4a4af61cb33b9b071da938d0" title="Shape motion type.">Shapes::eMotion</a></code>, also defined in <code><a class="el" href="_shape_8h.html" title="Interface for CShapeDesc and CShape.">Shape.h</a></code>.</p>
<p><a class="anchor" id="section5-4"></a></p><h2>5.4 Basic Shapes</h2>
<p><code><a class="el" href="class_shapes_1_1_c_shape_common.html" title="The shape common variables class.">Shapes::CShapeCommon</a></code> contains values common to all shapes. <code><a class="el" href="class_shapes_1_1_c_shape_desc.html" title="Shape Descriptor.">Shapes::CShapeDesc</a></code> is a shape descriptor. <code><a class="el" href="class_shapes_1_1_c_shape.html" title="Shape.">Shapes::CShape</a></code> is the base class for all shapes, from which the static shapes <code><a class="el" href="class_shapes_1_1_c_point.html" title="Point shape.">Shapes::CPoint</a></code> (see <a class="el" href="index.html#section5-7">Section 5.7</a>), <code><a class="el" href="class_shapes_1_1_c_line_seg.html" title="Line segment shape.">Shapes::CLineSeg</a></code> (see <a class="el" href="index.html#section5-8">Section 5.8</a>), <code><a class="el" href="class_shapes_1_1_c_circle.html" title="Circle shape.">Shapes::CCircle</a></code> (see <a class="el" href="index.html#section5-9">Section 5.9</a>), and <code><a class="el" href="class_shapes_1_1_c_arc.html" title="Arc shape.">Shapes::CArc</a></code> (see <a class="el" href="index.html#section5-10">Section 5.10</a>) are derived.</p>
<p><code><a class="el" href="class_shapes_1_1_c_shape.html" title="Shape.">Shapes::CShape</a></code> has various protected member variables relating to shapes. Of particular interest are the following.</p>
<p><code><a class="el" href="class_shapes_1_1_c_shape.html#a916d222b042f78286762cbc9bcee4b4b" title="How shape moves.">Shapes::CShape::m_eMotionType</a></code>, which is initialized to <code>Shapes::eMotion::Static</code>, so that the shapes described in <a class="el" href="index.html#section5-7">Section 5.7</a> through <a class="el" href="index.html#section5-10">Section 5.10</a> will be static shapes by default. <code><a class="el" href="class_shapes_1_1_c_shape.html#a916d222b042f78286762cbc9bcee4b4b" title="How shape moves.">Shapes::CShape::m_eMotionType</a></code> will be changes to <code>Shapes::eMotion::Kinematic</code> in the constructors of kinematic shapes (see <a class="el" href="index.html#section5-11">Section 5.11</a>) and to <code>Shapes::eMotion::Dynamic</code> in the constructors of dynamic shapes (see <a class="el" href="index.html#section5-12">Section 5.12</a>).</p>
<p><code><a class="el" href="class_shapes_1_1_c_shape.html#add1bf3ea4c3ba0e5b3edda6b7d690809" title="Elasticity, aka restitution, bounciness.">Shapes::CShape::m_fElasticity</a></code> is the "bounciness" of a collision, with <code>1.0f</code> means a perfectly elastic collision, <code>0.5f</code> means a collision in which half the velocities are lost in a collision, and values greater than <code>1.0f</code> mean that a collision imparts extra velocity to the object that it collides with, perhaps by mechanical or electromechanical means, such as a bumper in a pinball machine.</p>
<p><code><a class="el" href="class_shapes_1_1_c_shape.html#abcccbf7c5af628889b57fa51e0f95ea0" title="Sensor only, no rebound on collision.">Shapes::CShape::m_bIsSensor</a></code>. If this is set to <code>true</code> then the shape does not react and does not cause any colliding object to react to a collision with it. This can be used, for example, as a switch to light up lights in a pinball machine.</p>
<p><code><a class="el" href="class_shapes_1_1_c_shape.html#adce11d64aa90975b5469aafef3cd5c3f" title="Can collide with other shapes.">Shapes::CShape::m_bCanCollide</a></code> is usually set to <code>true</code>, meaning that the shape can collide with other shapes. Setting it to <code>false</code> will temporarily turn off collisions until it is set to <code>true</code> again. This can be used, for example, for a post that sometimes retracts below the surface in a pinball machine.</p>
<p><code><a class="el" href="class_shapes_1_1_c_shape.html#ae3a7a3fd9f6898b25e201ed0c5a4088d" title="Spare pointer for user in case they might need one.">Shapes::CShape::m_pUser</a></code> is a user pointer (that is, a pointer for the use of the programmer) whose aplication will be seen in the <a href="../collisionmath/index.html">Collision Math Toy</a> and the <a href="../pinball/index.html">Pinball Machine</a>.</p>
<p><a class="anchor" id="section5-5"></a></p><h2>5.5 Collision Detection and Response</h2>
<p>Shapes that can collide with other shapes will have a <code>CollisionDetected</code> function that takes a reference to an instance of the contact descriptor <code><a class="el" href="class_shapes_1_1_c_contact_desc.html" title="Contact descriptor.">Shapes::CContactDesc</a></code> that has been initialized with a pointer to the current shape <code>m_pShape</code> and a pointer to the dynamic shape (currently only dynamic circles are implemented) <code>m_pCircle</code>. If the two shapes overlap, <code>CollisionDetected</code> will fill in the other member variables of the contact descriptor as follows and return <code>true</code>. The point of intersection (the coordinates of the point at which the shapes first collided, which is usually between frames) is computed in the 2D vector <code>m_vPOI</code>, the collision normal is computed in <code>m_vNorm</code>, the setback distance (the distance that the dynamic shape must be moved back along the collision normal to its position at the time of impact) is computed in <code>m_fSetback</code>, and the collision speed is computed in <code>m_fSpeed</code>. The main difference between collision detection and response in this project as opposed to the previous one (<a href="../pool/index.html">The 8-ball Pool End Game</a>) is that here the POI will be approximated by the closest point on the shape to the center of the dynamic circle. This is an outrageous fudge, but it looks right in practice and is faster to compute than the alternative.</p>
<p>Shape classes will have various intersection functions that detect overlap with other shapes. Dynamic shapes (the only shapes that can currently react to a collision) They will have a <code>CollisionResponse</code> function that takes as parameter a constant reference to a contact descriptor provided by some call to a <code>CollisionDetected</code> function.</p>
<p><a class="anchor" id="section5-6"></a></p><h2>5.6 Lines</h2>
<p>Infinite lines are implemented as class <code><a class="el" href="class_shapes_1_1_c_line.html" title="Line shape.">Shapes::CLine</a></code>, which is for internal use only, that is, for computations internal to the Shapes library. For this reason, <code><a class="el" href="class_shapes_1_1_c_line.html" title="Line shape.">Shapes::CLine</a></code> has no <code>CollisionDetected</code> or <code>CollisionResponse</code> functions, neither does it have any functions to do with updating any member variables, translation, or rotation. It is the only shape that does not have a descriptor and is not derived from <code><a class="el" href="class_shapes_1_1_c_shape.html" title="Shape.">Shapes::CShape</a></code>. <code><a class="el" href="class_shapes_1_1_c_line.html" title="Line shape.">Shapes::CLine</a></code> stores a gradient \(m\), inverse gradient \(1/m\), \(x\)-intercept \(c\), and \(y\)-intercept \(b\). A vertical line has gradient \(m = \infty\) (implemented as <code>float::Inf</code>), \(1/m = 0\), and \(b = \infty\). A horizontal line has gradient \(m = 0\), \(1/m = \infty\), and \(c = \infty\).</p>
<p><a class="anchor" id="section5-6-1"></a></p><h3>5.6.1 The Line Constructor</h3>
<p>The <code><a class="el" href="class_shapes_1_1_c_line.html" title="Line shape.">Shapes::CLine</a></code> constructor takes two parameters, a point \(\vec{p}\) and a floating point gradient \(m\), and initializes its member variables to represent the line of gradient \(m\) through point \(\vec{p}=[p_x, p_y]\). That is, its gradient is \(m\), its inverse gradient \(1/m\), its \(y\)-intercept is \(p_y - p_xm\), and its \(x\)-intercept is \(p_x - p_y/m\).</p>
<p><a class="anchor" id="section5-6-2"></a></p><h3>5.6.2 Point of Intersection of Two Lines</h3>
<p><code><a class="el" href="class_shapes_1_1_c_line.html#a32f494b4360d19a5db531079fdd78785" title="Get intersection point with line.">Shapes::CLine::Intersect</a></code> computes the point of intersection between two lines. If both lines have the same gradient, then there is no point of intersection and the function returns <code>Vector2(Inf, Inf)</code>. Otherwise, if neither lines are vertical, and the lines have equations \(y=m_0x + c_0\) and \(y=m_1x+c_1\) as shown in <a class="el" href="index.html#fig5">Fig. 5</a>, then the \(x\)-coordinate of the point of intersection of the lines satisfies the equation \(m_0p_x + c_0 = m_1p_x+c_1\), that is, \(p_x = (c_1 - c_0)/(m_0 - m_1)\). The \(y\)-coordinate of the point of intersection is therefore \(p_y = m_0p_x + c_0 = m_0(c_1 - c_0)/(m_0 - m_1) + c_0\).</p>
<p><a class="anchor" id="fig5"></a></p><div class="image">
<img src="lineline1.png" alt="" width="30%"/>
<div class="caption">
Fig. 5: Intersection of two nonvertical lines.</div></div>
<p>Otherwise, one of the lines is vertical and the other is not. Suppose the first line is vertical and has equation \(x = c_0\), and that the second line has equation \(y=m_1x+c_1\). Let the point of intersection \(\vec{p}\) have coordinates \([p_x, p_y]\) as shown in <a class="el" href="index.html#fig6">Fig. 6</a>.</p>
<p><a class="anchor" id="fig6"></a></p><div class="image">
<img src="lineline2.png" alt="" width="30%"/>
<div class="caption">
Fig. 6: Intersection of a line with a vertical line.</div></div>
<p>Then \(p_x = c_0\) since \(\vec{p} = [p_x, p_y]\) is on the vertical line \(x = c_0\). Therefore \(p_y = m_1 c_0 + c_1\) since \(\vec{p}\) is on the line \(y=m_1x+c_1\). The case where the second line is vertical and the first line is not vertical is similar.</p>
<p><a class="anchor" id="section5-6-2"></a></p><h3>5.6.2 Point on Line Closest to Another Point</h3>
<p><a class="anchor" id="fig7"></a></p><div class="image">
<img src="lineclosestpt0.png" alt="" width="40%"/>
<div class="caption">
Fig. 7: Gradient of perpendicular line.</div></div>
<p>Let \(\triangle ABC\) be the triangle shown in <a class="el" href="index.html#fig7">Fig. 7</a>, where \(\overline{AB}\) has equation \(y=m_0x + c_0\), where \(\overline{BC}\) has equation \(y=m_1x + c_1\), and \(\overline{AC}\) lies along the positive \(X\)-axis. Let \(\theta = \angle BAC\). Drop a line perpendicular from \(B\) down to a point \(D\) the \(X\)-axis (shown in blue in <a class="el" href="index.html#fig7">Fig. 8</a>). Then, \(\tan \theta = d_y/d_x\) (also shown in blue), that is, rise over run, and so \(m_0 = \tan \theta\). Notice that \(\angle BAC = 90^\circ - \theta\) (shown in green in <a class="el" href="index.html#fig7">Fig. 7</a>). Therefore, the angle from the positive \(X\)-axis to \(\overline{BC}\) is \(90^\circ - \theta\) (shown in red in <a class="el" href="index.html#fig7">Fig. 7</a>). Since \(\overline{AB}\) has equation \(y=m_0x + c_0\), by an argument similar to the above, \(m_1 = \tan 90^\circ + \theta\). Therefore,  </p><p class="formulaDsp">
\[
m_1 = \tan (90^\circ + \theta)
= \frac{\sin (90^\circ + \theta)}{\cos (90^\circ + \theta)}
=- \frac{\cos \theta}{\sin \theta}
=\frac{-1}{\tan \theta}
=\frac{-1}{m_0}.
\]
</p>
<p>Therefore, as shown in <a class="el" href="index.html#fig8">Fig. 8</a> the closest point on a line \(L_0\) with gradient \(m\) to a point \(\vec{p}\) can be found by computing the point of intersection of the line \(L_0\) with the line \(L_1\) with gradient \(-1/m\) through point \(p\). \(L_1\) is constructed using the <code><a class="el" href="class_shapes_1_1_c_line.html" title="Line shape.">Shapes::CLine</a></code> constructor (see <a class="el" href="index.html#section5-6-1">Section 5.6.1</a>) and its point of intersection with \(L_0\) is computed using \(L_0\)'s <code><a class="el" href="class_shapes_1_1_c_line.html#a32f494b4360d19a5db531079fdd78785" title="Get intersection point with line.">Shapes::CLine::Intersect</a></code> function (see <a class="el" href="index.html#section5-6-2">Section 5.6.2</a>).</p>
<p><a class="anchor" id="fig8"></a></p><div class="image">
<img src="lineclosestpt1.png" alt="" width="28%"/>
<div class="caption">
Fig. 8: Point on line closest to a point.</div></div>
<p><a class="anchor" id="section5-7"></a></p><h2>5.7 Points</h2>
<p>Points are implemented as class <code><a class="el" href="class_shapes_1_1_c_point.html" title="Point shape.">Shapes::CPoint</a></code>, derived from <code><a class="el" href="class_shapes_1_1_c_shape.html" title="Shape.">Shapes::CShape</a></code>. They are instantiated using the descriptor <code><a class="el" href="class_shapes_1_1_c_point_desc.html" title="Point descriptor.">Shapes::CPointDesc</a></code>. <code><a class="el" href="class_shapes_1_1_c_point.html" title="Point shape.">Shapes::CPoint</a></code> has, in addition to constructors, a collision detection function <code><a class="el" href="class_shapes_1_1_c_point.html#a7c238672005132e54bf1d4cada2db30d" title="Collision detection.">Shapes::CPoint::CollisionDetected</a></code> which, as noted in <a class="el" href="index.html#section5-5">Section 5.5</a>, takes as parameter a reference to an instance of <code><a class="el" href="class_shapes_1_1_c_contact_desc.html" title="Contact descriptor.">Shapes::CContactDesc</a></code> initialized with a pointer to a dynamic circle and fills in the POI, collision normal, and setback distance.</p>
<p><a class="anchor" id="fig9"></a></p><div class="image">
<img src="point0.png" alt="" width="40%"/>
<div class="caption">
Fig. 9: A slowly moving circle colliding with a point (left) and the POI, impact normal, and setback distance (right).</div></div>
<p>If we assume that the circle and the point are moving relatively slowly, then the point will be only a short distance in from the edge of the circle when the collision is detected, as shown in <a class="el" href="index.html#fig9">Fig. 9</a>, left. In that figure the circle (in green) has radius \(r\) and center point \(\vec{p}_1\) (blue) and it is moving at velocity \(\vec{v}\) rightwards and slightly down (purple) towards point \(\vec{p}_0\) (red). <code><a class="el" href="class_shapes_1_1_c_point.html#a7c238672005132e54bf1d4cada2db30d" title="Collision detection.">Shapes::CPoint::CollisionDetected</a></code> computes \(\vec{p} = \vec{p}_1 - \vec{p}_0\), the vector from \(\vec{p}_0\) to \(\vec{p}_1\). A collision is detected when \(||\vec{p}|| &lt; r\). The POI is taken to be the coordinates of \(\vec{p}_0\) at the time the collision is detected, the setback distance is taken to be \(r - || \vec{p} ||\), the collision normal is taken to be \(\hat{p}\), and the collision speed is \(||\vec{p}_0 ||\). These are mostly not the correct values but, as we will see later in the <a href="../collisionmath/index.html">Collision Math Toy</a> and the <a href="../pinball/index.html">Pinball Game</a>, are usually close enough.</p>
<p><a class="anchor" id="fig10"></a></p><div class="image">
<img src="point1.png" alt="" width="40%"/>
<div class="caption">
Fig. 10: Two instances of a fast moving circle colliding with a point.</div></div>
<p>However, if our assumption that the circle and the point are moving relatively slowly is incorrect, then there are a number of things that can go wrong. For example, the circle could completely travel through the point without a collision being detected (tunneling), or it could travel almost competely through the point as shown in <a class="el" href="index.html#fig10">Fig. 10</a>, left (in which case the circle will be reflected in the wrong direction), or \(\vec{p}_0\) could be very close to or equal to \(\vec{p}_1\) as shown in <a class="el" href="index.html#fig10">Fig. 10</a>, right (in which case we may get a divide-by-zero).</p>
<p><a class="anchor" id="section5-8"></a></p><h2>5.8 Line Segments</h2>
<p><a class="anchor" id="fig11"></a></p><div class="image">
<img src="lineseg.png" alt="" width="28%"/>
<div class="caption">
Fig. 11: Line segment.</div></div>
<p>Line segments are implemented as class <code><a class="el" href="class_shapes_1_1_c_line_seg.html" title="Line segment shape.">Shapes::CLineSeg</a></code>, derived from <code><a class="el" href="class_shapes_1_1_c_shape.html" title="Shape.">Shapes::CShape</a></code> and <code><a class="el" href="class_shapes_1_1_c_line.html" title="Line shape.">Shapes::CLine</a></code> (see <a class="el" href="index.html#section5-6">Section 5.6</a>). They are instantiated using the descriptor <code><a class="el" href="class_shapes_1_1_c_line_seg_desc.html" title="Line segment descriptor.">Shapes::CLineSegDesc</a></code>. <code><a class="el" href="class_shapes_1_1_c_line_seg.html" title="Line segment shape.">Shapes::CLineSeg</a></code> stores, in addition to inherited values, the coordinates of the end points \(\vec{p}_0\) and \(\vec{p}_1\), the corresponding tangent vectors \(\hat{t}_0\) and \(\hat{t}_1\), and the counterclockwise normal \(\hat{n}\) from \(\vec{p}_0\), noting that we will always enforce the condition that \(\vec{p}_0\) will always be to the left of, or at the same \(X\)-coordinate as \(\vec{p}_1\) as shown in <a class="el" href="index.html#fig11">Fig. 11</a>. Note that \(\hat{t}_0 = - \hat{t}_1\) and \(\hat{t}_0 \cdot \hat{n} = \hat{t}_1 \cdot \hat{n} = 0\).</p>
<p><code><a class="el" href="class_shapes_1_1_c_line_seg.html" title="Line segment shape.">Shapes::CLineSeg</a></code> has, in addition to constructors and reader functions, a collision detection function <code><a class="el" href="class_shapes_1_1_c_line_seg.html#aed56df99acf61d2fca2dc98b1b55cccb" title="Collision detection.">Shapes::CLineSeg::CollisionDetected</a></code> which, as noted in <a class="el" href="index.html#section5-5">Section 5.5</a>, takes as parameter a reference to an instance of <code><a class="el" href="class_shapes_1_1_c_contact_desc.html" title="Contact descriptor.">Shapes::CContactDesc</a></code> initialized with a pointer to a dynamic circle and fills in the POI, collision normal, and setback distance. <code><a class="el" href="class_shapes_1_1_c_line_seg.html#aed56df99acf61d2fca2dc98b1b55cccb" title="Collision detection.">Shapes::CLineSeg::CollisionDetected</a></code> rejects collisions with dynamic circles that approach from the ends of the line segment, that is, if the circle center is \(\vec{p}_2\), either \((\vec{p}_2 - \vec{p}_0)\cdot \hat{t}_0 &lt; 0\) or \((\vec{p}_2 - \vec{p}_1)\cdot \hat{t}_1 &lt; 0\), as shown in <a class="el" href="index.html#fig12">Fig.12</a>.</p>
<p><a class="anchor" id="fig12"></a></p><div class="image">
<img src="linesegmiss.png" alt="" width="28%"/>
<div class="caption">
Fig. 12: Rejected collisions of dynamic circle with line segment.</div></div>
<p>Otherwise \((\vec{p}_2 - \vec{p}_0)\cdot \hat{t}_0 \geq 0\) and \((\vec{p}_2 - \vec{p}_1)\cdot \hat{t}_1 \geq 0\), in which case we take the POI to be the closest point on the line segment to \(p_2\), as shown in <a class="el" href="index.html#fig13">Fig.13</a>, using a call to <code><a class="el" href="class_shapes_1_1_c_line.html#ad2fc215b58ca14a43325b197e51e4b0e" title="Get closest point on line.">Shapes::CLine::ClosestPt</a></code>. We then foist the rest of the work to <code><a class="el" href="class_shapes_1_1_c_point.html" title="Point shape.">Shapes::CPoint</a></code>, as follows. </p><pre class="fragment">return CPoint(CPointDesc(ClosestPt(p2))).CollisionDetected(c);
</pre><p> where <code>c</code> is the contact descriptor for this collision.</p>
<p><a class="anchor" id="fig13"></a></p><div class="image">
<img src="lineseghit.png" alt="" width="28%"/>
<div class="caption">
Fig. 13: Accepted collision of dynamic circle with line segment.</div></div>
<p><a class="anchor" id="section5-9"></a></p><h2>5.9 Circles</h2>
<p>Circles are implemented as class <code><a class="el" href="class_shapes_1_1_c_circle.html" title="Circle shape.">Shapes::CCircle</a></code>, derived from <code><a class="el" href="class_shapes_1_1_c_shape.html" title="Shape.">Shapes::CShape</a></code>. They are instantiated using the descriptor <code><a class="el" href="class_shapes_1_1_c_circle_desc.html" title="Circle descriptor.">Shapes::CCircleDesc</a></code>. <code><a class="el" href="class_shapes_1_1_c_circle.html" title="Circle shape.">Shapes::CCircle</a></code> stores, in addition to inherited values, its radius <code>m_fRadius</code> and the square of the radius <code>m_fRadiusSq</code>, the purpose of which will become clear in <a class="el" href="index.html#section5-9-1">Section 5.9.1</a>. It also has some useful public member functions, including <code><a class="el" href="class_shapes_1_1_c_circle.html#a6c38d58773ad3ff94b635483769b3d5a" title="Point in circle test.">Shapes::CCircle::PtInCircle</a></code> test, a <code><a class="el" href="class_shapes_1_1_c_circle.html#a8d4f1b7f446170f46a55a054daa042ee" title="Closest point on circle.">Shapes::CCircle::ClosestPt</a></code> function <code><a class="el" href="class_shapes_1_1_c_circle.html" title="Circle shape.">Shapes::CCircle</a></code> also has a collision detection function <code><a class="el" href="class_shapes_1_1_c_circle.html#ac672d4f951692521c85862be7cd1c713" title="Collision detection.">Shapes::CCircle::CollisionDetected</a></code> which, as noted in <a class="el" href="index.html#section5-5">Section 5.5</a>, takes as parameter a reference to an instance of <code><a class="el" href="class_shapes_1_1_c_contact_desc.html" title="Contact descriptor.">Shapes::CContactDesc</a></code> initialized with a pointer to a dynamic circle and fills in the POI, collision normal, and setback distance.</p>
<p><a class="anchor" id="section5-9-1"></a></p><h3>5.9.1 Point in Circle Test</h3>
<p><code><a class="el" href="class_shapes_1_1_c_circle.html#a6c38d58773ad3ff94b635483769b3d5a" title="Point in circle test.">Shapes::CCircle::PtInCircle</a></code> checks whether a point \(\vec{p}_1=[x_1, y_1]\) is inside the circle by checking whether the distance from \(\vec{p}_1\) to the center of the circle \(\vec{p}_0=[x_0,y_0]\) is less than the radius \(r\). That is, whether  </p><p class="formulaDsp">
\[
\sqrt{(x_0 - x_1)^2 + (y_0 - y_1)^2} &lt; r.
\]
</p>
<p> To save doing the potentially costly square-root, we test instead whether  </p><p class="formulaDsp">
\[
(x_0 - x_1)^2 + (y_0 - y_1)^2 &lt; r^2,
\]
</p>
<p> noting that the radius squared is computed and stored in <code>m_fRadiusSq</code> in the constructor, and that <code>DirectX::SimpleMath::Vector2</code> has a function <code>LengthSquared</code> to compute the square of its length.</p>
<p><a class="anchor" id="section5-9-2"></a></p><h3>5.9.2 Closest Point on Perimeter</h3>
<p><a class="anchor" id="fig14"></a></p><div class="image">
<img src="closestptoncirc.png" alt="" width="25%"/>
<div class="caption">
Fig. 14: Point on perimeter closest to a point.</div></div>
<p><code><a class="el" href="class_shapes_1_1_c_circle.html#a8d4f1b7f446170f46a55a054daa042ee" title="Closest point on circle.">Shapes::CCircle::ClosestPt</a></code> finds the closest point on the perimeter to the point \(\vec{p}\) as follows. Suppose the center of the circle is \(\vec{p}_0\). Compute \(\vec{n} = \vec{p}_0 - \vec{p}\), the vector from \(\vec{p}_0\) to \(\vec{p}\), and normalize it to get \(\hat{n}\). Then the point on the perimeter closest to \(\vec{p}\) is \(\vec{p}_0 + r\hat{n}\), as shown in <a class="el" href="index.html#fig14">Fig. 14</a>.</p>
<p><a class="anchor" id="section5-9-3"></a></p><h3>5.9.3 Tangents Through a Point</h3>
<p><a class="anchor" id="fig15"></a></p><div class="image">
<img src="tangent0.png" alt="" width="25%"/>
<div class="caption">
Fig. 15: Points of intersection on tangent through a point.</div></div>
<p><code><a class="el" href="class_shapes_1_1_c_circle.html#a8465052c0a6352328832c657b2f147dd" title="Tangents through external point.">Shapes::CCircle::Tangents</a>(const Vector2&amp;, Vector2&amp;, Vector2&amp;)</code> finds the intersection points \(\vec{p}_0, \vec{p}_1\) of the tangents to a circle of radius \(r\) and center \(\vec{u}\) through an exterior point \(\vec{p}\). Let \(\vec{v} = \vec{u} - \vec{p}\) be the vector from \(\vec{p}\) to \(\vec{u}\). Let \(\hat{v_0}\) be the unit vector that points along the tangent from \(\vec{p}\) to \(\vec{p}_0\) and let \(\hat{v_1}\) be the unit vector that points along the tangent from \(\vec{p}\) to \(\vec{p}_1\). This is depicted in <a class="el" href="index.html#fig15">Fig.15</a>.</p>
<p><a class="anchor" id="fig16"></a></p><div class="image">
<img src="tangent1.png" alt="" width="30%"/>
<div class="caption">
Fig. 16: First point of intersection on tangent through a point.</div></div>
<p>Consider the first of these points \(\vec{p}_0\). Consider the triangle with vertices \(\vec{p}\), \(\vec{p}_0\), and \(\vec{u}\) as shown in <a class="el" href="index.html#fig16">Fig. 16</a>. The length of the hypotenuse \(d\) is equal to the length of the vector \(\vec{v}\) from \(\vec{p}\) to \(\vec{u}\), that is, \(d = ||\vec{u} - \vec{p}||\). Let \(\delta\) be the length of the tangent through \(\vec{p}\) and \(\vec{p}_0\). Since the triangle is a right triangle, we know by the Pythagorean Theorem that \(\delta^2 + r^2 = d^2\), that is, \(\delta = d^2 - r^2\). Also since the triangle is a right triangle, the tan of the angle \(\theta\) shown in blue in <a class="el" href="index.html#fig16">Fig.16</a> is \(r/\delta\), and therefore \(\theta = \arctan (r/\delta)\). The angle between the positive \(X\)-axis and the line between \(\vec{p}\) and \(\vec{u}\) is \(\phi = \arctan(v_y/v_x)\), shown in green in <a class="el" href="index.html#fig16">Fig.16</a>. Therefore, the angle between the positive \(X\)-axis and the tangent is \(\theta + \phi\), and \(\hat{v_0} = [\cos(\theta + \phi), \sin(\theta + \phi)]\). Then to get from point \(\vec{p}\) to point \(\vec{p}_0\) we need to go a distance of \(\delta\) in the direction of \(\hat{v}_0\), that is, \(\vec{p}_0 = \vec{p} + \delta \hat{v}_0\).</p>
<p><a class="anchor" id="fig17"></a></p><div class="image">
<img src="tangent2.png" alt="" width="30%"/>
<div class="caption">
Fig. 17: Second point of intersection on tangent through a point.</div></div>
<p>The computation of the second of these points \(\vec{p}_1\) is similar to the above, except that \(\hat{v_1} = [\cos(\theta - \phi), \sin(\theta - \phi)]\), noting that in <a class="el" href="index.html#fig17">Fig. 17</a>, \(\theta\) is the positive angle between \(\vec{v}\) and \(\hat{v}_1\) and \(\phi\) is the positive angle between the \(X\)-axis and \(\hat{v}_1\).</p>
<p><a class="anchor" id="section5-9-4"></a></p><h3>5.9.4 Common Tangents</h3>
<p><a class="anchor" id="fig18"></a></p><div class="image">
<img src="commontangent.png" alt="" width="75%"/>
<div class="caption">
Fig. 18: Tangent common to two circles.</div></div>
<p><code><a class="el" href="class_shapes_1_1_c_circle.html#a8465052c0a6352328832c657b2f147dd" title="Tangents through external point.">Shapes::CCircle::Tangents</a>(const CCircle*, CLineSegDesc&amp;, CLineSegDesc&amp;)</code> computes the line segments for the tangents to two circles of radius \(r_0\) and \(r_1\), where \(r_1 &lt; r_0\), as shown in <a class="el" href="index.html#fig18">Fig. 18</a>, left. J. Casey, <em>A sequel to the First Six Books of the Elements of Euclid</em>, pp. 31-32, 1888 notes that you can shrink both circles by the same amount and maintain exactly the same tangents. As observed in <a class="el" href="index.html#fig18">Fig. 18</a>, right, you can shrink the smaller (yellow) circle down to a single point while shrinking the larger (green) circle down to radius \(r_0 - r_1\). This reduces the problem to that of finding the intersection points of the tangents of a circle through an external point, which we can solve using the method of <a class="el" href="index.html#section5-9-3">Section 5.9.3</a>.</p>
<p><a class="anchor" id="fig19"></a></p><div class="image">
<img src="commontangent2.png" alt="" width="35%"/>
<div class="caption">
Fig. 19: Intersection points of common tangents.</div></div>
<p>Suppose the points of intersection on the reduced large circle are \(\vec{p}_0, \vec{p}_1\) and its center is at position \(\vec{u}\), as shown in <a class="el" href="index.html#fig19">Fig. 19</a>. Compute \(\vec{n}_0 = \vec{p}_0 - \vec{u}\) and \(\vec{n}_1 = \vec{p}_1 - \vec{u}\) and normalize them to get \(\hat{n}_0\) and \(\hat{n}_1\). Then the points of intersection of the common tangents of the two circles are \(\vec{q}_0 = \vec{p}_0 + r_1 \hat{n}_0\) \(\vec{q}_1 = \vec{p}_1 + r_1 \hat{n}_1\) on the large circle and \(\vec{q}_2 = \vec{p} + r_1 \hat{n}_0\) \(\vec{q}_3 = \vec{p} + r_1 \hat{n}_1\), again as shown in <a class="el" href="index.html#fig19">Fig. 19</a>.</p>
<p><a class="anchor" id="section5-9-5"></a></p><h3>5.9.5 Collision Detection</h3>
<p>As we did with line segments (see <a class="el" href="index.html#section5-8">Section 5.8</a>), <code><a class="el" href="class_shapes_1_1_c_circle.html#ac672d4f951692521c85862be7cd1c713" title="Collision detection.">Shapes::CCircle::CollisionDetected</a></code> foists off the work of filling in the collision descriptor <code>c</code> to an instance of <code><a class="el" href="class_shapes_1_1_c_point.html" title="Point shape.">Shapes::CPoint</a></code> for the closest point on the dynamic circle to the center of this circle, as follows. </p><pre class="fragment">return CPoint(ClosestPt(c.m_pCircle-&gt;GetPos())).CollisionDetected(c);
</pre><p> As before, this is not the correct POI but we will see in later projects that it is close enough.</p>
<p><a class="anchor" id="section5-10"></a></p><h2>5.10 Arcs</h2>
<p>Arcs are implemented as class <code><a class="el" href="class_shapes_1_1_c_arc.html" title="Arc shape.">Shapes::CArc</a></code>, derived from <code><a class="el" href="class_shapes_1_1_c_circle.html" title="Circle shape.">Shapes::CCircle</a></code> (see <a class="el" href="index.html#section5-9">Section 5.9</a>). They are instantiated using the descriptor <code><a class="el" href="class_shapes_1_1_c_arc_desc.html" title="Arc descriptor.">Shapes::CArcDesc</a></code>.</p>
<p><a class="anchor" id="section5-10-1"></a></p><h3>5.10.1 Arc Descriptors</h3>
<p><a class="anchor" id="fig20"></a></p><div class="image">
<img src="arcdesc.png" alt="" width="35%"/>
<div class="caption">
Fig. 20: Arc angles, points, and tangents.</div></div>
<p>Arcs are defined by a pair of angles, for example, the angles \(\alpha_0\) and \(\alpha_1\) shown in <a class="el" href="index.html#fig20">Fig. 20</a>. Note that at all times we will ensure that the stored values of these angles in <code><a class="el" href="class_shapes_1_1_c_arc_desc.html" title="Arc descriptor.">Shapes::CArcDesc</a></code> and <code><a class="el" href="class_shapes_1_1_c_arc.html" title="Arc shape.">Shapes::CArc</a></code> always have the property that \(0 \leq \alpha_0, \alpha_1 &lt; 2\pi\). As shown in <a class="el" href="index.html#fig20">Fig. 20</a>, we always store the coordinates of the end points of the arc \(\vec{p}_0\) and \(\vec{p}_1\), respectively, and the tangents to the arc at those points \(\vec{t}_0\) and \(\vec{t}_1\), respectively. To facilitate consistency is maintained when we rotate an arc in <code><a class="el" href="class_shapes_1_1_c_kinematic_arc.html" title="Kinematic arc shape.">Shapes::CKinematicArc</a></code>, the angles, points, and tangents will be stored in private member variables that are updated together automatically using <code>Set</code> functions. This is not formally allowed in our definition of a <a href="../sage/index.html#sec2-2">Descriptor</a>, but as Ralph Waldo Emerson once said, "Consistency is the bugbear of tiny minds."</p>
<p><a class="anchor" id="fig21"></a></p><div class="image">
<img src="arcangles.png" alt="" width="35%"/>
<div class="caption">
Fig. 21: Angle size determines arc direction.</div></div>
<p>Note that our definition of arc so far is ambiguous: the arc could be either the smaller or larger portion of a circle. Our code will adopt the convention that the arc is that part of the perimeter of a circle that goes counterclockwise from \(\vec{p}_0\) to \(\vec{p}_1\). Therefore, flipping the arc from one portion of a circle to its complement means just swapping the angles and swapping and reversing the direction of the normals. For example, in <a class="el" href="index.html#fig21">Fig. 21</a> (left) we have the case that \(\alpha_0 &lt; \alpha_1\), while in <a class="el" href="index.html#fig21">Fig. 21</a> (right) \(\alpha_0 &gt; \alpha_1\). For convenience, we will call the former an <em>acute</em> arc and the latter an <em>obtuse</em> arc.</p>
<p><a class="anchor" id="section5-10-2"></a></p><h3>5.10.2 Arc Update</h3>
<p><a class="anchor" id="fig22"></a></p><div class="image">
<img src="arcquad.png" alt="" width="40%"/>
<div class="caption">
Fig. 22: Arc AABBs.</div></div>
<p>Function <code><a class="el" href="class_shapes_1_1_c_arc.html#acebabe19c76a51e13bb8ce59c5cae602" title="Update from angles and radius.">Shapes::CArc::Update</a></code> computes the arc's end points, tangents, and AABB from its center point and angles. The trickiest of these is the AABB. Consider the arc shown in <a class="el" href="index.html#fig22">Fig. 22</a>, left. Since none of what we will call <em>quadrant points</em>, the four points on the extreme left, right, top, and bottom of the circle containing the arc (shown in red), then the AABB of the arc (shown in green) is just the smallest AABB that contains the end points of the arc \(\vec{p}_0\) and \(\vec{p}_1\). <a class="el" href="index.html#fig22">Fig. 22</a>, right, shows three arcs that do overlap one or more of the quadrant points. Clearly, their AABBs must be the smallest AABB that includes their respective end points and whichever quadrant points lie on the arc.</p>
<p><a class="anchor" id="section5-10-3"></a></p><h3>5.10.3 Point in Sector Test</h3>
<p><a class="anchor" id="fig23"></a></p><div class="image">
<img src="arcsector.png" alt="" width="30%"/>
<div class="caption">
Fig. 23: The sector of an arc is the light gray area extending out to infinity.</div></div>
<p>Function <code><a class="el" href="class_shapes_1_1_c_arc.html#a5df47e5d99c3d84d7c34cceb3c124288" title="Point in sector test.">Shapes::CArc::PtInSector</a></code> determines whether the coordinates of a point \(\vec{p}\) lie within the sector of the arc, which depends on whether the arc is acute or obtuse (refer back to <a class="el" href="index.html#section5-10-1">Section 5.10.1</a> for definitions). It begins by finding the orientation \(\alpha\) of the vector from the center of the arc to \(\vec{p}\). Suppose the arc angles are \(\alpha_0\) and \(\alpha_1\). If \(\alpha_0 &lt; \alpha_1\), then the arc is acute and \(\vec{p}\) is within the sector of the arc iff \(\alpha_0 \leq \alpha \leq \alpha_1\) (see <a class="el" href="index.html#fig24">Fig. 24</a>).</p>
<p><a class="anchor" id="fig24"></a></p><div class="image">
<img src="arcptinsector1.png" alt="" width="15%"/>
<div class="caption">
Fig. 24: Point in sector test for acute arcs.</div></div>
<p>Otherwise, the arc is obtuse and \(\vec{p}\) is within the sector of the arc iff \(\alpha_0 \leq \alpha \) or \(\alpha \leq \alpha_1\) (see <a class="el" href="index.html#fig25">Fig. 25</a>).</p>
<p><a class="anchor" id="fig25"></a></p><div class="image">
<img src="arcptinsector2.png" alt="" width="35%"/>
<div class="caption">
Fig. 25: Point in sector test for obtuse arcs.</div></div>
<p><a class="anchor" id="section5-10-4"></a></p><h3>5.10.4 Collision Detection</h3>
<p><code><a class="el" href="class_shapes_1_1_c_arc.html#a65f524c9e4e17ec42dc6fa4f64ee2a71" title="Collision detection.">Shapes::CArc::CollisionDetected</a></code> begins by rejecting the collision if the dynamic circle comes from outside the arc sector or is inside the arc circle and is approaching in the direction opposite a tangent to the arc. This is to avoid overlap with the end of the arc as much as possible. Otherwise the POI is taken to be the point on the arc closest to the center of the dynamic circle, and the work of filling in the collision descriptor <code>c</code> is once again foisted off to an instance of <code><a class="el" href="class_shapes_1_1_c_point.html" title="Point shape.">Shapes::CPoint</a></code> for the POI. </p><pre class="fragment">return CPoint(ClosestPt(c.m_pCircle-&gt;GetPos())).CollisionDetected(c);
</pre><p> As before, this is not the correct POI but we will see in later projects that it is close enough.</p>
<p><a class="anchor" id="section5-11"></a></p><h2>5.11 Kinematic Shapes</h2>
<p>The Shapes Library includes the following kinematic shapes <code><a class="el" href="class_shapes_1_1_c_kinematic_point.html" title="Kinematic point shape.">Shapes::CKinematicPoint</a></code>, <code><a class="el" href="class_shapes_1_1_c_kinematic_line_seg.html" title="Kinematic line segment shape.">Shapes::CKinematicLineSeg</a></code>, <code><a class="el" href="class_shapes_1_1_c_kinematic_circle.html" title="Kinematic circle shape.">Shapes::CKinematicCircle</a></code>, and <code><a class="el" href="class_shapes_1_1_c_kinematic_arc.html" title="Kinematic arc shape.">Shapes::CKinematicArc</a></code>. Each kinematic shape is derived from the corresponding static shape described in <a class="el" href="index.html#section5-10">Section 5.10</a> and inherits <code><a class="el" href="class_shapes_1_1_c_shape.html#a916d222b042f78286762cbc9bcee4b4b" title="How shape moves.">Shapes::CShape::m_eMotionType</a></code> which is set to <code>Shapes::eMotion::Kinematic</code> in the constructor. Each kinematic shape has additional private member variables in which the relevant constructor stores its initial position and/or orientation at time of instantiation.</p>
<p>Every kinematic shape has a <code>Reset</code> function that resets its current position and orientation to the initial ones and a <code>Rotate</code> function that takes the coordinates of the center of rotation and an angle to be added to the initial orientation to get the current orientation. <code><a class="el" href="class_shapes_1_1_c_kinematic_point.html#a167d589a23a70a96ef4ff0ddb88260e8" title="Rotate.">Shapes::CKinematicPoint::Rotate</a></code> and <code><a class="el" href="class_shapes_1_1_c_kinematic_circle.html#adddc836b5d7c4ca3f3484c431af1e810" title="Rotate.">Shapes::CKinematicCircle::Rotate</a></code> both use a single call to <code><a class="el" href="_shape_math_8h.html#a655b44b1455600fa7b31101f5ee0109d" title="Rotate point.">Shapes::RotatePt</a></code> to rotate their positions. <code><a class="el" href="class_shapes_1_1_c_kinematic_arc.html#a9a6914c653b5c9fd5d84c628b3d304cd" title="Rotate.">Shapes::CKinematicArc::Rotate</a></code> also changes the arc angle and calls <code><a class="el" href="class_shapes_1_1_c_arc.html#acebabe19c76a51e13bb8ce59c5cae602" title="Update from angles and radius.">Shapes::CArc::Update</a></code> as the last thing. <code><a class="el" href="class_shapes_1_1_c_kinematic_line_seg.html#a3b4eff84ef24b4b78f898f44064ed967" title="Rotate.">Shapes::CKinematicLineSeg::Rotate</a></code> rotates its end points (not its position), swaps the points if they are out of order, recomputes the position and lastly calls <code><a class="el" href="class_shapes_1_1_c_line_seg.html#a9d7855e89e954f47465461997da75dee" title="Update other properties from the end points.">Shapes::CLineSeg::Update</a></code>.</p>
<p><a class="anchor" id="section5-12"></a></p><h2>5.12 Dynamic Shapes</h2>
<p>The only dynamic shapes implemented so far in the Shapes Library is <code><a class="el" href="class_shapes_1_1_c_dynamic_circle.html" title="Dynamic circle.">Shapes::CDynamicCircle</a></code>, which is derived from <code><a class="el" href="class_shapes_1_1_c_circle.html" title="Circle shape.">Shapes::CCircle</a></code> and has its own descriptor <code><a class="el" href="class_shapes_1_1_c_dynamic_circle_desc.html" title="Dynamic circle descriptor.">Shapes::CDynamicCircleDesc</a></code>. It has private member variables <code><a class="el" href="class_shapes_1_1_c_dynamic_circle.html#a7d3351f758c3ff94431ca4bc9d717fd9" title="Velocity. Speed is measured in pixels per second.">Shapes::CDynamicCircle::m_vVel</a></code> for its velocity and <code><a class="el" href="class_shapes_1_1_c_dynamic_circle.html#abc2697066e212ddeb0adadaeae524c6f" title="Mass.">Shapes::CDynamicCircle::m_fMass</a></code> for its mass. The most interesting part of <code><a class="el" href="class_shapes_1_1_c_dynamic_circle.html" title="Dynamic circle.">Shapes::CDynamicCircle</a></code> is its collision response functions. Public member function <code><a class="el" href="class_shapes_1_1_c_dynamic_circle.html#a9f0b02a5d076cd8900ef3b25e28f5ddc" title="Collision response.">Shapes::CDynamicCircle::CollisionResponse</a></code> takes as parameter a const reference to a contact descriptor that describes the collision. This is passed to private member functions <code><a class="el" href="class_shapes_1_1_c_dynamic_circle.html#a463cfe5f078bb462a1774d3acd03093f" title="Collision response for static shape.">Shapes::CDynamicCircle::CollisionResponseStatic</a></code>, <code><a class="el" href="class_shapes_1_1_c_dynamic_circle.html#a3f2e8e14c8c28cc4629a4a31ae53595b" title="Collision response for kinematic shape.">Shapes::CDynamicCircle::CollisionResponseKinematic</a></code>, or <code><a class="el" href="class_shapes_1_1_c_dynamic_circle.html#a467397512de52e424a197f49d3cd29d0" title="Collision response for dynamic shape.">Shapes::CDynamicCircle::CollisionResponseDynamic</a></code>, depending on whether the shape that this dynamic circle is colliding with is, respectively, static, kinematic, or dynamic.</p>
<p><a class="anchor" id="section5-12-1"></a></p><h3>5.12.1 Static Shape Collision Response</h3>
<p><code><a class="el" href="class_shapes_1_1_c_dynamic_circle.html#a463cfe5f078bb462a1774d3acd03093f" title="Collision response for static shape.">Shapes::CDynamicCircle::CollisionResponseStatic</a></code> computes a dynamic circle's response to collision with a static shape. The dynamic circle is moved along the contact normal by the setback distance. If the dynamic circle is moving towards to POI, then its velocity is flipped and multiplied by the product of the dynamic circle and the static shape's elasticity.</p>
<p><a class="anchor" id="section5-12-2"></a></p><h3>5.12.2 Kinematic Shape Collision Response</h3>
<p><a class="anchor" id="fig26"></a></p><div class="image">
<img src="kinematiccollide.png" alt="" width="35%"/>
<div class="caption">
Fig. 26: Kinematic circle (yellow) collides with kinematic shape.</div></div>
<p><code><a class="el" href="class_shapes_1_1_c_dynamic_circle.html#a3f2e8e14c8c28cc4629a4a31ae53595b" title="Collision response for kinematic shape.">Shapes::CDynamicCircle::CollisionResponseKinematic</a></code> computes a dynamic circle's response to collision with a kinematic shape. It first calls <code><a class="el" href="class_shapes_1_1_c_dynamic_circle.html#a463cfe5f078bb462a1774d3acd03093f" title="Collision response for static shape.">Shapes::CDynamicCircle::CollisionResponseStatic</a></code> to modify the dynamic circle's position and velocity as if the kinematic shape were static. It then gives an extra kick to the dynamic circle's velocity from the kinematic shape's rotation delivered through the POI (see <a class="el" href="index.html#fig26">Fig. 26</a>). Let \(\vec{w}\) be the vector from the kinematic shape's center of rotation to the POI and let \(\vec{w}_\perp\) be the counterclockwise perpendicular to \(\vec{w}\), computed using <code><a class="el" href="_shape_math_8h.html#a42ba6241a99c1dcd508a892de306416a" title="Perpendicular vector.">Shapes::perp</a></code>. Suppose the kinematic shape has rotation speed \(a\) rotations per second. Then the velocity of the POI at time of impact is \(2 \pi a \vec{w}_\perp\) (remembering that the length of \(\vec{w}_\perp\) is the radius of rotation). Therefore, the velocity of the POI relative to the dynamic circle is \(\vec{v}_1 = 2 \pi a \vec{w}_\perp - \vec{v}\), where \(\vec{v}\) is the velocity of the dynamic circle. Let \(\vec{v}_2\) be the component of \(\vec{v}_1\) parallel to \(\vec{u}\) the vector from the POI to the center of the dynamic circle shown in red in <a class="el" href="index.html#fig26">Fig. 26</a>. Then the product of \(\vec{v}_2\) times the elasticities of the shapes is added to the velocity \(\vec{v}\) of the dynamic circle.</p>
<p><a class="anchor" id="section5-12-3"></a></p><h3>5.12.3 Dynamic Shape Collision Response</h3>
<p><code><a class="el" href="class_shapes_1_1_c_dynamic_circle.html#a467397512de52e424a197f49d3cd29d0" title="Collision response for dynamic shape.">Shapes::CDynamicCircle::CollisionResponseDynamic</a></code> computes a dynamic circle's response to collision with a dynamic shape. The code here is similar to the response code in <a href="../pool/class_c_object_manager.html#acee7c392319024d71772e2d290a1cc7d">NarrowPhase</a> in the <a href="../pool/index.html">Pool End Game</a>, with the major change being the fact that the balls may have different masses, and so we use the formula from <a href="../newton/index.html#section2">Section 2</a> of <a href="../newton/index.html">Newtons's Cradle and Friends</a> instead of <a href="../newton/index.html#section1">Section 1</a>.</p>
<p><a class="anchor" id="section5-13"></a></p><h2>5.13 Compound Shapes</h2>
<p><code><a class="el" href="class_shapes_1_1_c_compound_shape.html" title="Compound shape.">Shapes::CCompoundShape</a></code> consists of an <code>std::vector</code> of shapes and some public functions that can be used to rotate the whole shape as if it were kinematic. This is mainly for convenience.</p>
<p><a class="anchor" id="section5-14"></a></p><h2>5.14 Naked Shapes</h2>
<p><a class="anchor" id="fig27"></a></p><div class="image">
<img src="nakedlineseg.png" alt="" width="60%"/>
<div class="caption">
Fig. 26: A naked line segment with no contact (left), a bad contact (middle) and the correct collision with a protected line segment (right).</div></div>
<p>You will notice from the above that collisions that involve a dynamic circle colliding with the ends of a line segment (<a class="el" href="index.html#section5-8">Section 5.8</a>) or arc (<a class="el" href="index.html#section5-10-4">Section 5.10.4</a>) are rejected. For example, dynamic circle collide with line segment is done by finding the closest point to the center of the circle on the line through the line segment and rejecting it if it is not on the line segment, as shown in <a class="el" href="index.html#fig27">Fig.27</a>, left. Even worse, the dynamic circle may move from there so that the POI is actually on the line segment, shown in red in <a class="el" href="index.html#fig27">Fig.27</a>, middle. The collision response for the dynamic circle will place it in the grey dotted circle with velocity away from the line segment. This usually results in a large jump in position so that the dynamic circle skims off the edge of the line segment. What we really want is for the dynamic circle to bounce off the end of the line segment, as shown in <a class="el" href="index.html#fig27">Fig.27</a>, right. For this to happen, the programmer needs to actually place an instance of <code><a class="el" href="class_shapes_1_1_c_point.html" title="Point shape.">Shapes::CPoint</a></code> there and make sure that collision detection of dynamic shapes and points is done before dynamic shapes and line segments or arcs. We will call a line segment or arc without instances of <code><a class="el" href="class_shapes_1_1_c_point.html" title="Point shape.">Shapes::CPoint</a></code> to protects its ends a <em>naked shape</em>.</p>
<p><a class="anchor" id="fig28"></a></p><div class="image">
<img src="notnaked.png" alt="" width="30%"/>
<div class="caption">
Fig. 28: A line segment (black) that shares a point with and is tangent to an arc (blue), and an incorrect guard point (red).</div></div>
<p>However, there are places in which a guard point is unnecessary and may actually give incorrect behavior. This includes arcs and line segments that are share an end point and are tangent to other arcs or line segments. For example, in <a class="el" href="index.html#fig28">Fig. 28</a>, if the red dot is an instance of <code><a class="el" href="class_shapes_1_1_c_point.html" title="Point shape.">Shapes::CPoint</a></code> then the green circle may bounce off it and recoil leftwards and down instead of rightwards and down.</p>
<p><a class="anchor" id="section6"></a></p><h1>6. What Next?</h1>
<p>Next, take a look at the <a href="../collisionmath/index.html">Collision Math Toy</a>. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7
</small></address>
</body>
</html>
