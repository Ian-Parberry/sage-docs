<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Box2D Joint Toy: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="sagedoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">Box2D Joint Toy
   </div>
   <div id="projectbrief">Game Physics with a 2D Physics Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="doc-content">
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="contents">
<div class="textblock"><p><a class="anchor" id="section1"></a></p><h1>1. Introduction</h1>
<p>The Box2D Joint Toy demonstrates some important Box2D joints, including revolute, gear, prismatic, wheel, distance, and pulley joints. It is divided into 7 levels. This code demo has no sound. The remainder of this page is divided into six sections. <a class="el" href="#section2">Section 2</a> lists the controls and their corresponding actions, <a class="el" href="#section3">Section 3</a> tells you how to build it, <a class="el" href="#section4">Section 4</a> gives you a list of actions to take in the game to see some of its important features, <a class="el" href="#section5">Section 5</a> gives a breakdown of the code, important features, <a class="el" href="#section6">Section 6</a> contains some programming problems, and <a class="el" href="#section7">Section 7</a> addresses the question "what next?".</p>
<p><a class="anchor" id="section2"></a></p><h1>2. Keyboard Controls</h1>
<center> <table class="doxtable">
<tr>
<td><center><b>Key</b></center> </td><td><center><b>Action</b></center> </td></tr>
<tr>
<td><center>F1</center> </td><td>Help (this document) </td></tr>
<tr>
<td><center>F2</center> </td><td>Toggle draw mode from "sprites only", to "sprites and lines", to "lines only" </td></tr>
<tr>
<td><center>Backspace</center> </td><td>Reset current level </td></tr>
<tr>
<td><center>Enter</center> </td><td>Advance to next level </td></tr>
<tr>
<td><center>Space</center> </td><td>Do an interesting thing (see <a class="el" href="#section4-1">Section 4.1</a> to <a class="el" href="#section4-7">Section 4.7</a>) </td></tr>
<tr>
<td><center>PrtScr (hold down)</center> </td><td>Save screenshot to a PNG file </td></tr>
<tr>
<td><center>Esc</center> </td><td>Quit game and close the window </td></tr>
</table>
</center><p><a class="anchor" id="section3"></a></p><h1>3. Building the Game</h1>
<p>This code uses <a href="../sage/index.html">SAGE</a> and <a href="https://github.com/erincatto/Box2D">Box2D</a>. Make sure that you have followed the <a href="../install/index.html">SAGE Installation Instructions</a> and the <a href="../installphysics/index.html">Box2D Installation Instructions</a>. Navigate to the folder <span style="background-color:#D8E4D8;"><code>8. Box2D Joint Toy</code></span> in your copy of the <span style="background-color:#D8E4D8;"><code>sage-physics</code></span> repository. Run <span style="background-color:#D8E4D8;"><code>checkenv.bat</code></span> to verify that you have set the environment variables correctly. Open <span style="background-color:#D8E4D8;"><code>Box2D Joint Toy.sln</code></span> with Visual Studio and build the Release configuration. Alternatively, run <span style="background-color:#D8E4D8;"><code>Build.bat</code></span> to build both Release and Debug configurations.</p>
<p><a class="anchor" id="section4"></a></p><h1>4. Game Play</h1>
<p>This toy has 7 levels. As mentioned in <a class="el" href="#section2">Section 2</a>, the <code>Enter</code> key advances to the next level and the <code>Backspace</code> key resets the current level to the initial conditions. The levels are as follows: the windmill (<a class="el" href="#section4-1">Section 4.1</a>), round and square gears (<a class="el" href="#section4-2">Section 4.2</a>), nautilus gears (<a class="el" href="#section4-3">Section 4.3</a>), rack-and-pinion (<a class="el" href="#section4-4">Section 4.4</a>), car and bridge (<a class="el" href="#section4-5">Section 4.5</a>), Newton's cradle (<a class="el" href="#section4-6">Section 4.6</a>), and elephant drop (<a class="el" href="#section4-7">Section 4.7</a>). In every level the <code>Space</code> bar does an interesting things. These are described more detail in the subsections below.</p>
<p><a class="anchor" id="section4-1"></a></p><h2>4.1 The Windmill</h2>
<p><a class="anchor" id="fig1"></a></p><div class="image">
<img src="l1.png" alt="" width="60%"/>
<div class="caption">
Fig. 1: The windmill.</div></div>
<p>A windmill with a revolute joint connecting the fan to the body. The revolute joint has a motor (see <a class="el" href="#fig1">Fig. 1</a>). The <code>Space</code> bar reverses the motor's direction of rotation. Notice that the fan takes a while to spin up to full speed, and when the direction of the motor is reversed they slowly spin down to zero before spinning up in the opposite direction. This is a property of motors in Box2D and will depend of the mass of the body being rotated.</p>
<p><a class="anchor" id="section4-2"></a></p><h2>4.2 Gears</h2>
<p><a class="anchor" id="fig2"></a></p><div class="image">
<img src="l2.png" alt="" width="60%"/>
<div class="caption">
Fig. 2: The gears.</div></div>
<p>A system of 9 interlocked gears constructed using revolute and gear joints (see <a class="el" href="#fig2">Fig. 2</a>). The largest gear has a motor and the others are driven by their gear joints. The <code>Space</code> bar reverses the motor's direction of rotation. Notice that the gears take a while to spin up to full speed, and when the direction of the motor is reversed they slowly spin down to zero before spinning up in the opposite direction. Notice also how the teeth of the gears appear to mesh. However, if you look closely you will see that they do not mesh exactly. This is because we are not computing the physics of the teeth, we are simply rotating the gears at the right speeds assuming that the sprites are drawn with teeth that mesh correctly. The 4 square gears mesh perfectly the same way that round gears do. They are cheating in a way - they require no extra code over and above what is necessary for ordinary round gears.</p>
<p><a class="anchor" id="section4-3"></a></p><h2>4.3 Nautilus Gears</h2>
<p><a class="anchor" id="fig3"></a></p><div class="image">
<img src="l3.png" alt="" width="60%"/>
<div class="caption">
Fig. 3: The nautilus gears.</div></div>
<p>A pair of <em>nautilus gears</em>, which are gears in the shape of a nautilus shell (see <a class="el" href="#fig3">Fig. 3</a>). The left gear has a revolute joint with a motor. The right gear has variable speed, so they cannot be animated by Box2D. We have to animate it ourselves which means doing a little math, which we will cover in <a class="el" href="#section5-3">Section 5.3</a>. The <code>Space</code> bar reverses the motor's direction of rotation. Notice that the gears take a while to spin up to full speed, and when the direction of the motor is reversed they slowly spin down to zero before spinning up in the opposite direction.</p>
<p><a class="anchor" id="section4-4"></a></p><h2>4.4 Rack-and-Pinion</h2>
<p><a class="anchor" id="fig4"></a></p><div class="image">
<img src="l4.png" alt="" width="60%"/>
<div class="caption">
Fig. 4: The rack-and-pinion.</div></div>
<p>A <em>rack-and-pinion</em> consists of a round gear called a <em>pinion</em> connected to a toothed rod called a <em>rack</em> (see <a class="el" href="#fig4">Fig. 4</a>). When the pinion rotates, the rack moves horizontally. The pinion has a revolute joint with a motor. The rack is connected to the pinion using a gear joint and a prismatic joint. The <code>Space</code> bar reverses the motor's direction of rotation. Notice that the pinion takes a while to spin up to full speed, and when the direction of the motor is reversed it slowly spins down to zero before spinning up in the opposite direction. Also notice the sudden stop when the pinion reaches its extreme left and right positions.</p>
<p><a class="anchor" id="section4-5"></a></p><h2>4.5 Car and Bridge</h2>
<p><a class="anchor" id="fig5"></a></p><div class="image">
<img src="l5.png" alt="" width="60%"/>
<div class="caption">
Fig. 5: The car.</div></div>
<p>A car drives autonomously back and forth over a pair of ramps (see <a class="el" href="#fig5">Fig. 5</a>). The car is constructed using a pair of wheel joints that have motors. The <code>Space</code> bar reverses the motors' directions of rotation. Notice that the car takes a while to get to full speed, and when the direction of the motors is reversed it slows down to zero before speeding up in the opposite direction. Also notice the suspension that makes the car bounce when it goes over the ramps. If you are fast with the <code>Space</code> bar you may be able to get the car stuck. If you do, reset it with the <code>Backspace</code> key.</p>
<p><a class="anchor" id="section4-6"></a></p><h2>4.6 Newton's Cradle</h2>
<p><a class="anchor" id="fig6"></a></p><div class="image">
<img src="l6.png" alt="" width="60%"/>
<div class="caption">
Fig. 6: Newton's cradle.</div></div>
<p>Distance joints are used to construct a 2D <a href="../newton/index.html">Newton's Cradle</a> with 6 balls (see <a class="el" href="#fig6">Fig. 6</a>). When the balls are stopped, hitting the <code>Space</code> bar will lift and release from 1 to 5 balls in sequence. After that it should behave like a real Newton's Cradle. <a class="el" href="#fig7">Fig. 7</a> shows a screen shot with one ball raised (left), and the result after the collision (right). <a class="el" href="#fig8">Fig. 8</a> shows a screen shot with two balls raised (left), and the result after the collision (right). When the balls are in motion, the <code>Space</code> bar stops them.</p>
<p><a class="anchor" id="fig7"></a></p><div class="image">
<img src="newton1.png" alt="" width="80%"/>
<div class="caption">
Fig. 7: Newton's cradle with 1 ball raised (left) and after collision (right).</div></div>
<p><a class="anchor" id="fig8"></a></p><div class="image">
<img src="newton2.png" alt="" width="80%"/>
<div class="caption">
Fig. 8: Newton's cradle with 2 balls raised (left) and after collision (right).</div></div>
<p><a class="anchor" id="section4-7"></a></p><h2>4.7 Elephant Drop</h2>
<p><a class="anchor" id="fig9"></a></p><div class="image">
<img src="l7.png" alt="" width="80%"/>
<div class="caption">
Fig. 9: The elephant drop before (left) and after (right) the elephant is dropped.</div></div>
<p>A pulley joint is used to lift a safe when an elephant is dropped into a wooden cradle (see <a class="el" href="#fig9">Fig. 9</a>). The pulley wheels and ropes are animated in code. When the elephant is not present, the <code>Space</code> bar makes it drop in from above. When the elephant is present, the <code>Space</code> bar makes it disappear. You can make the elephant appear and disappear at any point in the cradle's travel, not just when it is at the top or bottom. Notice that in <a class="el" href="#fig9">Fig. 9</a> (right) the cradle is not immediately below the left rim of the pulley wheel above so that the rope from the pulley to the cradle is not vertical, whereas that portion of the rope is perfectly vertical in <a class="el" href="#fig9">Fig. 9</a> (left). This is because the elephant is not dropped exactly above the center of the cradle, causing it to rock from side to side as it falls.</p>
<p><a class="anchor" id="section5"></a></p><h1>5. Code Breakdown</h1>
<p>Each of the levels has its own class, each of which is derived from <code><a class="el" href="class_c_level.html" title="Stub class for a level.">CLevel</a></code>. <code><a class="el" href="class_c_level.html" title="Stub class for a level.">CLevel</a></code> contains code and data that will be used by most of the levels. Some of its functions are stubs. A pointer to a class representing the current level is maintained in <code><a class="el" href="class_c_common.html#a6fff59625307e47fceea41221bdb1270" title="Pointer to current level.">CCommon::m_pLevel</a></code>, which is of type <code>CLevel*</code>. Many of <code><a class="el" href="class_c_level.html" title="Stub class for a level.">CLevel</a></code>'s member functions are <code>virtual</code> so that they can be overridden in any particular level class if desired. Most importantly, <code><a class="el" href="class_c_level.html" title="Stub class for a level.">CLevel</a></code> has an <code>std::vector</code> of pointers to <code><a class="el" href="class_c_object.html" title="The game object.">CObject</a></code> for you to store your objects, and function <code><a class="el" href="class_c_level.html#a3e9208196a9e58b60f70dc1da3e7da55" title="Draw objects in level.">CLevel::Draw</a></code> to draw the objects in in (although of course this may be overridden in derived classes), a function stub <code><a class="el" href="class_c_level.html#ae0da64b3cc6ab4bd9e9a046ecd4730f6" title="Perform action for level.">CLevel::Action</a></code> to perform the "interesting action" in response to the space bar (see <a class="el" href="#section2">Section 2</a>), and a function stub <code><a class="el" href="class_c_level.html#ad35cb55ec0815766f028013beed590b3" title="Destructor.">CLevel::Move</a></code> that will be used in <a class="el" href="#section5-3">Section 5.3</a>, <a class="el" href="#section5-4">Section 5.4</a>, and <a class="el" href="#section5-5">Section 5.5</a> to implement things that are not supported in Box2D. <code><a class="el" href="class_c_level.html#ad35cb55ec0815766f028013beed590b3" title="Destructor.">CLevel::Move</a></code> or a function derivde from it will be called from <code><a class="el" href="class_c_game.html#aec83638cb2fdd94ef098132eb59617d8" title="Process an animation frame.">CGame::ProcessFrame</a></code> once per animation frame.</p>
<p>The most interesting portions of the code for each of the level classes is described in the following subsections: the windmill (<a class="el" href="#section5-1">Section 5.1</a>), round and square gears (<a class="el" href="#section5-2">Section 5.2</a>), nautilus gears (<a class="el" href="#section5-3">Section 5.3</a>), rack-and-pinion (<a class="el" href="#section5-4">Section 5.4</a>), car and bridge (<a class="el" href="#section5-5">Section 5.5</a>), and Newton's cradle (<a class="el" href="#section5-6">Section 5.6</a>), and elephant drop (<a class="el" href="#section5-7">Section 5.7</a>).</p>
<p><a class="anchor" id="section5-1"></a></p><h2>5.1 The Windmill</h2>
<p>The windmill level is implemented in class <code><a class="el" href="class_c_windmill.html" title="The windmill class.">CWindmill</a></code>, which is derived from <code><a class="el" href="class_c_level.html" title="Stub class for a level.">CLevel</a></code>. The <code><a class="el" href="class_c_windmill.html" title="The windmill class.">CWindmill</a></code> constructor calls <code><a class="el" href="class_c_windmill.html#a658ebd2a0abedde6cc955dcc03a7528e" title="Create the fan.">CWindmill::CreateFan</a></code> to create an instance of <code><a class="el" href="class_c_object.html" title="The game object.">CObject</a></code> for the fan, which is drawn using the sprite shown in <a class="el" href="#fig10">Figure 10</a> (right); and calls <code><a class="el" href="class_c_windmill.html#abfa2e977d445601d55cd701f6ec1a2b4" title="Create the base.">CWindmill::CreateBase</a></code> to create an instance of <code><a class="el" href="class_c_object.html" title="The game object.">CObject</a></code> for the base, which is drawn using the sprite shown in <a class="el" href="#fig10">Figure 10</a> (left).</p>
<p><a class="anchor" id="fig10"></a></p><div class="image">
<img src="windmillspr.png" alt="" width="30%"/>
<div class="caption">
Fig. 10: The windmill sprites for the base (left), and the fan (right).</div></div>
<p><code><a class="el" href="class_c_object.html" title="The game object.">CObject</a></code> has a pointer to a Box2D body <code><a class="el" href="class_c_object.html#aeadfd2ce9573fc0c40c24b622db49287" title="Physics World body.">CObject::m_pBody</a></code> of type <code>b2Body*</code>. <code><a class="el" href="class_c_windmill.html#a658ebd2a0abedde6cc955dcc03a7528e" title="Create the fan.">CWindmill::CreateFan</a></code> declares a body definition <code>bd</code> and sets its <code>type</code> and <code>position</code> fields. It then declares an instance of <code>b2CircleShape</code> called <code>s</code> and sets its radius to half the width of the sprite in <a class="el" href="#fig10">Figure 10</a> (right), translated from Render World to Physics World coordinates. It then declares a fixture definition <code>fd</code> and sets its shape to <code>s</code> and its density somewhat arbitrarily to <code>0.1f</code>. It then creates a Physics World body for the fan by calling </p><pre class="fragment">m_pPhysicsWorld-&gt;CreateBody(&amp;bd)
</pre><p>and saving the pointer to the Box2D body returned in a local variable <code>pBody</code>. The instance of <code><a class="el" href="class_c_object.html" title="The game object.">CObject</a></code> for the fan is then created by calling </p><pre class="fragment">new CObject(eSprite::WindmillFan, pBody)
</pre><p>and pushing the pointer returned at the back of the inherited object list <code><a class="el" href="class_c_level.html#aa1afeb5070203a0694b4f2cdb38f0e5a" title="Object pointers.">CLevel::m_stdObject</a></code>. Finally, the fixture for the shape is attached to the body by calling </p><pre class="fragment">pBody-&gt;CreateFixture(&amp;fd);
</pre><p>although this could be called before the instance of <code><a class="el" href="class_c_object.html" title="The game object.">CObject</a></code> was created.</p>
<p><a class="anchor" id="fig11"></a></p><div class="image">
<img src="windmill.png" alt="" width="80%"/>
<div class="caption">
Fig. 11: The windmill level drawn with Box2D bodies in black on top of sprites (left), and bodies only (right).</div></div>
<p><code><a class="el" href="class_c_windmill.html#abfa2e977d445601d55cd701f6ec1a2b4" title="Create the base.">CWindmill::CreateBase</a></code>, on the other hand, creates an instance of <code><a class="el" href="class_c_object.html" title="The game object.">CObject</a></code> with a pointer to a Box2D body that does not have a fixture attached to it. This results in the sprite for the windmill base being drawn as in <a class="el" href="#fig11">Fig. 11</a> (left), but it does not participate in Box2D collision detection and response and is not drawn when only Box2D bodies are drawn as in <a class="el" href="#fig11">Fig. 11</a> (right). As far as Box2D is concerned, then, the world consists of two bodies, one of which is a circle and the other of which is essentially the empty body.</p>
<p>Returning to the <code><a class="el" href="class_c_windmill.html" title="The windmill class.">CWindmill</a></code> constructor, after calling <code><a class="el" href="class_c_windmill.html#a658ebd2a0abedde6cc955dcc03a7528e" title="Create the fan.">CWindmill::CreateFan</a></code> and <code><a class="el" href="class_c_windmill.html#abfa2e977d445601d55cd701f6ec1a2b4" title="Create the base.">CWindmill::CreateBase</a></code> and saving the <code>b2Body</code> pointers in local variables <code>pFan</code> and <code>pBase</code>, respectively, it declares a <em>revolute joint</em> definition <code>wd</code>. The word <em>revolute</em> is a synonym for <em>rotation</em>. A revolute joint, then, allows two bodies to rotate about a single point. If both bodies are dynamic, then the two bodies rotate freely, but in our case the body for the windmill base is given type <code>b2_staticBody</code> in <code><a class="el" href="class_c_windmill.html#abfa2e977d445601d55cd701f6ec1a2b4" title="Create the base.">CWindmill::CreateBase</a></code>, which results in the windmill fan rotating about its center in the expected way. Various fields of the revolute joint definition <code>wd</code> are filled in, including pointers to the two bodies from <code>pFan</code> and <code>pBase</code>, a motor speed and the maximum torque to be applied. Recall from <a class="el" href="#section4-1">Section 4.1</a> that the fan slowly spins up to speed. The rate at which it does so depends upon the fan's mass (which depends on its shape and density) and the motor's torque. Setting the torque ususally requires a certain amount of try-it-and-see before you arrive at an appropriate value.</p>
<p>The revolute joint is created from the description in <code>wd</code> by calling </p><pre class="fragment">m_pPhysicsWorld-&gt;CreateJoint(&amp;wd)
</pre><p>Unfortunately <code>b2World::CreateJoint</code> returns a pointer to a <code>b2Joint</code>, which is a base class from which all Box2D joints are derived. It's up to us to cast this pointer to the correct type as follows: </p><pre class="fragment">m_pJoint = (b2RevoluteJoint*)m_pPhysicsWorld-&gt;CreateJoint(&amp;wd);
</pre><p>We save this pointer in <code><a class="el" href="class_c_windmill.html#afe12248e8fa4a60525617e3f9bf2e1d2" title="Pointer to revolute joint.">CWindmill::m_pJoint</a></code> because we will need to use it in <code><a class="el" href="class_c_windmill.html#ac153ffb7094b02714d2a8c01cffee3a0" title="Reverse motor.">CWindmill::Action</a></code> to change the motor speed in response to the space bar in <code><a class="el" href="class_c_game.html#a74a75ef02b07f0f785de8aa6e7631b5d" title="The keyboard handler.">CGame::KeyboardHandler</a></code>. This is easily done as follows using <code>b2RevoluteJoint</code>'s <code>GetMotorSpeed</code> and <code>SetMotorSpeed</code> functions. </p><pre class="fragment">void CWindmill::Action(){
  m_pJoint-&gt;SetMotorSpeed(-m_pJoint-&gt;GetMotorSpeed());
} //Action
</pre><p>A little care must be taken when leaving a level to ensure that there are no memory leaks. <code><a class="el" href="class_c_level.html" title="Stub class for a level.">CLevel</a></code> has a virtual destructor <code><a class="el" href="class_c_level.html#a3b8e82b76bd3571633860e5150b2cf90" title="Default constructor.">CLevel::~CLevel</a></code> that <code>delete</code>s all of the objects in the object list <code><a class="el" href="class_c_level.html#aa1afeb5070203a0694b4f2cdb38f0e5a" title="Object pointers.">CLevel::m_stdObject</a></code>. In turn the <code><a class="el" href="class_c_object.html" title="The game object.">CObject</a></code> destructor <code><a class="el" href="class_c_object.html#a93a3c3bc7d9a6462ef00e25404d9b0eb" title="Destructor.">CObject::~CObject</a></code> calls </p><pre class="fragment">m_pPhysicsWorld-&gt;DestroyBody(m_pBody)
</pre><p>to destroy the Box2D body associated with the object. This assumes that the Box2D Physics World pointed to by <code>m_pPhysicsWorld</code> still exists. This implies that the <code><a class="el" href="class_c_game.html" title="The game class.">CGame</a></code> destructor <code><a class="el" href="class_c_game.html#a4db10c09035dc16b32d6c1ef4cca2143" title="Destructor.">CGame::~CGame</a></code> must <code>delete</code> the current level before it <code>delete</code>s Physics World. This is handled as follows. </p><pre class="fragment">CGame::~CGame(){
  delete m_pRenderer;
  delete m_pLevel;
  delete m_pPhysicsWorld;
} //destructor
</pre><p><a class="anchor" id="section5-2"></a></p><h2>5.2 Gears</h2>
<p>The Gear level is implemented in class <code><a class="el" href="class_c_gear.html" title="A system of interlocking gears.">CGear</a></code>, which is derived from <code><a class="el" href="class_c_level.html" title="Stub class for a level.">CLevel</a></code>. It may come as a surprise that if you use <code>F2</code> to draw the Physics World bodies, then you will see a collection of small non-overlapping circles as shown in <a class="el" href="#fig12">Fig. 12</a>, whereas in sprite mode you see gears of different size as shown in <a class="el" href="#fig2">Fig. 2</a> happily rotating at the right speeds.</p>
<p><a class="anchor" id="fig12"></a></p><div class="image">
<img src="gears.png" alt="" width="40%"/>
<div class="caption">
Fig. 12: The gear level drawn with Box2D bodies.</div></div>
<p>This brings us to what I call the First Law of Computer Graphics:</p>
<blockquote class="doxtable">
<p>&zwj;If it looks right, it is right. </p>
</blockquote>
<p>and also what might be called the First Corollary of Computer Animation:</p>
<blockquote class="doxtable">
<p>&zwj;The things that you see on the screen don't actually interact - they are just drawn that way. </p>
</blockquote>
<p>In this case it might <em>look</em> as if the gears mesh in such a way that the teeth of one gear pushed against the teeth of the next gear, but that really isn't so. All we need to do is make sure that the center of each gear is in the correct place, and that gears that should "contact" rotate at the correct relative speeds (and of course that the sprites have the correct number and shape of teeth for their size).</p>
<p><a class="anchor" id="fig13"></a></p><div class="image">
<img src="gear0.png" alt="" width="55%"/>
<div class="caption">
Fig. 13: The five round gears.</div></div>
<p>Consider the five round gears in <a class="el" href="#fig2">Fig. 2</a>. As seen in <a class="el" href="#fig13">Fig. 13</a>, we can number them 0 through 4. Note that gears 2 and 3 have the same diameter, but gears 0, 1, and differ from them and each other.</p>
<p><a class="anchor" id="fig14"></a></p><div class="image">
<img src="gear1.png" alt="" width="30%"/>
<div class="caption">
Fig. 14: The five round gears drawn so that they appear to mesh.</div></div>
<p>These are drawn as shown in <a class="el" href="#fig14">Fig. 14</a> positioned and oriented so that their teeth appear to mesh together. As we animated the gears we just need to make sure that they stay that way. The largest, gear 0, will have a motor, and the others will rotate at the required speeds and directions. The relative speeds of rotation are proportional to the radii of the gears involved, which can be found by counting the teeth, as in <a class="el" href="#fig15">Fig. 15</a>.</p>
<p><a class="anchor" id="fig15"></a></p><div class="image">
<img src="gear2.png" alt="" width="12%"/>
<div class="caption">
Fig. 15: A gear with 12 teeth.</div></div>
<p>The relative directions of rotation flip from one gear to the next. For example, the largest gear in <a class="el" href="#fig16">Fig. 16</a> is driven clockwise by a motor in a clockwise direction as indicated by the black arrows, while the other gears rotate in the directions indicated by the gray dotted arrows.</p>
<p><a class="anchor" id="fig16"></a></p><div class="image">
<img src="gear3.png" alt="" width="45%"/>
<div class="caption">
Fig. 16: Directions of rotation.</div></div>
<p>The code for the creation of the gears and their revolute joints is very similar to the code for the rotating fan in the Windmill level (see <a class="el" href="#section5-3">Section 5.3</a>). Pointers to the revolute joints are stored in an <code>std::vector</code> of <code>b2RevoluteJoint</code> pointers <code><a class="el" href="class_c_gear.html#ac81f2f16024ed7aa30727b5c5436b6df" title="Revolute joint pointers.">CGear::m_stdJoint</a></code> by the <code><a class="el" href="class_c_gear.html" title="A system of interlocking gears.">CGear</a></code> constructor <code><a class="el" href="class_c_gear.html#a4680074b02a91cb020dfd1ff52d7e02b" title="Constructor.">CGear::CGear</a></code>. <code><a class="el" href="class_c_gear.html#af12c96fe877fae11de927c21fe5f0507" title="Create gear joint.">CGear::CreateGearJoint</a></code> creates a gear joint that joins the revolute joints pointed to by <code>m_stdJoint[i]</code> and <code>m_stdJoint[j]</code>, with gear ratio <code>r</code>, where the unsigned integers <code>i</code>, <code>j</code>, and the floating point value <code>r</code> are parameters. It does this by declaring a gear joint definition <code>gd</code> and filling in fields for the ratio, pointers to two revolute joints, and pointers to the corresponding two Box2D bodies. The gear joint is then created by calling </p><pre class="fragment">m_pPhysicsWorld-&gt;CreateJoint(&amp;gd);
</pre><p>There is no need to save the joint pointer returned since it does not have any properties that we want to change, and it will be destroyed when the two revolute joints are destroyed.</p>
<p>Then, for example, the <code><a class="el" href="class_c_gear.html" title="A system of interlocking gears.">CGear</a></code> constructor <code><a class="el" href="class_c_gear.html#a4680074b02a91cb020dfd1ff52d7e02b" title="Constructor.">CGear::CGear</a></code> makes the four following function calls for the gear joints joining gears 0 to 1, 2 to 2, 1 to 3, and 3 to 4. The third parameter in each case the ratio of the number of teeth in the second gear to the number of teeth in the first gear, noting that gear 0 has 33 teeth, gear 1 and 4 have 18 teeth, and gears 2 and 3 have 12 teeth. </p><pre class="fragment">CreateGearJoint(0, 1, 18.0f/33.0f); 
CreateGearJoint(1, 2, 12.0f/18.0f);
CreateGearJoint(1, 3, 12.0f/18.0f);
CreateGearJoint(3, 4, 18.0f/12.0f);
</pre><p><a class="anchor" id="section5-3"></a></p><h2>5.3 Nautilus Gears</h2>
<p>The Nautilus Gear level is implemented in class <code><a class="el" href="class_c_nautilus_gear.html" title="A pair of interlocking nautilus gears.">CNautilusGear</a></code>, which is derived from <code><a class="el" href="class_c_level.html" title="Stub class for a level.">CLevel</a></code>. A <em>nautilus shell</em> is the shell from the <a href="https://en.wikipedia.org/wiki/Nautilus">cephalopod family <em>Nautilidae</em></a>. A <em>nautilus gear</em> is made from a cross-section of a nautilus shell, two of which are shown in <a class="el" href="#fig17">Fig. 17</a>. The cross-section consists of a series of cells of increasing size that spiral out from a center point. In <a class="el" href="#fig17">Fig. 17</a> the left-hand shell rotates about that point with constant angular velocity, while the right-hand shell rotates around its central point with angular velocity that increases and decreases over time so that the teeth appear to mesh. Remember that our task here is not to compute how the teeth mesh, but merely to draw the right-hand gear at an orientation that makes appear that it meshes with the left-hand gear.</p>
<p><a class="anchor" id="fig17"></a></p><div class="image">
<img src="Nautilus2-342-96.gif" alt="" width="25%"/>
<div class="caption">
Fig. 17: Animation of two nautilus gears.</div></div>
<p>Since Box2D does not directly support nautilus gears, <code><a class="el" href="class_c_nautilus_gear.html" title="A pair of interlocking nautilus gears.">CNautilusGear</a></code> will override <code><a class="el" href="class_c_level.html#ad35cb55ec0815766f028013beed590b3" title="Destructor.">CLevel::Move</a></code> with a function <code><a class="el" href="class_c_nautilus_gear.html#ab6280edc601ff8ca4fa98045970c95e9" title="Move gears in synchrony.">CNautilusGear::Move</a></code> that computes the orientation of the second gear from the orientation of the first gear. Recall that this function will be called once per animation frame from <code><a class="el" href="class_c_game.html#aec83638cb2fdd94ef098132eb59617d8" title="Process an animation frame.">CGame::ProcessFrame</a></code>. Up until now, the function call <code>m_pLevel-&gt;Move()</code> in <code><a class="el" href="class_c_game.html#aec83638cb2fdd94ef098132eb59617d8" title="Process an animation frame.">CGame::ProcessFrame</a></code> defaults to <code><a class="el" href="class_c_level.html#ad35cb55ec0815766f028013beed590b3" title="Destructor.">CLevel::Move</a></code>, which does nothing. Before we write code for <code><a class="el" href="class_c_nautilus_gear.html#ab6280edc601ff8ca4fa98045970c95e9" title="Move gears in synchrony.">CNautilusGear::Move</a></code> we will need to derive some mathematics about nautilus gears. Suppose we have a nautilus gear of maximum radius \(a\) and minimum radius \(b\), as shown in <a class="el" href="#fig18">Fig. 18</a> (left). The radius of a nautilus gear at angle \(\theta\) measured counterclockwise from the positive \(x\)-axis (see <a class="el" href="#fig18">Fig. 18</a>, right) is \(ce^{d\theta}\) for some constants \(c, d\) that depend on the particular nautilus shell in question and \(e \approx 2.71828\) is the base of the natural logarithm. Since the radius at angle zero is \(b\), \(b = ce^0\), that is, \(c = b\). Since the radius at angle \(2 \pi\) is \(a\), \(a = be^{2 d\pi}\). That is, taking the natural logarithm of both sides, \(d = \ln (a/b)/2 \pi\). Examining our nautilus gear sprite in an image editor, we find that \(a=98\) and \(b=34\) pixels.</p>
<p><a class="anchor" id="fig18"></a></p><div class="image">
<img src="nautilus1.png" alt="" width="40%"/>
<div class="caption">
Fig. 18: Nautilus gear equation.</div></div>
<p>We thus begin our code for <code><a class="el" href="class_c_nautilus_gear.html#ab6280edc601ff8ca4fa98045970c95e9" title="Move gears in synchrony.">CNautilusGear::Move</a></code> with \(\theta_0\), \(a\), \(b\), and \(d\). Variable <code>theta0</code> holds \(\theta_0\), which is the opposite of the gear's orientation (from the gear's perspective, when it rotates through angle \(\theta\) it is as if the world has rotated through angle \(-\theta\)). <code><a class="el" href="class_c_nautilus_gear.html" title="A pair of interlocking nautilus gears.">CNautilusGear</a></code> has constant member variables for \(a, b, d\). </p><pre class="fragment">const float a = 98.0f; 
const float b = 34.0f; 
const float d = 0.5f*logf(a/b)/b2_pi; 
</pre><p>Since the fixed distance between the gear centers is \(a+b\) (<a class="el" href="#fig19">Fig. 19</a>, left), and \(be^{d\theta_0} + be^{d\theta_1}\) (<a class="el" href="#fig19">Fig. 19</a>, right), we can deduce that:</p>
<p class="formulaDsp">
\[
be^{d\theta_0} + be^{d\theta_1} = a+b
\]
</p>
<p>which implies that, dividing both sides by \(b\) then subtracting \(e^{d\theta_1}\) from both sides:   </p><p class="formulaDsp">
\[
e^{d\theta_1} = a/b+1 - e^{d\theta_0}
\]
</p>
<p> and so, taking the natural logarithm of both sides and dividing by \(d\),   </p><p class="formulaDsp">
\[
\theta_1 = \ln(a/b + 1 - e^{d\theta_0})/d.
\]
</p>
<p><a class="anchor" id="fig19"></a></p><div class="image">
<img src="nautilus2.png" alt="" width="55%"/>
<div class="caption">
Fig. 19: Two nautilus gears.</div></div>
<p>Since the right-hand gear starts out at an orientation of \(\pi\), its orientation is now \(\pi - \theta_1\). The code for <code><a class="el" href="class_c_nautilus_gear.html#ab6280edc601ff8ca4fa98045970c95e9" title="Move gears in synchrony.">CNautilusGear::Move</a></code> is then: </p><pre class="fragment">void CNautilusGear::Move(){
  float theta0 = -m_stdObject[0]-&gt;GetBody()-&gt;GetAngle(); //left gear angle
  const float b2_2pi = 2.0f*b2_pi; //2 times pi in Physics World
  theta0 -= (UINT)floor(theta0/b2_2pi)*b2_2pi; //normalize theta0 to be in [0, 2pi]
  const float theta1 = logf(a/b + 1.0f - expf(d*theta0))/d; //angle for right gear

  b2Body* pBody = m_stdObject[1]-&gt;GetBody(); //body of right gear
  pBody-&gt;SetTransform(pBody-&gt;GetPosition(), b2_pi - theta1); //orient right gear
} //Move
</pre><p>The <code><a class="el" href="class_c_nautilus_gear.html" title="A pair of interlocking nautilus gears.">CNautilusGear</a></code> constructor <code><a class="el" href="class_c_nautilus_gear.html#a066707102a77b81c84a59f1b347f8bea" title="Constructor.">CNautilusGear::CNautilusGear</a></code> calls <code><a class="el" href="class_c_nautilus_gear.html#a553e402655a93ca0e97f2049ebaaa124" title="Create gear.">CNautilusGear::CreateGear</a></code> once for each gear to create it in the correct position and orientationas shown in <a class="el" href="#fig19">Fig. 19</a>, left. It then creates a revolute joint that connects the left gear to a null background, and enables its motor. This is similar to the <code><a class="el" href="class_c_gear.html" title="A system of interlocking gears.">CGear</a></code> constructor <code><a class="el" href="class_c_gear.html#a4680074b02a91cb020dfd1ff52d7e02b" title="Constructor.">CGear::CGear</a></code> we saw in <a class="el" href="#section5-3">Section 5.3</a> except that it does not connect the nautilus gears with a Box2D gear joint. If <code><a class="el" href="class_c_nautilus_gear.html#ab6280edc601ff8ca4fa98045970c95e9" title="Move gears in synchrony.">CNautilusGear::Move</a></code> were not called from <code><a class="el" href="class_c_game.html#aec83638cb2fdd94ef098132eb59617d8" title="Process an animation frame.">CGame::ProcessFrame</a></code> (for example, if you comment out the call to <code>m_pLevel-&gt;Move()</code>), then the left gear would rotate but the right gear would not.</p>
<p><a class="anchor" id="section5-4"></a></p><h2>5.4 Rack-and-Pinion</h2>
<p>The Rack-and-Pinion level is implemented in class <code><a class="el" href="class_c_rack_and_pinion.html" title="Rack and pinion.">CRackAndPinion</a></code>, which is derived from <code><a class="el" href="class_c_level.html" title="Stub class for a level.">CLevel</a></code>. Its constructor <code><a class="el" href="class_c_rack_and_pinion.html#a346dfdb09744ba73d63dc277d0a3388b" title="Constructor.">CRackAndPinion::CRackAndPinion</a></code> calls <code><a class="el" href="class_c_rack_and_pinion.html#a673da4ccf8fa50593aee90037e4a1130" title="Create a rack.">CRackAndPinion::CreateRack</a></code> to create the rack (the horizontal part of <a class="el" href="#fig22">Fig. 22</a>), <code><a class="el" href="class_c_rack_and_pinion.html#a4a62a9bf8a4d92d9e2a6239d372b8fa7" title="Create a pinion.">CRackAndPinion::CreatePinion</a></code> to create the pinion, (the round gear in <a class="el" href="#fig22">Fig. 22</a>) and <code><a class="el" href="class_c_rack_and_pinion.html#a9ac42881d53ab12e1bf2d37761a4faaf" title="Create an invisible gantry.">CRackAndPinion::CreateBase</a></code> to create a null physics body for the background. It also creates a revolute joint for the pinion and stores a pointer to it in <code><a class="el" href="class_c_rack_and_pinion.html#a9bcabbe10db998bdccb0293d0c0dd3f6" title="Pointer to revolute joint for pinion.">CRackAndPinion::m_pRevoluteJoint</a></code>.</p>
<p><a class="anchor" id="fig22"></a></p><div class="image">
<img src="rackandpinion.gif" alt="" width="50%"/>
<div class="caption">
Fig. 22: The rack-and-pinion.</div></div>
<p>The horizontal motion of the rack is constrained by a <em>prismatic joint</em> that lets you set the direction of motion and the limits of travel. First we create a prismatic joint definition </p><pre class="fragment">b2PrismaticJointDef pjd;
</pre><p>A call to </p><pre class="fragment">pjd.Initialize(pBase, pRack, pRack-&gt;GetPosition(), b2Vec2(1.0f, 0.0f));
</pre><p>specifies pointers to the base body <code>pBase</code> and the rack <code>pRack</code>, the rack's initial position <code>pRack-&gt;GetPosition()</code>, and the unit direction vector pointing the positive X direction. Note that here and elsewhere it is important to create Box2D bodies in their initial positions and orientations, in contrast to graphics objects that can be creates at the origin and translated/rotated to their initial places. We then specify an upper and lower translation limit and enable limits. </p><pre class="fragment">pjd.lowerTranslation = -m_fLimit;
pjd.upperTranslation = m_fLimit;
pjd.enableLimit = true;
</pre><p>We can then create and save the prismatic joint. </p><pre class="fragment">m_pPrismaticJoint = (b2PrismaticJoint*)m_pPhysicsWorld-&gt;CreateJoint(&amp;pjd);
</pre><p>A gear joint is used in order for the rack to move in synchrony with the pinion. W saw gear joints being used to connect revolute joints in <code>\ref section5-2 "Section 5.2". Here a gear joint will be used to connect a revolute joint (for the pinion) with a prismatic joint (for the rack) using the pointers</code><a class="el" href="class_c_rack_and_pinion.html#a9bcabbe10db998bdccb0293d0c0dd3f6" title="Pointer to revolute joint for pinion.">CRackAndPinion::m_pRevoluteJoint</a><code>and</code><a class="el" href="class_c_rack_and_pinion.html#aaf008c36db230f4d052ac05780115b4a" title="Pointer to prismatic joint for rack.">CRackAndPinion::m_pPrismaticJoint</a>` created above. To do this we create a gear joint definition </p><pre class="fragment">b2GearJointDef gd;
</pre><p>set its ratio field to \(\pi\) divided by half the width of the rack sprite </p><pre class="fragment">gd.ratio = b2_pi/w2;
</pre><p>where we define </p><pre class="fragment">const float w = m_pRenderer-&gt;GetWidth(eSprite::Rack);
const float w2 = RW2PW(w)/2.0f;
</pre><p>and set its joint pointers </p><pre class="fragment">gd.joint1 = m_pRevoluteJoint;
gd.joint2 = m_pPrismaticJoint;
</pre><p>and provide pointers to the respective physics bodies </p><pre class="fragment">gd.bodyA = pPinion;
gd.bodyB = pRack;
</pre><p>We then go ahead and create the gear joint with a call to </p><pre class="fragment">m_pPhysicsWorld-&gt;CreateJoint(&amp;gd);
</pre><p>There is no need to save the joint pointer so we don't.</p>
<p>Recall again that the pinion does not actually engage with and move the rack: the Box2D joints merely coordinate the position of the rack with the orientation of the pinion. The teeth are not present in the Box2D representation of the rack and pinion as shown in <a class="el" href="#fig23">Fig. 23</a>. It is up to us to create sprites with the teeth in the right places to create the illusion of a rack and pinion.</p>
<p><a class="anchor" id="fig23"></a></p><div class="image">
<img src="shape-rack.png" alt="" width="40%"/>
<div class="caption">
Fig. 23: The Rack-and-Pinion shapes.</div></div>
<p><code><a class="el" href="class_c_rack_and_pinion.html#a0534b3d24a380b386adb75dc4a15d849" title="Reverse the motor.">CRackAndPinion::Action</a></code> is called from the keyboard handler in response to the space bar, overriding the default <code><a class="el" href="class_c_level.html#ae0da64b3cc6ab4bd9e9a046ecd4730f6" title="Perform action for level.">CLevel::Action</a></code>. It merely reverses the direction of motion of the motor on the revolute joint by negating its motor speed. </p><pre class="fragment">void CRackAndPinion::Action(){
  m_pRevoluteJoint-&gt;SetMotorSpeed(-m_pRevoluteJoint-&gt;GetMotorSpeed());
} //Action
</pre><p>Although the prismatic joint's limits will prevent the rack from sliding too far to the left or right, we will need to add code to reverse the motor when either limit is reached. <code><a class="el" href="class_c_rack_and_pinion.html#a9dc1202d3762d7b2bc45602891779ebd" title="Reverse the rack when it hits the limits.">CRackAndPinion::Move</a></code> is the perfect place to do this. It compares the prismatic joint position from <code>m_pPrismaticJoint-&gt;GetJointTranslation()</code> and the sign of the motor speed with the corresponding limit and negates the motor speed when the limit is reached.</p>
<p><a class="anchor" id="section5-5"></a></p><h2>5.5 Car and Bridge</h2>
<p>The Car and Bridge level is implemented in class <code><a class="el" href="class_c_car_and_bridge.html" title="A car consisting of a body and two wheels, and a bridge to run on.">CCarAndBridge</a></code>, which is derived from <code><a class="el" href="class_c_level.html" title="Stub class for a level.">CLevel</a></code>. Most of what you see in the screenshot shown in <a class="el" href="#fig5">Fig. 5</a> is baked into the background image shown in <a class="el" href="#fig24">Fig. 24</a>. The actual shapes in Box2D are shown in <a class="el" href="#fig25">Fig. 25</a>.</p>
<p><a class="anchor" id="fig24"></a></p><div class="image">
<img src="carbg.png" alt="" width="50%"/>
<div class="caption">
Fig. 24: Background image for the Car and Bridge.</div></div>
<p><a class="anchor" id="fig25"></a></p><div class="image">
<img src="shape-car.png" alt="" width="40%"/>
<div class="caption">
Fig. 25: The Car and Bridge shapes.</div></div>
<p>Much of the code for <code><a class="el" href="class_c_car_and_bridge.html" title="A car consisting of a body and two wheels, and a bridge to run on.">CCarAndBridge</a></code> is similar to the code that we have seen in previous levels, including the use of <code><a class="el" href="class_c_car_and_bridge.html#a298554acbf281bfb4c82149c4b74d9ba" title="Reverse the car when it gets near the edges.">CCarAndBridge::Move</a></code> to reverse the car wheel motors when it nears the edge of the window. However, the wheels are not connected to the rest of the car using revolute joints. Instead we use <em>wheel joints</em> that allow the wheels to both rotate and move up and down as shown in <a class="el" href="#fig26">Fig. 26</a>.</p>
<p><a class="anchor" id="fig26"></a></p><div class="image">
<img src="car.png" alt="" width="25%"/>
<div class="caption">
Fig. 26: Degrees of freedom for the car and its wheels.</div></div>
<p>This is done by creating an instance of <code>b2WheelJointDef</code>, setting and enabling its various motor-related fields, together with spring damping and stiffness values for the vertical motion. Finally, its <code>collideConnected</code> field is set to <code>false</code> so that Box2D will not respond to collisions between the wheels and the car body.</p>
<p><a class="anchor" id="section5-6"></a></p><h2>5.6 Newton's Cradle</h2>
<p>The Newton's Cradle level is implemented in class <code><a class="el" href="class_c_newtons_cradle.html" title="Newton&#39;s cradle.">CNewtonsCradle</a></code>, which is derived from <code><a class="el" href="class_c_level.html" title="Stub class for a level.">CLevel</a></code>. Its constructor <code><a class="el" href="class_c_newtons_cradle.html#ab4a77b11ccf02a52d39c1eec6f220746" title="Constructor.">CNewtonsCradle::CNewtonsCradle</a></code> calls <code><a class="el" href="class_c_newtons_cradle.html#ade953fca77863053020e04bd783ff0d7" title="Create all balls.">CNewtonsCradle::Create</a></code> to create the balls and their joints. <a class="el" href="#fig27">Fig 27</a> shows that each ball has a circle shape (compare to <a class="el" href="#fig6">Fig. 6</a>). <code><a class="el" href="class_c_newtons_cradle.html#ade953fca77863053020e04bd783ff0d7" title="Create all balls.">CNewtonsCradle::Create</a></code> calls <code><a class="el" href="class_c_newtons_cradle.html#a80a13f008f7dfea273b2117f99f67e67" title="Create a ball.">CNewtonsCradle::CreateBall</a></code> once for each ball in a <code>for</code>-loop, then calls <code><a class="el" href="class_c_newtons_cradle.html#a54d759a52886d0067d37ed5dc4d0d697" title="Create the cradle.">CNewtonsCradle::CreateCradle</a></code> to create the empty background. Finally <code><a class="el" href="class_c_newtons_cradle.html#ade953fca77863053020e04bd783ff0d7" title="Create all balls.">CNewtonsCradle::Create</a></code> creates the lines for the strings joining the balls to the cradle by calling <code><a class="el" href="class_c_level.html#afc270743065b1f4bfd48d8f8567aded6" title="Create new line object.">CLevel::CreateLine</a></code> once for each ball, then creates a <em>distance joint</em> by filling in an instance of <code>b2DistanceJointDef</code> with the positions of the ends of the strings and calling <code>m_pPhysicsWorld-&gt;CreateJoint</code> for each ball.</p>
<p><a class="anchor" id="fig27"></a></p><div class="image">
<img src="shape-newton.png" alt="" width="40%"/>
<div class="caption">
Fig. 27: The Newton's Cradle shapes.</div></div>
<p><code><a class="el" href="class_c_newtons_cradle.html#a7defc695cf5a90c521f6cad9b4e4c918" title="Reset all balls to initial conditions.">CNewtonsCradle::ResetBalls</a></code> resets the balls to their initial positions with zero velocity. It does this by deleting the balls, lines, and joints and re-creating them by calling <code><a class="el" href="class_c_newtons_cradle.html#ade953fca77863053020e04bd783ff0d7" title="Create all balls.">CNewtonsCradle::Create</a></code> used above in the constructor. <code><a class="el" href="class_c_newtons_cradle.html#a80a13f008f7dfea273b2117f99f67e67" title="Create a ball.">CNewtonsCradle::CreateBall</a></code> deserves a little examination. Almost all of the code there should be familiar except for the last two lines. When these are executed the local variable <code>pBody</code> points to an instance of <code>b2Body</code> representing the newly created ball. The call to </p><pre class="fragment">pBody-&gt;SetAngularDamping(12.0f);
</pre><p>makes sure that the ball does not rotate about its connection point to its distance joint, which if you examine the code closely will be found at the top of the ball. Failure to set the angular damping to a high enough level will result in balls wobbling as shown in <a class="el" href="#fig28">Fig. 28</a>. Finally, the call to </p><pre class="fragment">pBody-&gt;SetLinearDamping(0.1f);
</pre><p>mimics the effect of the balls slowing down due to air friction.</p>
<p><a class="anchor" id="fig28"></a></p><div class="image">
<img src="newton3.png" alt="" width="15%"/>
<div class="caption">
Fig. 28: Ball wobble.</div></div>
<p>The only interesting thing left is <code><a class="el" href="class_c_newtons_cradle.html#abf8af4bdf7ddfac2093d9d23321b4318" title="Reverse motor.">CNewtonsCradle::Action</a></code>, which either stops the balls with a call to <code><a class="el" href="class_c_newtons_cradle.html#a7defc695cf5a90c521f6cad9b4e4c918" title="Reset all balls to initial conditions.">CNewtonsCradle::ResetBalls</a></code> if they are moving or applies an impulse to the requisite number of them (see <a class="el" href="#section4-6">Section 4.6</a> for a reminder) by calling <code>pBody-&gt;ApplyLinearImpulse</code> to apply a horizontal impulse through the center of each ball body.</p>
<p><a class="anchor" id="section5-7"></a></p><h2>5.7 Elephant Drop</h2>
<p>The Elephant Drop level is implemented in class <code><a class="el" href="class_c_pulley.html" title="The pulley class.">CPulley</a></code>, which is derived from <code><a class="el" href="class_c_level.html" title="Stub class for a level.">CLevel</a></code>. As shown in <a class="el" href="#fig9">Fig. 9</a> (left), the level starts with an empty cradle connected to a heavy safe via two pulley wheels and a rope. Handily, Box2D includes a joint called <code>b2b2PulleyJoint</code> that connects a point on an instance of <code>b2Body</code> to another point on a second instance of <code>b2Body</code>. Here the first body will be the wooden cradle on the left side of <a class="el" href="#fig9">Fig. 9</a> (left), and the second body will be the safe on the right side of <a class="el" href="#fig9">Fig. 9</a> (left). The pulley joint is created in the <code><a class="el" href="class_c_pulley.html" title="The pulley class.">CPulley</a></code> constructor by filling in an instance of <code>b2PulleyJointDef</code> and using </p><pre class="fragment">m_pJoint = (b2PulleyJoint*)m_pPhysicsWorld-&gt;CreateJoint;
</pre><p>to save a pointer to the created joint in <code><a class="el" href="class_c_pulley.html#a9dfb43fb080c25b1344a4a01d25109ca" title="Pointer to the pulley joint.">CPulley::m_pJoint</a></code>.</p>
<p>There will be three bodies with attached shapes (see <a class="el" href="#fig29">Fig. 29</a>), large rectangles for the elephant and the safe body respectively, and three narrow overlapping rectangles for the crate body. It is a little tedious to get the initial positions of everything lined up correctly, but you can read the rest of the code for yourself if you wish.</p>
<p><a class="anchor" id="fig29"></a></p><div class="image">
<img src="shape-elephant.png" alt="" width="40%"/>
<div class="caption">
Fig. 29: The Elephant Drop shapes.</div></div>
<p>Unfortunately Box2D's pulley joint <code>b2PulleyJoint</code> does not have the concept of pulley wheels, just the positions of the ropes suspending the bodies attached to the joint. It is up to us to animate the pulley wheels in the correct directions as shown in <a class="el" href="#fig30">Fig. 30</a>. Fortunately <code>b2PulleyJoint</code> has a member function <code>GetCurrentLengthA</code> that returns the length of the left-hand portion of the rope. From this we can deduce how far each pulley wheel must rotate.</p>
<p><a class="anchor" id="fig30"></a></p><div class="image">
<img src="elephant.png" alt="" width="40%"/>
<div class="caption">
Fig. 30: Direction of motion for Elephant Drop.</div></div>
<p>For example, if a call to the pulley joint's <code>GetCurrentLengthA</code> function reveals that the rope has moved distance \(d\) around the circumference of a pulley wheel of radius \(r\) (see <a class="el" href="#fig31">Fig. 31</a>) and the angle subtended by that segment is \(\theta\), then \(\theta = 2 \pi d/c\), where \(c= 2 \pi r\) is the circumference of the circle, and hence \(\theta = d/r\).</p>
<p><a class="anchor" id="fig31"></a></p><div class="image">
<img src="angle.png" alt="" width="12%"/>
<div class="caption">
Fig. 31: Angle from distance around the circumference.</div></div>
<p>This calculation is carried out in <code><a class="el" href="class_c_pulley.html#a94f5a448781d0810d75cc8a8b417828e" title="Rotate the pulley wheels.">CPulley::Move</a></code>. The orientation of each pulley wheel is then set by calling their <code>b2Body</code>'s <code>SetTransform</code> function with \(\theta\) as the orientation parameter and the the body's current position as the position parameter.</p>
<p><a class="anchor" id="section6"></a></p><h1>6. Problems</h1>
<p>In the folder <span style="background-color:#D8E4D8;"><code>8. Box2D Joint Toy</code></span> in your copy of the <span style="background-color:#D8E4D8;"><code>sage-physics</code></span> repository you will find a folder <span style="background-color:#D8E4D8;">Problems</span> which will contain some code to help you get started with the problems below.</p>
<p><a class="anchor" id="section6-1"></a></p><h2>6.1 Windmill Problems</h2>
<p>In the folder <span style="background-color:#D8E4D8;">Windmill</span>, which you will find in the <span style="background-color:#D8E4D8;">Problems</span> folder described in the <a class="el" href="#section6">introduction to Section 6</a> above, open <span style="background-color:#D8E4D8;"><code>Windmill.sln</code></span> with Visual Studio. The key controls in <a class="el" href="#section2">Section 2</a> apply here too, except for the space bar which, instead of reversing the direction of the motor on the revolute joint, launches a collection of crates and balls using code borrowed from the <a href="../bouncy/index.html">Box2D Bouncy Things Toy</a>.</p>
<p><a class="anchor" id="problem8-1-1"></a></p><h3>Problem 8.1.1</h3>
<div style="padding-left: 30px;" markdown="1"> You might recall from <a class="el" href="#section5-1">Section 5.1</a> that the only shape in the Windmill level is a circle for the fan. Therefore, if you hit the space bar repeatedly to fill the window with crates and balls they will overlap the base of the windmill but not the fan, as shown in <a class="el" href="#fig90">Fig. 90</a></div><div style="padding-left: 30px;" markdown="1"><a class="anchor" id="fig90"></a><div class="image">
<img src="wm-blank.png" alt="" width="95%"/>
<div class="caption">
Fig. 90: Filling the windmill level with crates and balls viewed as sprites (left) and lines (right).</div></div>
</div><div style="padding-left: 30px;" markdown="1">Add code to <code><a class="el" href="class_c_windmill.html#abfa2e977d445601d55cd701f6ec1a2b4" title="Create the base.">CWindmill::CreateBase</a></code> that adds shapes to the windmill base object so that the balls collide with the body of the windmill as shown in <a class="el" href="#fig91">Fig. 91</a>.</div><div style="padding-left: 30px;" markdown="1"><a class="anchor" id="fig91"></a><div class="image">
<img src="wm-sln.png" alt="" width="95%"/>
<div class="caption">
Fig. 91: Filling the windmill level with crates and balls viewed as sprites (left) and lines (right).</div></div>
</div><div style="padding-left: 30px;" markdown="1">Note that the shape coordinates in your code need to be in physics coordinates relative to the center of the sprite. You can find the coordinates of the points in image coordinates (relative to the top left corner of the sprite) by opening <span style="background-color:#D8E4D8;">windmillbase.png</span> in an image editing tool such as <span style="background-color:#D8E4D8;">Paint.net</span> (available for free download from <a href="https://www.getpaint.net/download.html">https://www.getpaint.net/download.html</a>. In <span style="background-color:#D8E4D8;">Paint.net</span> style="background-color:#D8E4D8;"&gt; the coordinates of the mouse pointer are given at bottom of the window as shown in <a class="el" href="#fig92">Fig. 92</a>, left. I’ve marked the points from two polygons for you below in <a class="el" href="#fig92">Fig. 92</a>, right. Do the crosspiece yourself. Note that I've given you a handy function <code>RemapPoints</code> in <span style="background-color:#D8E4D8;"><a class="el" href="_windmill_8cpp.html" title="Code for the windmill class CWindmill.">Windmill.cpp</a></span> that takes coordinates from the image and maps them to the correct equivalents for Box2D.</div><div style="padding-left: 30px;" markdown="1"><a class="anchor" id="fig92"></a><div class="image">
<img src="wm-hints.png" alt="" width="70%"/>
<div class="caption">
Fig. 92: Mouse coordinates in paint.net (left), and location of some points (right).</div></div>
</div><div style="padding-left: 30px;" markdown="1"></div><p><a class="anchor" id="section6-2"></a></p><h2>6.2 Round Gear Problems</h2>
<p>In the folder <span style="background-color:#D8E4D8;">Gears</span>, which you will find in the <span style="background-color:#D8E4D8;">Problems</span> folder described in the <a class="el" href="#section6">introduction to Section 6</a> above, open <span style="background-color:#D8E4D8;"><code>Gear Toy.sln</code></span> with Visual Studio. The first level of the Gear Toy corresponds to <a class="el" href="#problem8-2-1">Problem 8.2.1</a> and displays two gears in their start positions and orientations as shown in <a class="el" href="#fig32">Fig. 32</a>. The second level of the Gear Toy corresponds to <a class="el" href="#problem8-2-2">Problem 8.2.2</a> and displays two gears in their start positions and orientations as shown in <a class="el" href="#fig33">Fig. 33</a>. The third level of the Gear Toy corresponds to <a class="el" href="#problem8-2-3">Problem 8.2.3</a> and displays two gears in their start positions and orientations are also as shown in <a class="el" href="#fig33">Fig. 33</a>. The key controls in <a class="el" href="#section2">Section 2</a> apply here too.</p>
<p>In the following problems, an <em>external</em> gear has teeth on the outside and an <em>internal</em> gear has teeth on the inside.</p>
<p><a class="anchor" id="fig32"></a></p><div class="image">
<img src="externalstart.png" alt="" width="180"/>
<div class="caption">
Fig. 32: Start position for the first level.</div></div>
<p><a class="anchor" id="fig33"></a></p><div class="image">
<img src="internalstart.png" alt="" width="256"/>
<div class="caption">
Fig. 33: Start position for the second and third levels.</div></div>
<p><a class="anchor" id="problem8-2-1"></a></p><h3>Problem 8.2.1</h3>
<div style="padding-left: 30px;" markdown="1"> Use two revolute joints and a gear joint to create a toy that has an external gear rotating around a fixed external gear as shown in <a class="el" href="#fig34">Fig. 34</a>. One revolute joint must have a motor and the other must not. To make the space bar reverse the motor, simply place a pointer to the revolute joint with the motor in local variable <code>m_pJoint</code> inherited from <code>CLevel::m_pJoint</code>. Your code must go into the <code>CExternal</code> constructor <code>CExternal::CExternal</code> in file <span style="background-color:#D8E4D8;">Round.cpp</span>. </div><p><a class="anchor" id="fig34"></a></p><div class="image">
<img src="external256.gif" alt=""/>
<div class="caption">
Fig. 34: An external gear rotating around a fixed external gear.</div></div>
<p><a class="anchor" id="problem8-2-2"></a></p><h3>Problem 8.2.2</h3>
<div style="padding-left: 30px;" markdown="1"> Use two revolute joints and a gear joint to create a toy that has an external gear rotating inside a fixed internal gear as shown in <a class="el" href="#fig35">Fig. 35</a>. One revolute joint must have a motor and the other must not. To make the space bar reverse the motor, simply place a pointer to the revolute joint with the motor in local variable <code>m_pJoint</code> inherited from <code>CLevel::m_pJoint</code>. Your code must go into the <code>CInternal</code> constructor <code>CInternal::CInternal</code> in file <span style="background-color:#D8E4D8;">Round.cpp</span>. </div><p><a class="anchor" id="fig35"></a></p><div class="image">
<img src="internal256.gif" alt=""/>
<div class="caption">
Fig. 35: An external gear rotating inside a fixed internal gear.</div></div>
<p><a class="anchor" id="problem8-2-3"></a></p><h3>Problem 8.2.3</h3>
<div style="padding-left: 30px;" markdown="1"> Use two revolute joints and a gear joint to create a toy that has an internal gear rotating around a fixed external gear as shown in <a class="el" href="#fig36">Fig. 36</a>. One revolute joint must have a motor and the other must not. To make the space bar reverse the motor, simply place a pointer to the revolute joint with the motor in local variable <code>m_pJoint</code> inherited from <code>CLevel::m_pJoint</code>. Your code must go into the <code>CInternal2</code> constructor <code>CInternal2::CInternal2</code> in file <span style="background-color:#D8E4D8;">Round.cpp</span>. </div><p><a class="anchor" id="fig36"></a></p><div class="image">
<img src="internal2-320.gif" alt=""/>
<div class="caption">
Fig. 36: An internal gear rotating around a fixed external gear.</div></div>
<p><a class="anchor" id="section6-3"></a></p><h2>6.3 Elliptical Gear Problems</h2>
<p>In the folder <span style="background-color:#D8E4D8;">Gears</span>, which you will find in the <span style="background-color:#D8E4D8;">Problems</span> folder described in the <a class="el" href="#section6">introduction to Section 6</a> above, once again open <span style="background-color:#D8E4D8;"><code>Gear Toy.sln</code></span> with Visual Studio. The fourth level of the Gear Toy corresponds to <a class="el" href="#problem8-3-1">Problem 8.3.1</a> and displays two elliptical gears with the left gear driven by a motor as shown in <a class="el" href="#fig35">Fig.35</a> and the right gear in its initial position. The fifth level of the Gear Toy corresponds to <a class="el" href="#problem8-3-2">Problem 8.3.2</a> and displays two elliptical gears with the left gear driven by a motor as shown in <a class="el" href="#fig35">Fig.35</a> and the right gear in its initial position. Before we start writing code we need some basic math facts about ellipses.</p>
<p>An <em>ellipse</em> is a shape that is formed as follows. Choose two distinct points called the <em>foci</em> (the singular of which is <em>focus</em>) and a distance \(d\). The perimeter of the ellipse is the set of all points \(p\) such that the sum of the two distances from \(p\) to the foci is equal to \(d\). In <a class="el" href="#fig37">Fig. 37</a> (left), the point \(p\) is on the perimeter of the ellipse because \(d_0 + d_1 = d\). If we place the foci on a horizontal line, then the ellipse is symmetrical about horizontal and vertical lines through its center, and the foci are on the horizontal center line equidistant from the center, as we can see in <a class="el" href="#fig37">Fig. 37</a> (right).</p>
<p><a class="anchor" id="fig37"></a></p><div class="image">
<img src="ellipsedef.png" alt="" width="40%"/>
<div class="caption">
Fig. 37: Some ellipse definitions.</div></div>
<p>Let \(a\) be the length of the major (horizontal) axis, \(b\) be the length of the minor (vertical) axis, and \(c\) be the <em>focal distance</em>, that is, the distance from the center to either focus (see <a class="el" href="#fig37">Fig. 37</a> (right)). The focal distance \(c\) is uniquely defined by the major and minor radii \(a\) and \(b\). That is, if we know \(a\) and \(b\), then we can calculate \(c\). This means that we can download an image of an elliptical gear from the internet, measure its height and width, and calculate \(c\) as follows.</p>
<p>Let \(p_0\) be a point at the end of the horizontal axis through the center of the ellipse. Then, as shown in <a class="el" href="#fig38">Fig. 38</a> (left), the distance from \(p_0\) to the leftmost focus is \(a-c\) and the distance from \(p_0\) to the rightmost focus is \(a-c+2c=a+c\). The sum of the two distances is therefore \(2a\). Let \(p_1\) be a point at the end of the vertical axis through the center of the ellipse. Then, as shown in <a class="el" href="#fig38">Fig. 38</a> (right) \(p_1\) is at distance \(\sqrt{c^2+b^2}\) from each focus, which means that the sum of the distances is \(2\sqrt{c^2+b^2}\). Since both \(p_0\) and \(p_1\) are on the perimeter of the ellipse, it must be the case that \(2\sqrt{c^2+b^2} = 2a\), that is, \(c = \sqrt{a^2 - b^2}\).</p>
<p><a class="anchor" id="fig38"></a></p><div class="image">
<img src="ellipse-f.png" alt="" width="40%"/>
<div class="caption">
Fig. 38: Calculating the focal distance.</div></div>
<p>Let \(p = (x,y)\) be the coordinates of a point on an ellipse with major radius \(a\) and minor radius \(b\) centered at the origin. The sum of the distances from \(p\) to the two focal points is   </p><p class="formulaDsp">
\[
\sqrt{(x+c)^2 + y^2} + \sqrt{(x-c)^2 + y^2}  =  2a.
\]
</p>
<p> That is,   </p><p class="formulaDsp">
\[
\sqrt{(x+c)^2 + y^2}  =  2a - \sqrt{(x-c)^2 + y^2}.
\]
</p>
<p> Squaring both sides,        </p><p class="formulaDsp">
\[
\begin{align*}
(x+c)^2 + y^2  &amp;=  \left( 2a - \sqrt{(x-c)^2 + y^2} \right)^2\\
x^2 + 2cx + c^2 + y^2 &amp;=  4a^2 - 4a \sqrt{(x-c)^2 + y^2} + (x-c)^2 + y^2\\
2cx  &amp;=  4a^2 - 4a \sqrt{(x-c)^2 + y^2} - 2cx\\
a^2 - cx  &amp;=  a \sqrt{(x-c)^2 + y^2}.
\end{align*}
\]
</p>
<p> Squaring both sides again,        </p><p class="formulaDsp">
\[
\begin{align*}
(a^2 - cx)^2  &amp;=  a^2 ((x-c)^2 + y^2)\\
c^2x^2 + a^4 &amp;=  a^2x^2 + a^2c^2 + a^2y^2\\
a^4 - a^2c^2 &amp;=  a^2x^2 - c^2x^2 + a^2y^2\\
a^2 (a^2 - c^2) &amp;=  (a^2 - c^2)x^2 + a^2y^2
\end{align*}
\]
</p>
<p> Since \(c^2 = a^2 + b^2\), we can now substitute for \(b^2 = c^2 - a^2\).   </p><p class="formulaDsp">
\[
a^2b^2  =  b^2 x^2 + a^2 y^2.
\]
</p>
<p> Dividing both sides by \(a^2b^2\),   </p><p class="formulaDsp">
\[
\frac{x^2}{a^2} + \frac{y^2}{b^2} = 1. \label{eq1}\tag{Equation 1}
\]
</p>
<p> \(\ref{eq1}\) is the equation for an ellipse in Cartesian coordinates.</p>
<p>Sometimes it is more useful to know the equation of an ellipse in polar coordinates. Let \(r\) be the length of a line at angle \(\theta\) counterclockwise from the long axis. This line ends at some point \(p=(r\cos \theta, r \sin\theta)\) on the ellipse. Therefore, by \(\ref{eq1}\),   </p><p class="formulaDsp">
\[
\frac{r^2\cos^2 \theta}{a^2} + \frac{r^2\sin^2 \theta}{b^2} = 1.
\]
</p>
<p> That is,   </p><p class="formulaDsp">
\[
r = \frac{ab}{\sqrt{b^2\cos^2 \theta + a^2 \sin^2 \theta}}. \label{eq2}\tag{Equation 2}
\]
</p>
<p> \(\ref{eq2}\) is the equation for an ellipse in polar coordinates.</p>
<p>As in <a class="el" href="#section6-2">Section 6.2</a>, navigate to the <span style="background-color:#D8E4D8;">Gears</span> folder and open <span style="background-color:#D8E4D8;"><code>Gears.sln</code></span> with Visual Studio. When you compile and run it, each level will correspond to a problem below and it should react to the key controls in <a class="el" href="#section2">Section 2</a> with the exception of the space bar, more of which later. The first level corresponds to <a class="el" href="#problem8-3-1">Problem 8.3.1</a> and displays two gears in their start positions and orientations as shown in <a class="el" href="#fig32">Fig. 32</a>. The second level corresponds to <a class="el" href="#problem8-3-2">Problem 8.3.2</a> and displays two gears in their start positions and orientations as shown in <a class="el" href="#fig37">Fig. 37</a>.</p>
<p><a class="anchor" id="problem8-3-1"></a></p><h3>Problem 8.3.1</h3>
<div style="padding-left: 30px;" markdown="1"> Consider the two meshed elliptical gears rotating around their centers shown in <a class="el" href="#fig35">Fig.35</a>. The left gear is driven by a motor at a constant rate of rotation. The gear rotates at a varying rate that has two local maxima and two local minima per revolution. These are called <em>double lobe</em> elliptical gears. Suppose that the gear on the left of <a class="el" href="#fig36">Fig. 36</a> is rotated counterclockwise through angle \(\theta_0\). Then the gear on the right rotates counterclockwise through some angle \(\pi/2 - \theta_1\) in order to keep the sum of the two radii along the line joining their centers \(r_0+r_1\) constant. </div><p><a class="anchor" id="fig35"></a></p><div class="image">
<img src="DoubleLobe.gif" alt="" width="300"/>
<div class="caption">
Fig. 35: Double-lobe elliptical gears.</div></div>
<p><a class="anchor" id="fig36"></a></p><div class="image">
<img src="ellipserotate.png" alt="" width="45%"/>
<div class="caption">
Fig. 36: Geometry of double-lobe elliptical gears.</div></div>
<div style="padding-left: 30px;" markdown="1"> We can calculate \(\theta_1\) from \(\theta_0\) in three steps. First we calculate \(r_0\) from \(\theta_0\). Then we calculate \(r_1\) from \(r_0\). Then we calculate \(\theta_1\) from \(r_1\). The first two steps are easy. By \(\ref{eq2}\),   <p class="formulaDsp">
\[
r_0 = \frac{ab}{\sqrt{b^2 \cos^2 \theta_0 + a^2 \sin^2 \theta_0}}.
\]
</p>
 Since the initial position of the gears has one gear rotated by \(\pi/2\) with respect to the other (see <a class="el" href="#fig36">Fig. 36</a>, left), \(r_0+r_1=a+b\). Therefore, \(r_1 = a+b-r_0\).</div><div style="padding-left: 30px;" markdown="1">Now that we have \(r_1\) we can calculate \(\theta_1\) as follows. By \(\ref{eq2}\),   <p class="formulaDsp">
\[
r_1^2 = \frac{a^2b^2}{b^2 \cos^2 (\theta_1 + \pi/2) + a^2 \sin^2 (\theta_1 + \pi/2)},
\]
</p>
 and therefore, inverting both sides and multiplying by \(ab\),   <p class="formulaDsp">
\[
a^2 b^2/r_1^2 = b^2 \cos^2 (\theta_1 + \pi/2) + a^2 \sin^2 (\theta_1 + \pi/2) .
\]
</p>
 Since (by the Theorem of Pythagoras), \(\sin^2 (\theta_1 + \pi/2) = 1 - \cos^2 (\theta_1 + \pi/2)\), we Substitute for \(\sin^2 \theta_1\) in the above,   <p class="formulaDsp">
\[
b^2 \cos^2 (\theta_1 + \pi/2)_1 + a^2 (1 - (\theta_1 + \pi/2)^2 \theta_1) = a^2 b^2/r_1^2.
\]
</p>
 Therefore,   <p class="formulaDsp">
\[
\cos^2 (\theta_1 + \pi/2) = (a^2 b^2/r_1^2 - a^2)/(b^2 - a^2),
\]
</p>
 that is, since \(\cos (x + \pi/2) = \sin x\) for all angles \(x\),   <p class="formulaDsp">
\[
\sin^2 \theta_1  = (a^2 b^2/r_1^2 - a^2)/(b^2 - a^2).
\]
</p>
 Therefore,     <p class="formulaDsp">
\[
\theta_1 =  \sin^{-1} (
\sqrt{a^2 - a^2 b^2/r_1^2}/f
) ,
\]
</p>
 where \(f\) is the focal distance. We can therefore compute \(\theta_1\) from \(\theta_0\) and the major and minor radiuses of the elliptical gears \(a\) and \(b\) respectively as follows: <pre class="fragment">const float CEllipticalGear2::ComputeTheta1(const float a, const float b, const float theta0){
  const float x = b*cosf(theta0);
  const float y = a*sinf(theta0);
  const float r0 = a*b/(sqrtf(x*x + y*y));
  const float r1 = a + b - r0;
  const float f = sqrtf(a*a - b*b); //focal distance
  const float d = a*b/r1;

  return asinf(sqrt(a*a - d*d)/f); 
} //ComputeTheta1
</pre></div><div style="padding-left: 30px;" markdown="1">Therefore the right gear has to be rotated a quarter of a turn counterclockwise from its initial orientation plus \(\theta_1\) clockwise to angle \(\pi - \theta_1\). Finally, note that <code>asinf</code> returns a value in the first or second quadrant, whereas we want an angle that can be in any quadrant. The correct quadrant needs to be corrected in code or else the right gear sprite will jump from one orientation to another at multiples of \(\pi/2\).</div><div style="padding-left: 30px;" markdown="1">Level 4 of the Gear Toy shows two elliptical gears with the left gear driven by a motor as in <a class="el" href="#fig35">Fig. 35</a> and the right gear static in its initial position. Write code for function <code>CEllipticalGear2::Move</code> in file <span style="background-color:#D8E4D8;">Elliptical.cpp</span> to rotate the right gear meshed with the left gear as shown in <a class="el" href="#fig35">Fig. 35</a>. You may use function <code>ComputeTheta1</code> as described above. </div><p><a class="anchor" id="problem8-3-2"></a></p><h3>Problem 8.3.2</h3>
<div style="padding-left: 30px;" markdown="1"> Consider the two meshed elliptical gears rotating around their centers shown in their initial positions in <a class="el" href="#fig37">Fig.37</a> and animated in <a class="el" href="#fig38">Fig.38</a>. The left gear is driven by a motor at a constant rate of rotation. The gear rotates at a varying rate that has one local maximum and one local minimum per revolution. These are called <em>single lobe</em> elliptical gears. Suppose that the gear on the left of <a class="el" href="#fig37">Fig. 37</a> is rotated counterclockwise through angle \(\theta_0\). Then the gear on the right rotates counterclockwise through some angle \(\pi + \theta_1\) in order to keep the sum of the two radii along the line joining their centers \(r_0+r_1\) constant.</div><div style="padding-left: 30px;" markdown="1"><a class="anchor" id="fig37"></a><div class="image">
<img src="elliptical1initial.png" alt="" width="400"/>
<div class="caption">
Fig. 37: Single-lobe elliptical gears in their initial position.</div></div>
</div><div style="padding-left: 30px;" markdown="1"><a class="anchor" id="fig38"></a><div class="image">
<img src="SingleLobe.gif" alt="" width="400"/>
<div class="caption">
Fig. 38: Single-lobe elliptical gears.</div></div>
</div><div style="padding-left: 30px;" markdown="1">We again calculate \(\theta_1\) from \(\theta_0\) in three steps. First we calculate \(r_0\) from \(\theta_0\). Then we calculate \(r_1\) from \(r_0\). Then we calculate \(\theta_1\) from \(r_1\). This time the first step is a little more difficult. Let \(A_0\) be the center of rotation of the left gear and \(B_0\) its other focus, let \(A_1\) be the center of rotation of the right gear and \(B_1\) its other focus, and let \(C\) be the point of contact between the gears, as shown in <a class="el" href="#fig39">Fig. 39</a>. Then \(\triangle A_0B_0C\) is similar to \(\triangle A_1B_1C\) and \(\triangle A_0B_0C\) is as pictured in <a class="el" href="#fig39">Fig. 39</a> (right).</div><div style="padding-left: 30px;" markdown="1"><a class="anchor" id="fig39"></a><div class="image">
<img src="ellipserotate1.png" alt="" width="450"/>
<div class="caption">
Fig. 39: Geometry of single-lobe elliptical gears.</div></div>
</div><div style="padding-left: 30px;" markdown="1">Applying the Law of Cosines to \(\angle B_0A_0C = \theta_0\) (see <a class="el" href="#fig39">Fig. 39</a>, right),   <p class="formulaDsp">
\[
r_1^2 = r_0^2 + 4c^2 - 4cr_0 \cos \theta_0. 
\]
</p>
 Recall that \(r_0+r_1 = 2a\) (see <a class="el" href="#fig37">Fig. 37</a>). Substituting for \(r_1 = 2a - r_0\) in the last equation,   <p class="formulaDsp">
\[
(2a - r_0)^2 =  r_0^2 + 4c^2 - 4c r_0 \cos \theta_0.
\]
</p>
 Solving for \(r_0\),   <p class="formulaDsp">
\[
r_0   = \frac{c^2 - a^2}{c\cos \theta_0 - a}.
\]
</p>
</div><div style="padding-left: 30px;" markdown="1">Calculating \(r_1\) from \(r_0\) is pretty easy. The initial position of the gears has both gears with the same orientation with the foci about which they rotate at distance \(r_0+r_1\) (see <a class="el" href="#fig37">Fig.37</a>, left). Therefore \(r_0+r_1=2f+2(a-c)=2a\) (again, see <a class="el" href="#fig37">Fig.37</a>, left).</div><div style="padding-left: 30px;" markdown="1">To calculate \(\theta_1\) from \(r_1\) we apply the Law of Cosines to \(\angle CB_0A_0 = \theta_1\) (see <a class="el" href="#fig39">Fig. 39</a>, right),   <p class="formulaDsp">
\[
r_0^2 = 4c^2 + r_1^2 - 4cr_1 \cos \theta_1. 
\]
</p>
 Therefore, solving for \(\theta_1\),   <p class="formulaDsp">
\[
\theta_1 = \cos^{-1} \left( \frac{4c^2 + r_1^2 -r_0^2}{4cr_1} \right).
\]
</p>
</div><div style="padding-left: 30px;" markdown="1">Now we can write code to compute the orientation of the right gear <code>theta1</code> from the orientation of the right gear <code>theta0</code> and the ellipse radii <code>a</code> and <code>b</code> as follows. <pre class="fragment">const float CEllipticalGear1::ComputeTheta1(const float a, const float b, const float theta0) const{
  const float f = sqrtf(a*a - b*b); //focal distance
  const float r0 = (f*f - a*a)/(f*cosf(theta0) - a);
  const float r1 = 2*a - r0;

  return acosf((4.0f*f*f + r1*r1 - r0*r0)/(4.0f*f*r1));
} //ComputeTheta1
</pre></div><div style="padding-left: 30px;" markdown="1">Therefore the right gear has to be rotated a quarter of a turn counterclockwise from its initial orientation plus \(\theta_1\) counterclockwise to angle \(\pi \pm \theta_1\). Finally, note that <code>acosf</code> returns a value in the first or second quadrant, whereas we want an angle that can be in any quadrant. The correct quadrant needs to be corrected in code or else the right gear sprite will jump from one orientation to another at multiples of \(\pi/2\).</div><div style="padding-left: 30px;" markdown="1">Level 5 of the Gear Toy shows two elliptical gears with the left gear driven by a motor as in <a class="el" href="#fig37">Fig. 37</a> and the right gear static in its initial position. Write code for function <code>CEllipticalGear1::Move</code> in file <span style="background-color:#D8E4D8;">Elliptical.cpp</span> to rotate the right gear meshed with the left gear as shown in <a class="el" href="#fig37">Fig. 37</a>. </div><p><a class="anchor" id="section7"></a></p><h1>7. What Next?</h1>
<p>Next, take a look at the <a href="../cannon/index.html">Box2D Cannon Game</a>. </p>
</div></div><!-- PageDoc -->
<a href="doxygen_crawl.html"></a>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
